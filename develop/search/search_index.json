{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cleopatra - Matplotlib utility package","text":"<p>cleopatra is a Python package providing a fast and flexible way to build visualize data using matplotlib. It provides functionalities to handle 3D arrays and perform various operations on them, such as plotting, animating, and displaying the array. It also provides functionalities for creating statistical plots.</p>"},{"location":"#main-features","title":"Main Features","text":"<p>The <code>Array</code> class has the following functionalities:</p> <ul> <li>Initialize an array object with the provided parameters.</li> <li>Plot the array with optional parameters to customize the appearance and display cell values.</li> <li>Animate the array over time with optional parameters to customize the animation speed and display points.</li> <li>Display the array with optional parameters to customize the appearance and display point IDs.</li> </ul> <p>The <code>Statistic</code> module provides a class for creating statistical plots, specifically histograms. The class, <code>Statistic</code>, is designed to handle both 1D (single-dimensional) and 2D (multi-dimensional) data.</p>"},{"location":"change-log/","title":"Changelog","text":""},{"location":"change-log/#010-2022-05-24","title":"0.1.0 (2022-05-24)","text":"<ul> <li>First release on PyPI.</li> </ul>"},{"location":"change-log/#024-2022-12-26","title":"0.2.4 (2022-12-26)","text":"<ul> <li>bump up numpy versions to 1.23.5, add pandas</li> </ul>"},{"location":"change-log/#025-2022-12-26","title":"0.2.5 (2022-12-26)","text":"<ul> <li>plot array with discrete bounds takes the bounds as a parameter</li> </ul>"},{"location":"change-log/#026-2023-01-31","title":"0.2.6 (2023-01-31)","text":"<ul> <li>bump up versions</li> <li>add serapeum_utils as a dependency</li> </ul>"},{"location":"change-log/#027-2023-01-31","title":"0.2.7 (2023-01-31)","text":"<ul> <li>bump up numpy to version 1.24.1</li> </ul>"},{"location":"change-log/#030-2023-04-11","title":"0.3.0 (2023-04-11)","text":"<ul> <li>change API to work completly with numpy array inputs</li> <li>chenge to conda config</li> <li>add hpc-utils to filter and access arrays</li> <li>restructure the whole modules to array, statistics, and styles modules.</li> <li>all modules has classes.</li> <li>save animation function using ffmpeg.</li> </ul>"},{"location":"change-log/#031-2023-04-17","title":"0.3.1 (2023-04-17)","text":"<ul> <li>plot RGB plots</li> </ul>"},{"location":"change-log/#032-2023-04-23","title":"0.3.2 (2023-04-23)","text":"<ul> <li>bump up hpc version</li> </ul>"},{"location":"change-log/#033-2023-04-25","title":"0.3.3 (2023-04-25)","text":"<ul> <li>change the default value for the color bar label.</li> </ul>"},{"location":"change-log/#034-2023-04-26","title":"0.3.4 (2023-04-26)","text":"<ul> <li>pass the plot kwargs to the init of the array to scale the color bar using the vmin and vmax.</li> </ul>"},{"location":"change-log/#035-2023-8-31","title":"0.3.5 (2023-8-31)","text":"<ul> <li>Update dependencies</li> </ul>"},{"location":"change-log/#040-2023-9-24","title":"0.4.0 (2023-9-24)","text":"<ul> <li>Add a colors module to handle issues related to</li> <li>Converting colors from one format to another</li> <li>Creating colormaps</li> </ul>"},{"location":"change-log/#041-2024-1-11","title":"0.4.1 (2024-1-11)","text":"<ul> <li>add extent to the array plot.</li> </ul>"},{"location":"change-log/#042-2024-06-30","title":"0.4.2 (2024-06-30)","text":"<ul> <li>Update dependencies</li> </ul>"},{"location":"change-log/#043-2024-07-13","title":"0.4.3 (2024-07-13)","text":"<ul> <li>Add extent to the array plot when plotting an rgb array.</li> <li>Add <code>ax</code>, and <code>fig</code> parameters to the <code>Array</code> constructor method to take an Axes and plot the array on it.</li> <li>Add <code>__str__</code> to the <code>Array</code> class.</li> </ul>"},{"location":"change-log/#050-2024-07-22","title":"0.5.0 (2024-07-22)","text":""},{"location":"change-log/#arrayglyph","title":"ArrayGlyph","text":"<ul> <li>rename the <code>Array</code> class to <code>ArrayGlyph</code>.</li> <li>add <code>scale_percentile</code> method to the <code>Array</code> class to scale the array using the percentile values.</li> <li>the <code>statistic.histogram</code> can plot multiple column array.</li> <li>change the <code>color_scale</code> values to be string (<code>linear</code>, \"power\", ...)</li> <li>the <code>kwargs</code> can be provided to the constructor or the <code>plot</code> method to plot the array.</li> </ul>"},{"location":"change-log/#colors","title":"Colors","text":"<ul> <li>rename the <code>get_rgb</code> to <code>to_rgb</code></li> <li>add <code>get_type</code> to get the type of the color.</li> <li>add <code>to_hex</code> to convert the color to hex.</li> <li>add <code>to_rgb</code> to convert the color to rgb.</li> </ul>"},{"location":"change-log/#051-2024-07-24","title":"0.5.1 (2024-07-24)","text":""},{"location":"change-log/#arrayglyph_1","title":"ArrayGlyph","text":"<ul> <li>the ArrayGlyph constructor uses a masked array instead of a numpy array.</li> </ul>"},{"location":"change-log/#052-2025-05-08","title":"0.5.2 (2025-05-08)","text":""},{"location":"change-log/#dev","title":"Dev","text":"<ul> <li>replace the setup.py with pyproject.toml</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#dependencies","title":"Dependencies","text":""},{"location":"installation/#required-dependencies","title":"Required dependencies","text":"<ul> <li>Python (3.11 or later)</li> <li>numpy (2.0.0 or later)</li> <li>hpc (0.1.4 or later)</li> <li>matplotlib (3.8.4 or later)</li> <li>ffmpeg-python (0.2.0 or later)</li> </ul>"},{"location":"installation/#stable-release","title":"Stable release","text":"<p>Please install <code>cleopatra</code> in a Virtual environment so that its requirements don't tamper with your system's python.</p>"},{"location":"installation/#conda","title":"conda","text":"<p>The easiest way to install <code>cleopatra</code> is using <code>conda</code> package manager. <code>cleopatra</code> is available in the conda-forge channel. To install you can use the following command:</p> <pre><code>conda install -c conda-forge cleopatra\n</code></pre> <p>If this works it will install <code>cleopatra</code> with all dependencies including Python, and you skip the rest of the installation instructions.</p>"},{"location":"installation/#installing-python-and-gdal-dependencies","title":"Installing Python and gdal dependencies","text":"<p>The main dependencies for cleopatra are an installation of Python 3.11+</p>"},{"location":"installation/#installing-python","title":"Installing Python","text":"<p>For Python, we recommend using the Anaconda Distribution for Python 3, which is available for download from https://www.anaconda.com/download/. The installer gives the option to add <code>python</code> to your <code>PATH</code> environment variable. We will assume in the instructions below that it is available in the path, such that <code>python</code>, <code>pip</code>, and <code>conda</code> are all available from the command line.</p> <p>Note that there is no hard requirement specifically for Anaconda's Python, but often it makes installation of required dependencies easier using the conda package manager.</p>"},{"location":"installation/#install-as-a-conda-environment","title":"Install as a conda environment","text":"<p>The easiest and most robust way to install Hapi is by installing it in a separate conda environment. In the root repository directory there is an <code>environment.yml</code> file. This file lists all dependencies. Either use the <code>environment.yml</code> file from the master branch (please note that the master branch can change rapidly and break functionality without warning), or from one of the releases {release}.</p> <p>Run this command to start installing all Hapi dependencies:</p> <pre><code>conda env create -f environment.yml\n</code></pre> <p>This creates a new environment with the name <code>cleopatra</code>. To activate this environment in a session, run:</p> <pre><code>conda activate cleopatra\n</code></pre> <p>For the installation of Hapi there are two options (from the Python Package Index (PyPI) or from Github). To install a release of Hapi from the PyPI (available from release 2018.1):</p> <pre><code>pip install cleopatra=={release}\n</code></pre>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>The sources for HapiSM can be downloaded from the Github repo.</p> <p>You can either clone the public repository:</p> <pre><code>git clone git://github.com/Serapieum-of-alex/cleopatra\n</code></pre> <p>Or download the tarball:</p> <pre><code>curl -OJL https://github.com/Serapieum-of-alex/cleopatra/tarball/main\n</code></pre> <p>Once you have a copy of the source, you can install it with:</p> <pre><code>python pip install .\n</code></pre> <p>To install directly from GitHub (from the HEAD of the master branch):</p> <pre><code>pip install git+https://github.com/Serapieum-of-alex/cleopatra.git\n</code></pre> <p>or from Github from a specific release:</p> <pre><code>pip install git+https://github.com/Serapieum-of-alex/cleopatra.git@{release}\n</code></pre> <p>Now you should be able to start this environment's Python with <code>python</code>, try <code>import cleopatra</code> to see if the package is installed.</p> <p>More details on how to work with conda environments can be found here: https://conda.io/docs/user-guide/tasks/manage-environments.html</p> <p>If you are planning to make changes and contribute to the development of Hapi, it is best to make a git clone of the repository, and do a editable install in the location of you clone. This will not move a copy to your Python installation directory, but instead create a link in your Python installation pointing to the folder you installed it from, such that any changes you make there are directly reflected in your install.</p> <pre><code>git clone https://github.com/Serapieum-of-alex/cleopatra.git\ncd cleopatra\nactivate cleopatra\npip install -e .\n</code></pre> <p>Alternatively, if you want to avoid using <code>git</code> and simply want to test the latest version from the <code>main</code> branch, you can replace the first line with downloading a zip archive from GitHub: https://github.com/Serapieum-of-alex/cleopatra/archive/master.zip libraries.io.</p>"},{"location":"installation/#install-using-pip","title":"Install using pip","text":"<p>Besides the recommended conda environment setup described above, you can also install <code>cleopatra</code> with <code>pip</code>. For the more difficult to install Python dependencies, it is best to use the conda package manager:</p> <pre><code>conda install numpy gdal\n</code></pre> <p>you can check libraries.io to check versions of the libraries</p> <p>Then install a release {release} of cleopatra (available from release 2018.1) with pip:</p> <pre><code>pip install cleopatra=={release}\n</code></pre>"},{"location":"installation/#check-if-the-installation-is-successful","title":"Check if the installation is successful","text":"<p>To check it the install is successful, go to the examples directory and run the following command:</p> <pre><code>python -m cleopatra.*******\n</code></pre> <p>This should run without errors.</p> <p>Note</p> <p>This documentation was generated on {{ date }}</p> <p>Documentation for the development version: https://cleopatra.readthedocs.org/en/latest/</p> <p>Documentation for the stable version: https://cleopatra.readthedocs.org/en/stable/</p>"},{"location":"api/array-glyph-class/","title":"Array Class","text":"<p>The <code>ArrayGlyph</code> class provides functionality for visualizing and manipulating arrays, including plotting, animating, and saving animations.</p>"},{"location":"api/array-glyph-class/#class-documentation","title":"Class Documentation","text":""},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph","title":"<code>cleopatra.array_glyph.ArrayGlyph</code>","text":"<p>A class to handle 3D arrays and perform various operations on them.</p> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>class ArrayGlyph:\n    \"\"\"A class to handle 3D arrays and perform various operations on them.\"\"\"\n\n    def __init__(\n        self,\n        array: np.ndarray,\n        exclude_value: List = np.nan,\n        extent: List = None,\n        rgb: List[int] = None,\n        surface_reflectance: int = None,\n        cutoff: List = None,\n        ax: Axes = None,\n        fig: Figure = None,\n        percentile: int = None,\n        **kwargs,\n    ):\n        \"\"\"ArrayGlyph.\n\n        Parameters\n        ----------\n        array: np.ndarray\n            array.\n        exclude_value: numeric, Optional, Default is np.nan.\n            value used to fill cells out of the domain.\n        extent: List, Default is None.\n            [xmin, ymin, xmax, ymax].\n        rgb: List\n            the indices of the red, green, and blue bands in the given array. the `rgb` parameter can be a list of\n            three values, or a list of four values if the alpha band is also included.\n        surface_reflectance: int, Default is 10000.\n            surface reflectance value of the sentinel data.\n        cutoff: List, Default is None.\n            clip the range of pixel values for each band. (take only the pixel values from 0 to the value of the cutoff\n            and scale them back to between 0 and 1.\n        percentile: int\n            The percentile value to be used for scaling.\n        **kwargs:\n            figsize : [tuple], optional\n                    figure size. The default is (8,8).\n\n        the object does not need any parameters to be initialized.\n\n        Examples\n        --------\n        - Create an array and instantiate the `Array` object.\n            ```python\n            &gt;&gt;&gt; import numpy as np\n            &gt;&gt;&gt; arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n            &gt;&gt;&gt; array = ArrayGlyph(arr)\n            &gt;&gt;&gt; fig, ax = array.plot()\n            ```\n\n          ![image](../_images/image-plot.png)\n\n        \"\"\"\n        self._default_options = DEFAULT_OPTIONS.copy()\n\n        for key, val in kwargs.items():\n            if key not in self.default_options.keys():\n                raise ValueError(\n                    f\"The given keyword argument:{key} is not correct, possible parameters are,\"\n                    f\" {DEFAULT_OPTIONS}\"\n                )\n            else:\n                self.default_options[key] = val\n        # first replace the no_data_value by nan\n        # convert the array to float32 to be able to replace the no data value with nan\n        if exclude_value is not np.nan:\n            if len(exclude_value) &gt; 1:\n                mask = np.logical_or(\n                    np.isclose(array, exclude_value[0], rtol=0.001),\n                    np.isclose(array, exclude_value[1], rtol=0.001),\n                )\n            else:\n                mask = np.isclose(array, exclude_value[0], rtol=0.0000001)\n            array = ma.array(array, mask=mask, dtype=array.dtype)\n        else:\n            array = ma.array(array)\n\n        # convert the extent from [xmin, ymin, xmax, ymax] to [xmin, xmax, ymin, ymax] as required by matplotlib.\n        if extent is not None:\n            extent = [extent[0], extent[2], extent[1], extent[3]]\n        self.extent = extent\n\n        if rgb is not None:\n            self.rgb = True\n            # prepare to plot rgb plot only if there are three arrays\n            if array.shape[0] &lt; 3:\n                raise ValueError(\n                    f\"To plot RGB plot the given array should have only 3 arrays, given array have \"\n                    f\"{array.shape[0]}\"\n                )\n            else:\n                array = self.prepare_array(\n                    array,\n                    rgb=rgb,\n                    surface_reflectance=surface_reflectance,\n                    cutoff=cutoff,\n                    percentile=percentile,\n                )\n        else:\n            self.rgb = False\n\n        self._exclude_value = exclude_value\n\n        self._vmax = (\n            np.nanmax(array) if kwargs.get(\"vmax\") is None else kwargs.get(\"vmax\")\n        )\n        self._vmin = (\n            np.nanmin(array) if kwargs.get(\"vmin\") is None else kwargs.get(\"vmin\")\n        )\n\n        self.arr = array\n        # get the tick spacing that has 10 ticks only\n        self.ticks_spacing = (self._vmax - self._vmin) / 10\n        shape = array.shape\n        if len(shape) == 3:\n            no_elem = array[0, :, :].count()\n        else:\n            no_elem = array.count()\n\n        self.no_elem = no_elem\n        if fig is None:\n            self.fig, self.ax = self.create_figure_axes()\n        else:\n            self.fig, self.ax = fig, ax\n\n    def prepare_array(\n        self,\n        array: np.ndarray,\n        rgb: List[int] = None,\n        surface_reflectance: int = None,\n        cutoff: List = None,\n        percentile: int = None,\n    ) -&gt; np.ndarray:\n        \"\"\"Prepare Array.\n\n        Parameters\n        ----------\n        array: np.ndarray\n            array.\n        rgb: List, Default is [3,2,1]\n            the indices of the red, green, and blue bands in the given array.\n        surface_reflectance: int, Default is 10000.\n            surface reflectance value of the sentinel data.\n        cutoff: List, Default is None.\n            clip the range of pixel values for each band. (take only the pixel values from 0 to the value of the cutoff\n            and scale them back to between 0 and 1).\n        percentile: int\n            The percentile value to be used for scaling.\n\n        Returns\n        -------\n        np.ndarray: np.float32\n            the rgb 3d array is converted into 2d array to be plotted using the plt.imshow function.\n            a float32 array normalized between 0 and 1 using the percentile values.\n        \"\"\"\n        # take the rgb arrays and reorder them to have the red-green-blue, if the order is not given, assume the\n        # order as sentinel data. [3, 2, 1]\n        array = array[rgb].transpose(1, 2, 0)\n\n        if percentile is not None:\n            array = self.scale_percentile(array, percentile=percentile)\n        elif surface_reflectance is not None:\n            array = self._prepare_sentinel_rgb(\n                array,\n                rgb=rgb,\n                surface_reflectance=surface_reflectance,\n                cutoff=cutoff,\n            )\n        return array\n\n    def _prepare_sentinel_rgb(\n        self,\n        array: np.ndarray,\n        rgb: List[int] = None,\n        surface_reflectance: int = 10000,\n        cutoff: List = None,\n    ) -&gt; np.ndarray:\n        \"\"\"Prepare for RGB plot.\n\n        Parameters\n        ----------\n        array: np.ndarray\n            array.\n        rgb: List, Default is [3,2,1]\n            the indices of the red, green, and blue bands in the given array.\n        surface_reflectance: int, Default is 10000.\n            surface reflectance value of the sentinel data.\n        cutoff: List, Default is None.\n            clip the range of pixel values for each band. (take only the pixel values from 0 to the value of the cutoff\n            and scale them back to between 0 and 1).\n\n        Returns\n        -------\n        np.ndarray:\n            the rgb 3d array is converted into 2d array to be plotted using the plt.imshow function.\n        \"\"\"\n        array = np.clip(array / surface_reflectance, 0, 1)\n        if cutoff is not None:\n            array[0] = np.clip(rgb[0], 0, cutoff[0]) / cutoff[0]\n            array[1] = np.clip(rgb[1], 0, cutoff[1]) / cutoff[1]\n            array[2] = np.clip(rgb[2], 0, cutoff[2]) / cutoff[2]\n\n        return array\n\n    @staticmethod\n    def scale_percentile(arr: np.ndarray, percentile: int = 1) -&gt; np.ndarray:\n        \"\"\"Scale the array.\n\n        Parameters\n        ----------\n        arr: np.ndarray\n            The array to be scaled.\n        percentile: int\n            The percentile value to be used for scaling.\n\n        Returns\n        -------\n        np.ndarray: float32\n            The scaled array, normalized between 0 and 1. using the percentile values.\n        \"\"\"\n        rows, columns, bands = arr.shape\n        # flatten image.\n        arr = np.reshape(arr, [rows * columns, bands]).astype(np.float32)\n        # lower percentile values (one value for each band).\n        lower_percent = np.percentile(arr, percentile, axis=0)\n        # 98 percentile values.\n        upper_percent = np.percentile(arr, 100 - percentile, axis=0) - lower_percent\n        # normalize the 3 bands using the percentile values for each band.\n        arr = (arr - lower_percent[None, :]) / upper_percent[None, :]\n        arr = np.reshape(arr, [rows, columns, bands])\n        # discard outliers.\n        arr = arr.clip(0, 1)\n\n        return arr\n\n    def __str__(self):\n        \"\"\"String representation of the Array object.\"\"\"\n        message = f\"\"\"\n                    Min: {self.vmin}\n                    Max: {self.vmax}\n                    Exclude values: {self.exclude_value}\n                    RGB: {self.rgb}\n                \"\"\"\n        return message\n\n    @property\n    def vmin(self):\n        \"\"\"min value in the array\"\"\"\n        return self._vmin\n\n    @property\n    def vmax(self):\n        \"\"\"max value in the array\"\"\"\n        return self._vmax\n\n    @property\n    def exclude_value(self):\n        \"\"\"exclude_value\"\"\"\n        return self._exclude_value\n\n    @exclude_value.setter\n    def exclude_value(self, value):\n        self._exclude_value = value\n\n    @property\n    def default_options(self):\n        \"\"\"Default plot options\"\"\"\n        return self._default_options\n\n    @property\n    def anim(self):\n        \"\"\"Animation function\"\"\"\n        if hasattr(self, \"_anim\"):\n            val = self._anim\n        else:\n            raise ValueError(\n                \"Please first use the function animate to create the animation object\"\n            )\n        return val\n\n    def create_figure_axes(self) -&gt; Tuple[Figure, Axes]:\n        \"\"\"Create the figure and the axes.\n\n        Returns\n        -------\n        fig: matplotlib.figure.Figure\n            the created figure.\n        ax: matplotlib.axes.Axes\n            the created axes.\n        \"\"\"\n        plt.ioff()  # to prevent the empty figure from being displayed\n        fig, ax = plt.subplots(figsize=self.default_options[\"figsize\"])\n\n        return fig, ax\n\n    def get_ticks(self) -&gt; np.ndarray:\n        \"\"\"get a list of ticks for the color bar\"\"\"\n        ticks_spacing = self.default_options[\"ticks_spacing\"]\n        vmax = self.default_options[\"vmax\"]\n        vmin = self.default_options[\"vmin\"]\n        remainder = np.round(math.remainder(vmax, ticks_spacing), 3)\n        # np.mod(vmax, ticks_spacing) gives float point error, so we use the round function.\n        if remainder == 0:\n            ticks = np.arange(vmin, vmax + ticks_spacing, ticks_spacing)\n        else:\n            try:\n                ticks = np.arange(vmin, vmax + ticks_spacing, ticks_spacing)\n            except ValueError:\n                raise ValueError(\n                    \"The number of ticks exceeded the max allowed size, possible errors\"\n                    f\" is the value of the NodataValue you entered-{self.exclude_value}\"\n                )\n            ticks = np.append(\n                ticks,\n                [int(vmax / ticks_spacing) * ticks_spacing + ticks_spacing],\n            )\n        return ticks\n\n    def _plot_im_get_cbar_kw(\n        self, ax: Axes, arr: np.ndarray, ticks: np.ndarray\n    ) -&gt; Tuple[AxesImage, Dict[str, str]]:\n        \"\"\"Plot a single image and get color bar keyword arguments.\n\n        Parameters\n        ----------\n        ax: [axes]\n            matplotlib figure axes.\n        arr: [array]\n            numpy array.\n        ticks: [list]\n            color bar ticks.\n\n        Returns\n        -------\n        im: AxesImage\n            image axes.\n        cbar: Dict[str,str]\n            color bar keyword arguments.\n        \"\"\"\n        color_scale = self.default_options[\"color_scale\"]\n        cmap = self.default_options[\"cmap\"]\n        # get the vmin and vmax from the tick instead of the default values.\n        vmin: float = ticks[0]  # self.default_options[\"vmin\"]\n        vmax: float = ticks[-1]  # self.default_options[\"vmax\"]\n\n        if color_scale.lower() == \"linear\":\n            im = ax.matshow(arr, cmap=cmap, vmin=vmin, vmax=vmax, extent=self.extent)\n            cbar_kw = dict(ticks=ticks)\n        elif color_scale.lower() == \"power\":\n            im = ax.matshow(\n                arr,\n                cmap=cmap,\n                norm=colors.PowerNorm(\n                    gamma=self.default_options[\"gamma\"], vmin=vmin, vmax=vmax\n                ),\n                extent=self.extent,\n            )\n            cbar_kw = dict(ticks=ticks)\n        elif color_scale.lower() == \"sym-lognorm\":\n            im = ax.matshow(\n                arr,\n                cmap=cmap,\n                norm=colors.SymLogNorm(\n                    linthresh=self.default_options[\"line_threshold\"],\n                    linscale=self.default_options[\"line_scale\"],\n                    base=np.e,\n                    vmin=vmin,\n                    vmax=vmax,\n                ),\n                extent=self.extent,\n            )\n            formatter = LogFormatter(10, labelOnlyBase=False)\n            cbar_kw = dict(ticks=ticks, format=formatter)\n        elif color_scale.lower() == \"boundary-norm\":\n            if not self.default_options[\"bounds\"]:\n                bounds = ticks\n                cbar_kw = dict(ticks=ticks)\n            else:\n                bounds = self.default_options[\"bounds\"]\n                cbar_kw = dict(ticks=self.default_options[\"bounds\"])\n            norm = colors.BoundaryNorm(boundaries=bounds, ncolors=256)\n            im = ax.matshow(arr, cmap=cmap, norm=norm, extent=self.extent)\n        elif color_scale.lower() == \"midpoint\":\n            arr = arr.filled(np.nan)\n            im = ax.matshow(\n                arr,\n                cmap=cmap,\n                norm=MidpointNormalize(\n                    midpoint=self.default_options[\"midpoint\"],\n                    vmin=vmin,\n                    vmax=vmax,\n                ),\n                extent=self.extent,\n            )\n            cbar_kw = dict(ticks=ticks)\n        else:\n            raise ValueError(\n                f\"Invalid color scale option: {color_scale}. Use 'linear', 'power', 'power-norm',\"\n                \"'sym-lognorm', 'boundary-norm'\"\n            )\n\n        return im, cbar_kw\n\n    @staticmethod\n    def _plot_text(\n        ax: Axes, arr: np.ndarray, indices, default_options_dict: dict\n    ) -&gt; list:\n        \"\"\"plot values as a text in each cell.\n\n        Parameters\n        ----------\n        ax:[matplotlib ax]\n            matplotlib axes\n        indices: [array]\n            array with columns, (row, col)\n        default_options_dict: Dict\n            default options dictionary after updating the options.\n\n        Returns\n        -------\n        list:\n            list of the text object\n        \"\"\"\n        # https://github.com/Serapieum-of-alex/cleopatra/issues/75\n        # add text for the cell values\n        add_text = lambda elem: ax.text(\n            elem[1],\n            elem[0],\n            np.round(arr[elem[0], elem[1]], 2),\n            ha=\"center\",\n            va=\"center\",\n            color=\"w\",\n            fontsize=default_options_dict[\"num_size\"],\n        )\n        return list(map(add_text, indices))\n\n    @staticmethod\n    def _plot_point_values(ax, point_table: np.ndarray, pid_color, pid_size):\n        write_points = lambda x: ax.text(\n            x[2],\n            x[1],\n            x[0],\n            ha=\"center\",\n            va=\"center\",\n            color=pid_color,\n            fontsize=pid_size,\n        )\n        return list(map(write_points, point_table))\n\n    def create_color_bar(self, ax: Axes, im: AxesImage, cbar_kw: dict) -&gt; Colorbar:\n        \"\"\"Create Color bar.\n\n        Parameters\n        ----------\n        ax: Axes\n            matplotlib axes.\n        im: AxesImage\n            Image axes.\n        cbar_kw: dict\n            color bar keyword arguments.\n\n        Returns\n        -------\n        Colorbar:\n            colorbar object.\n        \"\"\"\n        # im or cax is the last image added to the axes\n        # im = ax.images[-1]\n        cbar = ax.figure.colorbar(\n            im,\n            ax=ax,\n            shrink=self.default_options[\"cbar_length\"],\n            orientation=self.default_options[\"cbar_orientation\"],\n            **cbar_kw,\n        )\n        # cbar.ax.set_ylabel(\n        #     self.default_options[\"cbar_label\"],\n        #     rotation=self.default_options[\"cbar_label_rotation\"],\n        #     va=self.default_options[\"cbar_label_location\"],\n        #     fontsize=self.default_options[\"cbar_label_size\"],\n        # )\n        cbar.ax.tick_params(labelsize=10)\n        cbar.set_label(\n            self.default_options[\"cbar_label\"],\n            fontsize=self.default_options[\"cbar_label_size\"],\n            loc=self.default_options[\"cbar_label_location\"],\n        )\n\n        return cbar\n\n    def plot(\n        self,\n        points: np.ndarray = None,\n        point_color: str = \"red\",\n        point_size: Union[int, float] = 100,\n        pid_color=\"blue\",\n        pid_size: Union[int, float] = 10,\n        **kwargs,\n    ) -&gt; Tuple[Figure, Axes]:\n        \"\"\"plot an array.\n\n        Parameters\n        ----------\n        points : [array]\n            3 column array with the first column as the value you want to display for the point, the second is the rows'\n            index of the point in the array, and the third column as the column index in the array.\n            - the second and third column tells the location of the point in the array.\n        point_color: [str]\n            color.\n        point_size: [Any]\n            size of the point.\n        pid_color: [str]\n            the annotation color of the point. Default is blue.\n        pid_size: [Any]\n            size of the point annotation.\n        **kwargs: [dict]\n            title: [str], optional\n                title of the plot. The default is 'Total Discharge'.\n            title_size: [integer], optional, default is 15.\n                title size.\n            cbar_orientation: [string], optional, default is 'vertical'\n                orientation of the color bar horizontal/vertical.\n            cbar_label_rotation: [number], optional, default is -90.\n                rotation of the color bar label.\n            cbar_label_location: str, optional, default is 'bottom'.\n                location of the color bar title 'top', 'bottom', 'center', 'baseline', 'center_baseline'.\n            cbar_length: float, optional\n                ratio to control the height of the color bar. The default is 0.75.\n            ticks_spacing: int, optional\n                Spacing in the color bar ticks. The default is 2.\n            cbar_label_size: integer, optional\n                size of the color bar label. The default is 12.\n            cbar_label: str, optional\n                label of the color bar. The default is 'Discharge m3/s'.\n            color_scale : integer, optional, default is 1.\n                there are 5 options to change the scale of the colors.\n\n                1- `linear`:\n                    linear scale.\n                2- `power`:\n                    for the power scale. Linearly map a given value to the 0-1 range and then apply a power-law\n                    normalization over that range.\n                3- `sym-lognorm`:\n                    the symmetrical logarithmic scale `SymLogNorm` is logarithmic in both the positive and\n                    negative directions from the origin.\n                4- `boundary-norm`:\n                    the BoundaryNorm scale generates a colormap index based on discrete intervals.\n                5- `midpoint`:\n                    the midpoint scale splits the scale into 2 halfs, be the given value.\n            gamma: [float], optional, default is 0.5.\n                value needed for the color_scale `power`.\n            line_threshold: float, optional, default is 0.0001.\n                value needed for the color_scale `sym-lognorm`.\n            line_scale: float, optional, default is 0.001.\n                value needed for the color_scale `sym-lognorm`.\n            bounds: List, default is None,\n                a list of number to be used as a discrete bounds for the color scale `boundary-norm`.\n            midpoint: float, optional, default is 0.\n                value needed for the color_scale `midpoint`.\n            cmap: str, optional, default is 'coolwarm_r'.\n                color style.\n            display_cell_value: bool\n                True if you want to display the values of the cells as a text\n            num_size: integer, optional, default is 8.\n                size of the numbers plotted on top of each cell.\n            background_color_threshold: [float/integer], optional, default is None.\n                threshold value if the value of the cell is greater, the plotted\n                numbers will be black, and if smaller the plotted number will be white\n                if None given the max value/2 is considered.\n\n        Returns\n        -------\n        axes: [figure axes].\n            the axes of the matplotlib figure\n        fig: [matplotlib figure object]\n            the figure object\n\n        Examples\n        --------\n        - Create an array and instantiate the `Array` object.\n            ```python\n            &gt;&gt;&gt; import numpy as np\n            &gt;&gt;&gt; arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n            &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Customized Plot\", title_size=18)\n            &gt;&gt;&gt; fig, ax = array.plot()\n            ```\n        ![image](../_images/array-plot.png)\n\n        - Color bar customization:\n\n            - Create an array and instantiate the `Array` object with custom options.\n                ```python\n                &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Customized color bar\", title_size=18)\n                &gt;&gt;&gt; fig, ax = array.plot(\n                ...     cbar_orientation=\"horizontal\",\n                ...     cbar_label_rotation=-90,\n                ...     cbar_label_location=\"center\",\n                ...     cbar_length=0.7,\n                ...     cbar_label_size=12,\n                ...     cbar_label=\"Discharge m3/s\",\n                ...     ticks_spacing=5,\n                ...     color_scale=\"linear\",\n                ...     cmap=\"coolwarm_r\",\n                ... )\n                ```\n                ![image](../_images/color-bar-customization.png)\n\n                - Color bar customization:\n\n        - Display values for each cell:\n\n            - you can display the values for each cell by using thr parameter `display_cell_value`, and customize how\n                the values are displayed using the parameter `background_color_threshold` and `num_size`.\n                ```python\n                &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Display array values\", title_size=18)\n                &gt;&gt;&gt; fig, ax = array.plot(\n                ...     display_cell_value=True,\n                ...     num_size=12\n                ... )\n                ```\n                ![image](../_images/display-cell-values.png)\n\n        - Plot points at specific locations in the array:\n\n            - you can display points in specific cells in the array and also display a value for each of these points.\n                The point parameter takes an array with the first column as the values to be displayed on top of the\n                points, the second and third columns are the row and column index of the point in the array.\n            - The `point_color` and `point_size` parameters are used to customize the appearance of the points,\n                while the `pid_color` and `pid_size` parameters are used to customize the appearance of the point\n                IDs/text.\n                ```python\n                &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Display Points in top of the array\", title_size=14)\n                &gt;&gt;&gt; points = np.array([[1, 0, 0], [2, 1, 1], [3, 2, 2]])\n                &gt;&gt;&gt; fig, ax = array.plot(\n                ...     points=points,\n                ...     point_color=\"black\",\n                ...     point_size=100,\n                ...     pid_color=\"orange\",\n                ...     pid_size=30,\n                ... )\n                ```\n                ![image](../_images/display-points.png)\n\n        - Color scale customization:\n\n            - Power scale.\n\n                - The default power scale uses a gamma value of 0.5.\n                    ```python\n                    &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Power scale\", title_size=18)\n                    &gt;&gt;&gt; fig, ax = array.plot(\n                    ...     cbar_label_rotation=-90,\n                    ...     cbar_label=\"Discharge m3/s\",\n                    ...     color_scale=\"power\",\n                    ...     cmap=\"coolwarm_r\",\n                    ... )\n                    ```\n                    ![image](../_images/power-scale.png)\n\n                - change the gamma of 0.8.\n                    ```python\n                    &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Power scale: gamma=0.8\", title_size=18)\n                    &gt;&gt;&gt; fig, ax = array.plot(\n                    ...     cbar_label_rotation=-90,\n                    ...     cbar_label=\"Discharge m3/s\",\n                    ...     color_scale=\"power\",\n                    ...     gamma=0.8,\n                    ...     cmap=\"coolwarm_r\",\n                    ... )\n                    ```\n                    ![image](../_images/power-scale-gamma-0.8.png)\n\n                - change the gamma of 0.1.\n                    ```python\n                    &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Power scale: gamma=0.1\", title_size=18)\n                    &gt;&gt;&gt; fig, ax = array.plot(\n                    ...     cbar_label_rotation=-90,\n                    ...     cbar_label=\"Discharge m3/s\",\n                    ...     color_scale=\"power\",\n                    ...     gamma=0.1,\n                    ...     cmap=\"coolwarm_r\",\n                    ... )\n                    ```\n                    ![image](../_images/power-scale-gamma-0.1.png)\n\n            - Logarithmic scale.\n\n                - the logarithmic scale uses to parameters `line_threshold` and `line_scale` with a default\n                value if 0.0001, and 0.001 respectively.\n                    ```python\n                    &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"logarithmic scale\", title_size=18)\n                    &gt;&gt;&gt; fig, ax = array.plot(\n                    ...     cbar_label_rotation=-90,\n                    ...     cbar_label=\"Discharge m3/s\",\n                    ...     color_scale=\"sym-lognorm\",\n                    ...     cmap=\"coolwarm_r\",\n                    ... )\n                    ```\n                    ![image](../_images/log-scale.png)\n\n                - you can change the `line_threshold` and `line_scale` values.\n                    ```python\n                    &gt;&gt;&gt; array = ArrayGlyph(\n                    ...     arr, figsize=(6, 6), title=\"Logarithmic scale: Customized Parameter\", title_size=12\n                    ... )\n                    &gt;&gt;&gt; fig, ax = array.plot(\n                    ...     cbar_label_rotation=-90,\n                    ...     cbar_label=\"Discharge m3/s\",\n                    ...     color_scale=\"sym-lognorm\",\n                    ...     cmap=\"coolwarm_r\",\n                    ...     line_threshold=0.015,\n                    ...     line_scale=0.1,\n                    ... )\n                    ```\n                    ![image](../_images/log-scale-custom-parameters.png)\n\n            - Defined boundary scale.\n                ```python\n                &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Defined boundary scale\", title_size=18)\n                &gt;&gt;&gt; fig, ax = array.plot(\n                ...     cbar_label_rotation=-90,\n                ...     cbar_label=\"Discharge m3/s\",\n                ...     color_scale=\"boundary-norm\",\n                ...     cmap=\"coolwarm_r\",\n                ... )\n                ```\n                ![image](../_images/boundary-scale.png)\n\n                - You can also define the boundaries.\n                    ```python\n                    &gt;&gt;&gt; array = ArrayGlyph(\n                    ...     arr, figsize=(6, 6), title=\"Defined boundary scale: defined bounds\", title_size=18\n                    ... )\n                    &gt;&gt;&gt; bounds = [0, 5, 10]\n                    &gt;&gt;&gt; fig, ax = array.plot(\n                    ...     cbar_label_rotation=-90,\n                    ...     cbar_label=\"Discharge m3/s\",\n                    ...     color_scale=\"boundary-norm\",\n                    ...     bounds=bounds,\n                    ...     cmap=\"coolwarm_r\",\n                    ... )\n                    ```\n                    ![image](../_images/boundary-scale-defined-bounds.png)\n\n            - Midpoint scale.\n                ```python\n                in the midpoint scale you can define a value that splits the scale into half.\n                &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Midpoint scale\", title_size=18)\n                &gt;&gt;&gt; fig, ax = array.plot(\n                ...     cbar_label_rotation=-90,\n                ...     cbar_label=\"Discharge m3/s\",\n                ...     color_scale=\"midpoint\",\n                ...     cmap=\"coolwarm_r\",\n                ...     midpoint=2,\n                ... )\n                ```\n                ![image](../_images/midpoint-scale-costom-parameters.png)\n        \"\"\"\n        for key, val in kwargs.items():\n            if key not in self.default_options.keys():\n                raise ValueError(\n                    f\"The given keyword argument:{key} is not correct, possible parameters are,\"\n                    f\" {DEFAULT_OPTIONS}\"\n                )\n            else:\n                self.default_options[key] = val\n\n        arr = self.arr\n        fig, ax = self.fig, self.ax\n\n        if self.rgb:\n            ax.imshow(arr, extent=self.extent)\n        else:\n            # if user did not input ticks spacing use the calculated one.\n            if \"ticks_spacing\" in kwargs.keys():\n                self.default_options[\"ticks_spacing\"] = kwargs[\"ticks_spacing\"]\n            else:\n                self.default_options[\"ticks_spacing\"] = self.ticks_spacing\n\n            if \"vmin\" in kwargs.keys():\n                self.default_options[\"vmin\"] = kwargs[\"vmin\"]\n            else:\n                self.default_options[\"vmin\"] = self.vmin\n\n            if \"vmax\" in kwargs.keys():\n                self.default_options[\"vmax\"] = kwargs[\"vmax\"]\n            else:\n                self.default_options[\"vmax\"] = self.vmax\n\n            # creating the ticks/bounds\n            ticks = self.get_ticks()\n            im, cbar_kw = self._plot_im_get_cbar_kw(ax, arr, ticks)\n\n            # Create colorbar\n            self.create_color_bar(ax, im, cbar_kw)\n\n        ax.set_title(\n            self.default_options[\"title\"], fontsize=self.default_options[\"title_size\"]\n        )\n\n        if self.extent is None:\n            ax.set_xticklabels([])\n            ax.set_yticklabels([])\n            ax.set_xticks([])\n            ax.set_yticks([])\n\n        optional_display = {}\n        if self.default_options[\"display_cell_value\"]:\n            indices = get_indices2(arr, [np.nan])\n            optional_display[\"cell_text_value\"] = self._plot_text(\n                ax, arr, indices, self.default_options\n            )\n\n        if points is not None:\n            row = points[:, 1]\n            col = points[:, 2]\n            optional_display[\"points_scatter\"] = ax.scatter(\n                col, row, color=point_color, s=point_size\n            )\n            optional_display[\"points_id\"] = self._plot_point_values(\n                ax, points, pid_color, pid_size\n            )\n\n        # # Normalize the threshold to the image color range.\n        # if self.default_options[\"background_color_threshold\"] is not None:\n        #     im.norm(self.default_options[\"background_color_threshold\"])\n        # else:\n        #     im.norm(self.vmax) / 2.0\n        plt.show()\n        return fig, ax\n\n    def animate(\n        self,\n        time: List[Any],\n        points: np.ndarray = None,\n        text_colors=(\"white\", \"black\"),\n        interval=200,\n        text_loc: list[Any, Any] = None,\n        point_color=\"red\",\n        point_size=100,\n        pid_color=\"blue\",\n        pid_size=10,\n        **kwargs,\n    ):\n        \"\"\"AnimateArray.\n\n        plot an animation for 3d arrays\n\n        Parameters\n        ----------\n        time : List[Any]\n            A list containing the date of values for each frame in the animation.\n        points : np.ndarray, optional\n            A 3 column array with the first column as the value you want to display for the point, the second is the\n            rows index of the point in the array, and the third column as the column index in the array.\n            - the second and third column tells the location of the point in the array.\n        point_color : str, optional, default is 'red'.\n            The color of the points.\n        point_size: int, optional, default is 100.\n            The size of the point.\n        pid_color : str, optional, default is blue.\n            The annotation color of the point.\n        pid_size : int, optional, default is 10.\n            The size of the point annotation.\n        text_colors : Tuple[str, str], optional, The default is (\"white\",\"black\").\n            Two colors to be used to plot the values on top of each cell.\n        interval: int, optional, default is 200.\n            number to control the speed of the animation.\n        text_loc: list, optional, default is [0.1,0.2].\n            location of the date text.\n        **kwargs: [dict]\n            figsize: [tuple], optional\n                figure size. The default is (8,8).\n            title: [str], optional\n                title of the plot. The default is 'Total Discharge'.\n            title_size: [integer], optional\n                title size. The default is 15.\n            cbar_orientation: [string], optional\n                orientation of the color bar horizontal/vertical. The default is 'vertical'.\n            cbar_label_rotation: [number], optional\n                rotation of the color bar label. The default is -90.\n            cbar_label_location: str, optional, default is 'bottom'.\n                location of the color bar title 'top', 'bottom', 'center', 'baseline', 'center_baseline'.\n            cbar_length: float, optional\n                ratio to control the height of the color bar. The default is 0.75.\n            ticks_spacing: int, optional\n                Spacing in the color bar ticks. The default is 2.\n            cbar_label_size: integer, optional\n                size of the color bar label. The default is 12.\n            cbar_label: str, optional\n                label of the color bar. The default is 'Discharge m3/s'.\n            color_scale : integer, optional, default is 1.\n                there are 5 options to change the scale of the colors.\n\n                1- `linear`:\n                    linear scale.\n                2- `power`:\n                    for the power scale. Linearly map a given value to the 0-1 range and then apply a power-law\n                    normalization over that range.\n                3- `sym-lognorm`:\n                    the symmetrical logarithmic scale `SymLogNorm` is logarithmic in both the positive and\n                    negative directions from the origin.\n                4- `boundary-norm`:\n                    the BoundaryNorm scale generates a colormap index based on discrete intervals.\n                5- `midpoint`:\n                    the midpoint scale splits the scale into 2 halfs, be the given value.\n            gamma: [float], optional, default is 0.5.\n                value needed for the color_scale `power`.\n            line_threshold: float, optional, default is 0.0001.\n                value needed for the color_scale `sym-lognorm`.\n            line_scale: float, optional, default is 0.001.\n                value needed for the color_scale `sym-lognorm`.\n            bounds: List, default is None,\n                a list of number to be used as a discrete bounds for the color scale `boundary-norm`.\n            midpoint: float, optional, default is 0.\n                value needed for the color_scale `midpoint`.\n            cmap: str, optional, default is 'coolwarm_r'.\n                color style.\n            display_cell_value: bool\n                True if you want to display the values of the cells as a text\n            num_size: integer, optional, default is 8.\n                size of the numbers plotted on top of each cell.\n            background_color_threshold: [float/integer], optional, default is None.\n                threshold value if the value of the cell is greater, the plotted\n                numbers will be black, and if smaller the plotted number will be white\n                if None given the max value/2 is considered.\n\n        Returns\n        -------\n        animation.FuncAnimation.\n\n        Examples\n        --------\n        - First create a 3D array with the first dimension `frame_0 = arr[0, :, :]` as the dimension that the function\n            will loop over as the frame, then create a list of what you want to be displayed with each frame (i.e.,\n            time stamp, counter, ...)\n\n        ```python\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; arr = np.random.randint(1, 10, size=(5, 10, 10))\n        &gt;&gt;&gt; animate_time_list = [1, 2, 3, 4, 5]\n        &gt;&gt;&gt; animated_array = ArrayGlyph(arr, figsize=(8, 8), title=\"Animated 3D array\", title_size=18)\n        &gt;&gt;&gt; anim_obj = animated_array.animate(animate_time_list)\n        ```\n\n        ![image](../_images/animated_array.gif)\n\n        - To save the animation to a file, use the `save_animation` method, and provide the frame per second `fps`\n            parameter.\n\n            ```python\n            &gt;&gt;&gt; animated_array.save_animation(\"animated_array.gif\", fps=2)\n            ```\n\n        \"\"\"\n        if text_loc is None:\n            text_loc = [0.1, 0.2]\n\n        for key, val in kwargs.items():\n            if key not in self.default_options.keys():\n                raise ValueError(\n                    f\"The given keyword argument:{key} is not correct, possible parameters are,\"\n                    f\" {DEFAULT_OPTIONS}\"\n                )\n            else:\n                self.default_options[key] = val\n\n        # if user did not input ticks spacing use the calculated one.\n        if \"ticks_spacing\" in kwargs.keys():\n            self.default_options[\"ticks_spacing\"] = kwargs[\"ticks_spacing\"]\n        else:\n            self.default_options[\"ticks_spacing\"] = self.ticks_spacing\n\n        if \"vmin\" in kwargs.keys():\n            self.default_options[\"vmin\"] = kwargs[\"vmin\"]\n        else:\n            self.default_options[\"vmin\"] = self.vmin\n\n        if \"vmax\" in kwargs.keys():\n            self.default_options[\"vmax\"] = kwargs[\"vmax\"]\n        else:\n            self.default_options[\"vmax\"] = self.vmax\n\n        # if optional_display\n        precision = self.default_options[\"precision\"]\n        array = self.arr\n        fig, ax = self.fig, self.ax\n\n        ticks = self.get_ticks()\n        im, cbar_kw = self._plot_im_get_cbar_kw(ax, array[0, :, :], ticks)\n\n        # Create colorbar\n        cbar = ax.figure.colorbar(\n            im,\n            ax=ax,\n            shrink=self.default_options[\"cbar_length\"],\n            orientation=self.default_options[\"cbar_orientation\"],\n            **cbar_kw,\n        )\n        cbar.ax.set_ylabel(\n            self.default_options[\"cbar_label\"],\n            rotation=self.default_options[\"cbar_label_rotation\"],\n            va=self.default_options[\"cbar_label_location\"],\n            fontsize=self.default_options[\"cbar_label_size\"],\n        )\n        cbar.ax.tick_params(labelsize=10)\n\n        ax.set_title(\n            self.default_options[\"title\"], fontsize=self.default_options[\"title_size\"]\n        )\n        ax.set_xticklabels([])\n        ax.set_yticklabels([])\n\n        ax.set_xticks([])\n        ax.set_yticks([])\n\n        if self.default_options[\"display_cell_value\"]:\n            indices = get_indices2(array[0, :, :], [np.nan])\n            cell_text_value = self._plot_text(\n                ax, array[0, :, :], indices, self.default_options\n            )\n            indices = np.array(indices)\n\n        if points is not None:\n            row = points[:, 1]\n            col = points[:, 2]\n            points_scatter = ax.scatter(col, row, color=point_color, s=point_size)\n            points_id = self._plot_point_values(ax, points, pid_color, pid_size)\n\n        # Normalize the threshold to the image color range.\n        if self.default_options[\"background_color_threshold\"] is not None:\n            background_color_threshold = im.norm(\n                self.default_options[\"background_color_threshold\"]\n            )\n        else:\n            background_color_threshold = im.norm(np.nanmax(array)) / 2.0\n\n        day_text = ax.text(\n            text_loc[0],\n            text_loc[1],\n            \" \",\n            fontsize=self.default_options[\"cbar_label_size\"],\n        )\n\n        def init():\n            \"\"\"initialize the plot with the first array\"\"\"\n            im.set_data(array[0, :, :])\n            day_text.set_text(\"\")\n            output = [im, day_text]\n\n            if points is not None:\n                points_scatter.set_offsets(np.c_[col, row])\n                output.append(points_scatter)\n                update_points = lambda x: points_id[x].set_text(points[x, 0])\n                list(map(update_points, range(len(col))))\n\n                output += points_id\n\n            if self.default_options[\"display_cell_value\"]:\n                vals = array[0, indices[:, 0], indices[:, 1]]\n                update_cell_value = lambda x: cell_text_value[x].set_text(vals[x])\n                list(map(update_cell_value, range(self.no_elem)))\n                output += cell_text_value\n\n            return output\n\n        def animate_a(i):\n            \"\"\"plot for each element in the iterable.\"\"\"\n            im.set_data(array[i, :, :])\n            day_text.set_text(\"Date = \" + str(time[i])[0:10])\n            output = [im, day_text]\n\n            if points is not None:\n                points_scatter.set_offsets(np.c_[col, row])\n                output.append(points_scatter)\n\n                for x in range(len(col)):\n                    points_id[x].set_text(points[x, 0])\n\n                output += points_id\n\n            if self.default_options[\"display_cell_value\"]:\n                vals = array[i, indices[:, 0], indices[:, 1]]\n\n                def update_cell_value(x):\n                    \"\"\"Update cell value\"\"\"\n                    val = round(vals[x], precision)\n                    kw = dict(\n                        color=text_colors[\n                            int(im.norm(vals[x]) &gt; background_color_threshold)\n                        ]\n                    )\n                    cell_text_value[x].update(kw)\n                    cell_text_value[x].set_text(val)\n\n                list(map(update_cell_value, range(self.no_elem)))\n\n                output += cell_text_value\n\n            return output\n\n        plt.tight_layout()\n\n        anim = FuncAnimation(\n            fig,\n            animate_a,\n            init_func=init,\n            frames=np.shape(array)[0],\n            interval=interval,\n            blit=True,\n        )\n        self._anim = anim\n        plt.show()\n        return anim\n\n    def save_animation(self, path: str, fps: int = 2):\n        \"\"\"Save the animation.\n\n            - video format is taken from the given path. available [\"gif\", \"mov\", \"avi\", \"mp4\"].\n\n        Parameters\n        ----------\n        path: [str]\n            path\n        fps: [int]\n            frames per second. Default is 2.\n        \"\"\"\n        video_format = path.split(\".\")[-1]\n        if video_format not in SUPPORTED_VIDEO_FORMAT:\n            raise ValueError(\n                f\"The given extension {video_format} implies a format that is not supported, \"\n                f\"only {SUPPORTED_VIDEO_FORMAT} are supported\"\n            )\n\n        if video_format == \"gif\":\n            writer_gif = animation.PillowWriter(fps=fps)\n            self.anim.save(path, writer=writer_gif)\n        else:\n            try:\n                if video_format == \"avi\" or video_format == \"mov\":\n                    writer_video = animation.FFMpegWriter(fps=fps, bitrate=1800)\n                    self.anim.save(path, writer=writer_video)\n                elif video_format == \"mp4\":\n                    writer_mp4 = animation.FFMpegWriter(fps=fps, bitrate=1800)\n                    self.anim.save(path, writer=writer_mp4)\n            except FileNotFoundError:\n                print(\n                    \"Please visit https://ffmpeg.org/ and download a version of ffmpeg compatible with your operating\"\n                    \"system, for more details please check the method definition\"\n                )\n</code></pre>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.anim","title":"<code>anim</code>  <code>property</code>","text":"<p>Animation function</p>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.default_options","title":"<code>default_options</code>  <code>property</code>","text":"<p>Default plot options</p>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.exclude_value","title":"<code>exclude_value</code>  <code>property</code> <code>writable</code>","text":"<p>exclude_value</p>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.vmax","title":"<code>vmax</code>  <code>property</code>","text":"<p>max value in the array</p>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.vmin","title":"<code>vmin</code>  <code>property</code>","text":"<p>min value in the array</p>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.__init__","title":"<code>__init__(array, exclude_value=np.nan, extent=None, rgb=None, surface_reflectance=None, cutoff=None, ax=None, fig=None, percentile=None, **kwargs)</code>","text":"<p>ArrayGlyph.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>array.</p> required <code>exclude_value</code> <code>List</code> <p>value used to fill cells out of the domain.</p> <code>nan</code> <code>extent</code> <code>List</code> <p>[xmin, ymin, xmax, ymax].</p> <code>None</code> <code>rgb</code> <code>List[int]</code> <p>the indices of the red, green, and blue bands in the given array. the <code>rgb</code> parameter can be a list of three values, or a list of four values if the alpha band is also included.</p> <code>None</code> <code>surface_reflectance</code> <code>int</code> <p>surface reflectance value of the sentinel data.</p> <code>None</code> <code>cutoff</code> <code>List</code> <p>clip the range of pixel values for each band. (take only the pixel values from 0 to the value of the cutoff and scale them back to between 0 and 1.</p> <code>None</code> <code>percentile</code> <code>int</code> <p>The percentile value to be used for scaling.</p> <code>None</code> <code>**kwargs</code> <p>figsize : [tuple], optional         figure size. The default is (8,8).</p> <code>{}</code> <code>the</code> required <p>Examples:</p> <ul> <li>Create an array and instantiate the <code>Array</code> object.     <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n&gt;&gt;&gt; array = ArrayGlyph(arr)\n&gt;&gt;&gt; fig, ax = array.plot()\n</code></pre></li> </ul> <p></p> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>def __init__(\n    self,\n    array: np.ndarray,\n    exclude_value: List = np.nan,\n    extent: List = None,\n    rgb: List[int] = None,\n    surface_reflectance: int = None,\n    cutoff: List = None,\n    ax: Axes = None,\n    fig: Figure = None,\n    percentile: int = None,\n    **kwargs,\n):\n    \"\"\"ArrayGlyph.\n\n    Parameters\n    ----------\n    array: np.ndarray\n        array.\n    exclude_value: numeric, Optional, Default is np.nan.\n        value used to fill cells out of the domain.\n    extent: List, Default is None.\n        [xmin, ymin, xmax, ymax].\n    rgb: List\n        the indices of the red, green, and blue bands in the given array. the `rgb` parameter can be a list of\n        three values, or a list of four values if the alpha band is also included.\n    surface_reflectance: int, Default is 10000.\n        surface reflectance value of the sentinel data.\n    cutoff: List, Default is None.\n        clip the range of pixel values for each band. (take only the pixel values from 0 to the value of the cutoff\n        and scale them back to between 0 and 1.\n    percentile: int\n        The percentile value to be used for scaling.\n    **kwargs:\n        figsize : [tuple], optional\n                figure size. The default is (8,8).\n\n    the object does not need any parameters to be initialized.\n\n    Examples\n    --------\n    - Create an array and instantiate the `Array` object.\n        ```python\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        &gt;&gt;&gt; array = ArrayGlyph(arr)\n        &gt;&gt;&gt; fig, ax = array.plot()\n        ```\n\n      ![image](../_images/image-plot.png)\n\n    \"\"\"\n    self._default_options = DEFAULT_OPTIONS.copy()\n\n    for key, val in kwargs.items():\n        if key not in self.default_options.keys():\n            raise ValueError(\n                f\"The given keyword argument:{key} is not correct, possible parameters are,\"\n                f\" {DEFAULT_OPTIONS}\"\n            )\n        else:\n            self.default_options[key] = val\n    # first replace the no_data_value by nan\n    # convert the array to float32 to be able to replace the no data value with nan\n    if exclude_value is not np.nan:\n        if len(exclude_value) &gt; 1:\n            mask = np.logical_or(\n                np.isclose(array, exclude_value[0], rtol=0.001),\n                np.isclose(array, exclude_value[1], rtol=0.001),\n            )\n        else:\n            mask = np.isclose(array, exclude_value[0], rtol=0.0000001)\n        array = ma.array(array, mask=mask, dtype=array.dtype)\n    else:\n        array = ma.array(array)\n\n    # convert the extent from [xmin, ymin, xmax, ymax] to [xmin, xmax, ymin, ymax] as required by matplotlib.\n    if extent is not None:\n        extent = [extent[0], extent[2], extent[1], extent[3]]\n    self.extent = extent\n\n    if rgb is not None:\n        self.rgb = True\n        # prepare to plot rgb plot only if there are three arrays\n        if array.shape[0] &lt; 3:\n            raise ValueError(\n                f\"To plot RGB plot the given array should have only 3 arrays, given array have \"\n                f\"{array.shape[0]}\"\n            )\n        else:\n            array = self.prepare_array(\n                array,\n                rgb=rgb,\n                surface_reflectance=surface_reflectance,\n                cutoff=cutoff,\n                percentile=percentile,\n            )\n    else:\n        self.rgb = False\n\n    self._exclude_value = exclude_value\n\n    self._vmax = (\n        np.nanmax(array) if kwargs.get(\"vmax\") is None else kwargs.get(\"vmax\")\n    )\n    self._vmin = (\n        np.nanmin(array) if kwargs.get(\"vmin\") is None else kwargs.get(\"vmin\")\n    )\n\n    self.arr = array\n    # get the tick spacing that has 10 ticks only\n    self.ticks_spacing = (self._vmax - self._vmin) / 10\n    shape = array.shape\n    if len(shape) == 3:\n        no_elem = array[0, :, :].count()\n    else:\n        no_elem = array.count()\n\n    self.no_elem = no_elem\n    if fig is None:\n        self.fig, self.ax = self.create_figure_axes()\n    else:\n        self.fig, self.ax = fig, ax\n</code></pre>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.__str__","title":"<code>__str__()</code>","text":"<p>String representation of the Array object.</p> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>def __str__(self):\n    \"\"\"String representation of the Array object.\"\"\"\n    message = f\"\"\"\n                Min: {self.vmin}\n                Max: {self.vmax}\n                Exclude values: {self.exclude_value}\n                RGB: {self.rgb}\n            \"\"\"\n    return message\n</code></pre>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.animate","title":"<code>animate(time, points=None, text_colors=('white', 'black'), interval=200, text_loc=None, point_color='red', point_size=100, pid_color='blue', pid_size=10, **kwargs)</code>","text":"<p>AnimateArray.</p> <p>plot an animation for 3d arrays</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>List[Any]</code> <p>A list containing the date of values for each frame in the animation.</p> required <code>points</code> <code>ndarray</code> <p>A 3 column array with the first column as the value you want to display for the point, the second is the rows index of the point in the array, and the third column as the column index in the array. - the second and third column tells the location of the point in the array.</p> <code>None</code> <code>point_color</code> <code>str</code> <p>The color of the points.</p> <code>is 'red'.</code> <code>point_size</code> <p>The size of the point.</p> <code>100</code> <code>pid_color</code> <code>str</code> <p>The annotation color of the point.</p> <code>is blue.</code> <code>pid_size</code> <code>int</code> <p>The size of the point annotation.</p> <code>is 10.</code> <code>text_colors</code> <code>Tuple[str, str], optional, The default is (\"white\",\"black\").</code> <p>Two colors to be used to plot the values on top of each cell.</p> <code>('white', 'black')</code> <code>interval</code> <p>number to control the speed of the animation.</p> <code>200</code> <code>text_loc</code> <code>list[Any, Any]</code> <p>location of the date text.</p> <code>None</code> <code>**kwargs</code> <p>figsize: [tuple], optional     figure size. The default is (8,8). title: [str], optional     title of the plot. The default is 'Total Discharge'. title_size: [integer], optional     title size. The default is 15. cbar_orientation: [string], optional     orientation of the color bar horizontal/vertical. The default is 'vertical'. cbar_label_rotation: [number], optional     rotation of the color bar label. The default is -90. cbar_label_location: str, optional, default is 'bottom'.     location of the color bar title 'top', 'bottom', 'center', 'baseline', 'center_baseline'. cbar_length: float, optional     ratio to control the height of the color bar. The default is 0.75. ticks_spacing: int, optional     Spacing in the color bar ticks. The default is 2. cbar_label_size: integer, optional     size of the color bar label. The default is 12. cbar_label: str, optional     label of the color bar. The default is 'Discharge m3/s'. color_scale : integer, optional, default is 1.     there are 5 options to change the scale of the colors.</p> <pre><code>1- `linear`:\n    linear scale.\n2- `power`:\n    for the power scale. Linearly map a given value to the 0-1 range and then apply a power-law\n    normalization over that range.\n3- `sym-lognorm`:\n    the symmetrical logarithmic scale `SymLogNorm` is logarithmic in both the positive and\n    negative directions from the origin.\n4- `boundary-norm`:\n    the BoundaryNorm scale generates a colormap index based on discrete intervals.\n5- `midpoint`:\n    the midpoint scale splits the scale into 2 halfs, be the given value.\n</code></pre> <p>gamma: [float], optional, default is 0.5.     value needed for the color_scale <code>power</code>. line_threshold: float, optional, default is 0.0001.     value needed for the color_scale <code>sym-lognorm</code>. line_scale: float, optional, default is 0.001.     value needed for the color_scale <code>sym-lognorm</code>. bounds: List, default is None,     a list of number to be used as a discrete bounds for the color scale <code>boundary-norm</code>. midpoint: float, optional, default is 0.     value needed for the color_scale <code>midpoint</code>. cmap: str, optional, default is 'coolwarm_r'.     color style. display_cell_value: bool     True if you want to display the values of the cells as a text num_size: integer, optional, default is 8.     size of the numbers plotted on top of each cell. background_color_threshold: [float/integer], optional, default is None.     threshold value if the value of the cell is greater, the plotted     numbers will be black, and if smaller the plotted number will be white     if None given the max value/2 is considered.</p> <code>{}</code> <p>Returns:</p> Type Description <code>animation.FuncAnimation.</code> <p>Examples:</p> <ul> <li>First create a 3D array with the first dimension <code>frame_0 = arr[0, :, :]</code> as the dimension that the function     will loop over as the frame, then create a list of what you want to be displayed with each frame (i.e.,     time stamp, counter, ...)</li> </ul> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; arr = np.random.randint(1, 10, size=(5, 10, 10))\n&gt;&gt;&gt; animate_time_list = [1, 2, 3, 4, 5]\n&gt;&gt;&gt; animated_array = ArrayGlyph(arr, figsize=(8, 8), title=\"Animated 3D array\", title_size=18)\n&gt;&gt;&gt; anim_obj = animated_array.animate(animate_time_list)\n</code></pre> <p></p> <ul> <li> <p>To save the animation to a file, use the <code>save_animation</code> method, and provide the frame per second <code>fps</code>     parameter.</p> <pre><code>&gt;&gt;&gt; animated_array.save_animation(\"animated_array.gif\", fps=2)\n</code></pre> </li> </ul> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>def animate(\n    self,\n    time: List[Any],\n    points: np.ndarray = None,\n    text_colors=(\"white\", \"black\"),\n    interval=200,\n    text_loc: list[Any, Any] = None,\n    point_color=\"red\",\n    point_size=100,\n    pid_color=\"blue\",\n    pid_size=10,\n    **kwargs,\n):\n    \"\"\"AnimateArray.\n\n    plot an animation for 3d arrays\n\n    Parameters\n    ----------\n    time : List[Any]\n        A list containing the date of values for each frame in the animation.\n    points : np.ndarray, optional\n        A 3 column array with the first column as the value you want to display for the point, the second is the\n        rows index of the point in the array, and the third column as the column index in the array.\n        - the second and third column tells the location of the point in the array.\n    point_color : str, optional, default is 'red'.\n        The color of the points.\n    point_size: int, optional, default is 100.\n        The size of the point.\n    pid_color : str, optional, default is blue.\n        The annotation color of the point.\n    pid_size : int, optional, default is 10.\n        The size of the point annotation.\n    text_colors : Tuple[str, str], optional, The default is (\"white\",\"black\").\n        Two colors to be used to plot the values on top of each cell.\n    interval: int, optional, default is 200.\n        number to control the speed of the animation.\n    text_loc: list, optional, default is [0.1,0.2].\n        location of the date text.\n    **kwargs: [dict]\n        figsize: [tuple], optional\n            figure size. The default is (8,8).\n        title: [str], optional\n            title of the plot. The default is 'Total Discharge'.\n        title_size: [integer], optional\n            title size. The default is 15.\n        cbar_orientation: [string], optional\n            orientation of the color bar horizontal/vertical. The default is 'vertical'.\n        cbar_label_rotation: [number], optional\n            rotation of the color bar label. The default is -90.\n        cbar_label_location: str, optional, default is 'bottom'.\n            location of the color bar title 'top', 'bottom', 'center', 'baseline', 'center_baseline'.\n        cbar_length: float, optional\n            ratio to control the height of the color bar. The default is 0.75.\n        ticks_spacing: int, optional\n            Spacing in the color bar ticks. The default is 2.\n        cbar_label_size: integer, optional\n            size of the color bar label. The default is 12.\n        cbar_label: str, optional\n            label of the color bar. The default is 'Discharge m3/s'.\n        color_scale : integer, optional, default is 1.\n            there are 5 options to change the scale of the colors.\n\n            1- `linear`:\n                linear scale.\n            2- `power`:\n                for the power scale. Linearly map a given value to the 0-1 range and then apply a power-law\n                normalization over that range.\n            3- `sym-lognorm`:\n                the symmetrical logarithmic scale `SymLogNorm` is logarithmic in both the positive and\n                negative directions from the origin.\n            4- `boundary-norm`:\n                the BoundaryNorm scale generates a colormap index based on discrete intervals.\n            5- `midpoint`:\n                the midpoint scale splits the scale into 2 halfs, be the given value.\n        gamma: [float], optional, default is 0.5.\n            value needed for the color_scale `power`.\n        line_threshold: float, optional, default is 0.0001.\n            value needed for the color_scale `sym-lognorm`.\n        line_scale: float, optional, default is 0.001.\n            value needed for the color_scale `sym-lognorm`.\n        bounds: List, default is None,\n            a list of number to be used as a discrete bounds for the color scale `boundary-norm`.\n        midpoint: float, optional, default is 0.\n            value needed for the color_scale `midpoint`.\n        cmap: str, optional, default is 'coolwarm_r'.\n            color style.\n        display_cell_value: bool\n            True if you want to display the values of the cells as a text\n        num_size: integer, optional, default is 8.\n            size of the numbers plotted on top of each cell.\n        background_color_threshold: [float/integer], optional, default is None.\n            threshold value if the value of the cell is greater, the plotted\n            numbers will be black, and if smaller the plotted number will be white\n            if None given the max value/2 is considered.\n\n    Returns\n    -------\n    animation.FuncAnimation.\n\n    Examples\n    --------\n    - First create a 3D array with the first dimension `frame_0 = arr[0, :, :]` as the dimension that the function\n        will loop over as the frame, then create a list of what you want to be displayed with each frame (i.e.,\n        time stamp, counter, ...)\n\n    ```python\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; arr = np.random.randint(1, 10, size=(5, 10, 10))\n    &gt;&gt;&gt; animate_time_list = [1, 2, 3, 4, 5]\n    &gt;&gt;&gt; animated_array = ArrayGlyph(arr, figsize=(8, 8), title=\"Animated 3D array\", title_size=18)\n    &gt;&gt;&gt; anim_obj = animated_array.animate(animate_time_list)\n    ```\n\n    ![image](../_images/animated_array.gif)\n\n    - To save the animation to a file, use the `save_animation` method, and provide the frame per second `fps`\n        parameter.\n\n        ```python\n        &gt;&gt;&gt; animated_array.save_animation(\"animated_array.gif\", fps=2)\n        ```\n\n    \"\"\"\n    if text_loc is None:\n        text_loc = [0.1, 0.2]\n\n    for key, val in kwargs.items():\n        if key not in self.default_options.keys():\n            raise ValueError(\n                f\"The given keyword argument:{key} is not correct, possible parameters are,\"\n                f\" {DEFAULT_OPTIONS}\"\n            )\n        else:\n            self.default_options[key] = val\n\n    # if user did not input ticks spacing use the calculated one.\n    if \"ticks_spacing\" in kwargs.keys():\n        self.default_options[\"ticks_spacing\"] = kwargs[\"ticks_spacing\"]\n    else:\n        self.default_options[\"ticks_spacing\"] = self.ticks_spacing\n\n    if \"vmin\" in kwargs.keys():\n        self.default_options[\"vmin\"] = kwargs[\"vmin\"]\n    else:\n        self.default_options[\"vmin\"] = self.vmin\n\n    if \"vmax\" in kwargs.keys():\n        self.default_options[\"vmax\"] = kwargs[\"vmax\"]\n    else:\n        self.default_options[\"vmax\"] = self.vmax\n\n    # if optional_display\n    precision = self.default_options[\"precision\"]\n    array = self.arr\n    fig, ax = self.fig, self.ax\n\n    ticks = self.get_ticks()\n    im, cbar_kw = self._plot_im_get_cbar_kw(ax, array[0, :, :], ticks)\n\n    # Create colorbar\n    cbar = ax.figure.colorbar(\n        im,\n        ax=ax,\n        shrink=self.default_options[\"cbar_length\"],\n        orientation=self.default_options[\"cbar_orientation\"],\n        **cbar_kw,\n    )\n    cbar.ax.set_ylabel(\n        self.default_options[\"cbar_label\"],\n        rotation=self.default_options[\"cbar_label_rotation\"],\n        va=self.default_options[\"cbar_label_location\"],\n        fontsize=self.default_options[\"cbar_label_size\"],\n    )\n    cbar.ax.tick_params(labelsize=10)\n\n    ax.set_title(\n        self.default_options[\"title\"], fontsize=self.default_options[\"title_size\"]\n    )\n    ax.set_xticklabels([])\n    ax.set_yticklabels([])\n\n    ax.set_xticks([])\n    ax.set_yticks([])\n\n    if self.default_options[\"display_cell_value\"]:\n        indices = get_indices2(array[0, :, :], [np.nan])\n        cell_text_value = self._plot_text(\n            ax, array[0, :, :], indices, self.default_options\n        )\n        indices = np.array(indices)\n\n    if points is not None:\n        row = points[:, 1]\n        col = points[:, 2]\n        points_scatter = ax.scatter(col, row, color=point_color, s=point_size)\n        points_id = self._plot_point_values(ax, points, pid_color, pid_size)\n\n    # Normalize the threshold to the image color range.\n    if self.default_options[\"background_color_threshold\"] is not None:\n        background_color_threshold = im.norm(\n            self.default_options[\"background_color_threshold\"]\n        )\n    else:\n        background_color_threshold = im.norm(np.nanmax(array)) / 2.0\n\n    day_text = ax.text(\n        text_loc[0],\n        text_loc[1],\n        \" \",\n        fontsize=self.default_options[\"cbar_label_size\"],\n    )\n\n    def init():\n        \"\"\"initialize the plot with the first array\"\"\"\n        im.set_data(array[0, :, :])\n        day_text.set_text(\"\")\n        output = [im, day_text]\n\n        if points is not None:\n            points_scatter.set_offsets(np.c_[col, row])\n            output.append(points_scatter)\n            update_points = lambda x: points_id[x].set_text(points[x, 0])\n            list(map(update_points, range(len(col))))\n\n            output += points_id\n\n        if self.default_options[\"display_cell_value\"]:\n            vals = array[0, indices[:, 0], indices[:, 1]]\n            update_cell_value = lambda x: cell_text_value[x].set_text(vals[x])\n            list(map(update_cell_value, range(self.no_elem)))\n            output += cell_text_value\n\n        return output\n\n    def animate_a(i):\n        \"\"\"plot for each element in the iterable.\"\"\"\n        im.set_data(array[i, :, :])\n        day_text.set_text(\"Date = \" + str(time[i])[0:10])\n        output = [im, day_text]\n\n        if points is not None:\n            points_scatter.set_offsets(np.c_[col, row])\n            output.append(points_scatter)\n\n            for x in range(len(col)):\n                points_id[x].set_text(points[x, 0])\n\n            output += points_id\n\n        if self.default_options[\"display_cell_value\"]:\n            vals = array[i, indices[:, 0], indices[:, 1]]\n\n            def update_cell_value(x):\n                \"\"\"Update cell value\"\"\"\n                val = round(vals[x], precision)\n                kw = dict(\n                    color=text_colors[\n                        int(im.norm(vals[x]) &gt; background_color_threshold)\n                    ]\n                )\n                cell_text_value[x].update(kw)\n                cell_text_value[x].set_text(val)\n\n            list(map(update_cell_value, range(self.no_elem)))\n\n            output += cell_text_value\n\n        return output\n\n    plt.tight_layout()\n\n    anim = FuncAnimation(\n        fig,\n        animate_a,\n        init_func=init,\n        frames=np.shape(array)[0],\n        interval=interval,\n        blit=True,\n    )\n    self._anim = anim\n    plt.show()\n    return anim\n</code></pre>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.create_color_bar","title":"<code>create_color_bar(ax, im, cbar_kw)</code>","text":"<p>Create Color bar.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>matplotlib axes.</p> required <code>im</code> <code>AxesImage</code> <p>Image axes.</p> required <code>cbar_kw</code> <code>dict</code> <p>color bar keyword arguments.</p> required <p>Returns:</p> Name Type Description <code>Colorbar</code> <code>Colorbar</code> <p>colorbar object.</p> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>def create_color_bar(self, ax: Axes, im: AxesImage, cbar_kw: dict) -&gt; Colorbar:\n    \"\"\"Create Color bar.\n\n    Parameters\n    ----------\n    ax: Axes\n        matplotlib axes.\n    im: AxesImage\n        Image axes.\n    cbar_kw: dict\n        color bar keyword arguments.\n\n    Returns\n    -------\n    Colorbar:\n        colorbar object.\n    \"\"\"\n    # im or cax is the last image added to the axes\n    # im = ax.images[-1]\n    cbar = ax.figure.colorbar(\n        im,\n        ax=ax,\n        shrink=self.default_options[\"cbar_length\"],\n        orientation=self.default_options[\"cbar_orientation\"],\n        **cbar_kw,\n    )\n    # cbar.ax.set_ylabel(\n    #     self.default_options[\"cbar_label\"],\n    #     rotation=self.default_options[\"cbar_label_rotation\"],\n    #     va=self.default_options[\"cbar_label_location\"],\n    #     fontsize=self.default_options[\"cbar_label_size\"],\n    # )\n    cbar.ax.tick_params(labelsize=10)\n    cbar.set_label(\n        self.default_options[\"cbar_label\"],\n        fontsize=self.default_options[\"cbar_label_size\"],\n        loc=self.default_options[\"cbar_label_location\"],\n    )\n\n    return cbar\n</code></pre>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.create_figure_axes","title":"<code>create_figure_axes()</code>","text":"<p>Create the figure and the axes.</p> <p>Returns:</p> Name Type Description <code>fig</code> <code>Figure</code> <p>the created figure.</p> <code>ax</code> <code>Axes</code> <p>the created axes.</p> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>def create_figure_axes(self) -&gt; Tuple[Figure, Axes]:\n    \"\"\"Create the figure and the axes.\n\n    Returns\n    -------\n    fig: matplotlib.figure.Figure\n        the created figure.\n    ax: matplotlib.axes.Axes\n        the created axes.\n    \"\"\"\n    plt.ioff()  # to prevent the empty figure from being displayed\n    fig, ax = plt.subplots(figsize=self.default_options[\"figsize\"])\n\n    return fig, ax\n</code></pre>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.get_ticks","title":"<code>get_ticks()</code>","text":"<p>get a list of ticks for the color bar</p> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>def get_ticks(self) -&gt; np.ndarray:\n    \"\"\"get a list of ticks for the color bar\"\"\"\n    ticks_spacing = self.default_options[\"ticks_spacing\"]\n    vmax = self.default_options[\"vmax\"]\n    vmin = self.default_options[\"vmin\"]\n    remainder = np.round(math.remainder(vmax, ticks_spacing), 3)\n    # np.mod(vmax, ticks_spacing) gives float point error, so we use the round function.\n    if remainder == 0:\n        ticks = np.arange(vmin, vmax + ticks_spacing, ticks_spacing)\n    else:\n        try:\n            ticks = np.arange(vmin, vmax + ticks_spacing, ticks_spacing)\n        except ValueError:\n            raise ValueError(\n                \"The number of ticks exceeded the max allowed size, possible errors\"\n                f\" is the value of the NodataValue you entered-{self.exclude_value}\"\n            )\n        ticks = np.append(\n            ticks,\n            [int(vmax / ticks_spacing) * ticks_spacing + ticks_spacing],\n        )\n    return ticks\n</code></pre>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.plot","title":"<code>plot(points=None, point_color='red', point_size=100, pid_color='blue', pid_size=10, **kwargs)</code>","text":"<p>plot an array.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>[array]</code> <p>3 column array with the first column as the value you want to display for the point, the second is the rows' index of the point in the array, and the third column as the column index in the array. - the second and third column tells the location of the point in the array.</p> <code>None</code> <code>point_color</code> <code>str</code> <p>color.</p> <code>'red'</code> <code>point_size</code> <code>Union[int, float]</code> <p>size of the point.</p> <code>100</code> <code>pid_color</code> <p>the annotation color of the point. Default is blue.</p> <code>'blue'</code> <code>pid_size</code> <code>Union[int, float]</code> <p>size of the point annotation.</p> <code>10</code> <code>**kwargs</code> <p>title: [str], optional     title of the plot. The default is 'Total Discharge'. title_size: [integer], optional, default is 15.     title size. cbar_orientation: [string], optional, default is 'vertical'     orientation of the color bar horizontal/vertical. cbar_label_rotation: [number], optional, default is -90.     rotation of the color bar label. cbar_label_location: str, optional, default is 'bottom'.     location of the color bar title 'top', 'bottom', 'center', 'baseline', 'center_baseline'. cbar_length: float, optional     ratio to control the height of the color bar. The default is 0.75. ticks_spacing: int, optional     Spacing in the color bar ticks. The default is 2. cbar_label_size: integer, optional     size of the color bar label. The default is 12. cbar_label: str, optional     label of the color bar. The default is 'Discharge m3/s'. color_scale : integer, optional, default is 1.     there are 5 options to change the scale of the colors.</p> <pre><code>1- `linear`:\n    linear scale.\n2- `power`:\n    for the power scale. Linearly map a given value to the 0-1 range and then apply a power-law\n    normalization over that range.\n3- `sym-lognorm`:\n    the symmetrical logarithmic scale `SymLogNorm` is logarithmic in both the positive and\n    negative directions from the origin.\n4- `boundary-norm`:\n    the BoundaryNorm scale generates a colormap index based on discrete intervals.\n5- `midpoint`:\n    the midpoint scale splits the scale into 2 halfs, be the given value.\n</code></pre> <p>gamma: [float], optional, default is 0.5.     value needed for the color_scale <code>power</code>. line_threshold: float, optional, default is 0.0001.     value needed for the color_scale <code>sym-lognorm</code>. line_scale: float, optional, default is 0.001.     value needed for the color_scale <code>sym-lognorm</code>. bounds: List, default is None,     a list of number to be used as a discrete bounds for the color scale <code>boundary-norm</code>. midpoint: float, optional, default is 0.     value needed for the color_scale <code>midpoint</code>. cmap: str, optional, default is 'coolwarm_r'.     color style. display_cell_value: bool     True if you want to display the values of the cells as a text num_size: integer, optional, default is 8.     size of the numbers plotted on top of each cell. background_color_threshold: [float/integer], optional, default is None.     threshold value if the value of the cell is greater, the plotted     numbers will be black, and if smaller the plotted number will be white     if None given the max value/2 is considered.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>axes</code> <code>[figure axes].</code> <p>the axes of the matplotlib figure</p> <code>fig</code> <code>[matplotlib figure object]</code> <p>the figure object</p> <p>Examples:</p> <ul> <li> <p>Create an array and instantiate the <code>Array</code> object.     <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n&gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Customized Plot\", title_size=18)\n&gt;&gt;&gt; fig, ax = array.plot()\n</code></pre> </p> </li> <li> <p>Color bar customization:</p> <ul> <li> <p>Create an array and instantiate the <code>Array</code> object with custom options.     <pre><code>&gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Customized color bar\", title_size=18)\n&gt;&gt;&gt; fig, ax = array.plot(\n...     cbar_orientation=\"horizontal\",\n...     cbar_label_rotation=-90,\n...     cbar_label_location=\"center\",\n...     cbar_length=0.7,\n...     cbar_label_size=12,\n...     cbar_label=\"Discharge m3/s\",\n...     ticks_spacing=5,\n...     color_scale=\"linear\",\n...     cmap=\"coolwarm_r\",\n... )\n</code></pre> </p> <ul> <li>Color bar customization:</li> </ul> </li> </ul> </li> <li> <p>Display values for each cell:</p> <ul> <li>you can display the values for each cell by using thr parameter <code>display_cell_value</code>, and customize how     the values are displayed using the parameter <code>background_color_threshold</code> and <code>num_size</code>.     <pre><code>&gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Display array values\", title_size=18)\n&gt;&gt;&gt; fig, ax = array.plot(\n...     display_cell_value=True,\n...     num_size=12\n... )\n</code></pre> </li> </ul> </li> <li> <p>Plot points at specific locations in the array:</p> <ul> <li>you can display points in specific cells in the array and also display a value for each of these points.     The point parameter takes an array with the first column as the values to be displayed on top of the     points, the second and third columns are the row and column index of the point in the array.</li> <li>The <code>point_color</code> and <code>point_size</code> parameters are used to customize the appearance of the points,     while the <code>pid_color</code> and <code>pid_size</code> parameters are used to customize the appearance of the point     IDs/text.     <pre><code>&gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Display Points in top of the array\", title_size=14)\n&gt;&gt;&gt; points = np.array([[1, 0, 0], [2, 1, 1], [3, 2, 2]])\n&gt;&gt;&gt; fig, ax = array.plot(\n...     points=points,\n...     point_color=\"black\",\n...     point_size=100,\n...     pid_color=\"orange\",\n...     pid_size=30,\n... )\n</code></pre> </li> </ul> </li> <li> <p>Color scale customization:</p> <ul> <li> <p>Power scale.</p> <ul> <li> <p>The default power scale uses a gamma value of 0.5.     <pre><code>&gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Power scale\", title_size=18)\n&gt;&gt;&gt; fig, ax = array.plot(\n...     cbar_label_rotation=-90,\n...     cbar_label=\"Discharge m3/s\",\n...     color_scale=\"power\",\n...     cmap=\"coolwarm_r\",\n... )\n</code></pre> </p> </li> <li> <p>change the gamma of 0.8.     <pre><code>&gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Power scale: gamma=0.8\", title_size=18)\n&gt;&gt;&gt; fig, ax = array.plot(\n...     cbar_label_rotation=-90,\n...     cbar_label=\"Discharge m3/s\",\n...     color_scale=\"power\",\n...     gamma=0.8,\n...     cmap=\"coolwarm_r\",\n... )\n</code></pre> </p> </li> <li> <p>change the gamma of 0.1.     <pre><code>&gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Power scale: gamma=0.1\", title_size=18)\n&gt;&gt;&gt; fig, ax = array.plot(\n...     cbar_label_rotation=-90,\n...     cbar_label=\"Discharge m3/s\",\n...     color_scale=\"power\",\n...     gamma=0.1,\n...     cmap=\"coolwarm_r\",\n... )\n</code></pre> </p> </li> </ul> </li> <li> <p>Logarithmic scale.</p> <ul> <li> <p>the logarithmic scale uses to parameters <code>line_threshold</code> and <code>line_scale</code> with a default value if 0.0001, and 0.001 respectively.     <pre><code>&gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"logarithmic scale\", title_size=18)\n&gt;&gt;&gt; fig, ax = array.plot(\n...     cbar_label_rotation=-90,\n...     cbar_label=\"Discharge m3/s\",\n...     color_scale=\"sym-lognorm\",\n...     cmap=\"coolwarm_r\",\n... )\n</code></pre> </p> </li> <li> <p>you can change the <code>line_threshold</code> and <code>line_scale</code> values.     <pre><code>&gt;&gt;&gt; array = ArrayGlyph(\n...     arr, figsize=(6, 6), title=\"Logarithmic scale: Customized Parameter\", title_size=12\n... )\n&gt;&gt;&gt; fig, ax = array.plot(\n...     cbar_label_rotation=-90,\n...     cbar_label=\"Discharge m3/s\",\n...     color_scale=\"sym-lognorm\",\n...     cmap=\"coolwarm_r\",\n...     line_threshold=0.015,\n...     line_scale=0.1,\n... )\n</code></pre> </p> </li> </ul> </li> <li> <p>Defined boundary scale.     <pre><code>&gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Defined boundary scale\", title_size=18)\n&gt;&gt;&gt; fig, ax = array.plot(\n...     cbar_label_rotation=-90,\n...     cbar_label=\"Discharge m3/s\",\n...     color_scale=\"boundary-norm\",\n...     cmap=\"coolwarm_r\",\n... )\n</code></pre> </p> <ul> <li>You can also define the boundaries.     <pre><code>&gt;&gt;&gt; array = ArrayGlyph(\n...     arr, figsize=(6, 6), title=\"Defined boundary scale: defined bounds\", title_size=18\n... )\n&gt;&gt;&gt; bounds = [0, 5, 10]\n&gt;&gt;&gt; fig, ax = array.plot(\n...     cbar_label_rotation=-90,\n...     cbar_label=\"Discharge m3/s\",\n...     color_scale=\"boundary-norm\",\n...     bounds=bounds,\n...     cmap=\"coolwarm_r\",\n... )\n</code></pre> </li> </ul> </li> <li> <p>Midpoint scale.     <pre><code>in the midpoint scale you can define a value that splits the scale into half.\n&gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Midpoint scale\", title_size=18)\n&gt;&gt;&gt; fig, ax = array.plot(\n...     cbar_label_rotation=-90,\n...     cbar_label=\"Discharge m3/s\",\n...     color_scale=\"midpoint\",\n...     cmap=\"coolwarm_r\",\n...     midpoint=2,\n... )\n</code></pre> </p> </li> </ul> </li> </ul> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>def plot(\n    self,\n    points: np.ndarray = None,\n    point_color: str = \"red\",\n    point_size: Union[int, float] = 100,\n    pid_color=\"blue\",\n    pid_size: Union[int, float] = 10,\n    **kwargs,\n) -&gt; Tuple[Figure, Axes]:\n    \"\"\"plot an array.\n\n    Parameters\n    ----------\n    points : [array]\n        3 column array with the first column as the value you want to display for the point, the second is the rows'\n        index of the point in the array, and the third column as the column index in the array.\n        - the second and third column tells the location of the point in the array.\n    point_color: [str]\n        color.\n    point_size: [Any]\n        size of the point.\n    pid_color: [str]\n        the annotation color of the point. Default is blue.\n    pid_size: [Any]\n        size of the point annotation.\n    **kwargs: [dict]\n        title: [str], optional\n            title of the plot. The default is 'Total Discharge'.\n        title_size: [integer], optional, default is 15.\n            title size.\n        cbar_orientation: [string], optional, default is 'vertical'\n            orientation of the color bar horizontal/vertical.\n        cbar_label_rotation: [number], optional, default is -90.\n            rotation of the color bar label.\n        cbar_label_location: str, optional, default is 'bottom'.\n            location of the color bar title 'top', 'bottom', 'center', 'baseline', 'center_baseline'.\n        cbar_length: float, optional\n            ratio to control the height of the color bar. The default is 0.75.\n        ticks_spacing: int, optional\n            Spacing in the color bar ticks. The default is 2.\n        cbar_label_size: integer, optional\n            size of the color bar label. The default is 12.\n        cbar_label: str, optional\n            label of the color bar. The default is 'Discharge m3/s'.\n        color_scale : integer, optional, default is 1.\n            there are 5 options to change the scale of the colors.\n\n            1- `linear`:\n                linear scale.\n            2- `power`:\n                for the power scale. Linearly map a given value to the 0-1 range and then apply a power-law\n                normalization over that range.\n            3- `sym-lognorm`:\n                the symmetrical logarithmic scale `SymLogNorm` is logarithmic in both the positive and\n                negative directions from the origin.\n            4- `boundary-norm`:\n                the BoundaryNorm scale generates a colormap index based on discrete intervals.\n            5- `midpoint`:\n                the midpoint scale splits the scale into 2 halfs, be the given value.\n        gamma: [float], optional, default is 0.5.\n            value needed for the color_scale `power`.\n        line_threshold: float, optional, default is 0.0001.\n            value needed for the color_scale `sym-lognorm`.\n        line_scale: float, optional, default is 0.001.\n            value needed for the color_scale `sym-lognorm`.\n        bounds: List, default is None,\n            a list of number to be used as a discrete bounds for the color scale `boundary-norm`.\n        midpoint: float, optional, default is 0.\n            value needed for the color_scale `midpoint`.\n        cmap: str, optional, default is 'coolwarm_r'.\n            color style.\n        display_cell_value: bool\n            True if you want to display the values of the cells as a text\n        num_size: integer, optional, default is 8.\n            size of the numbers plotted on top of each cell.\n        background_color_threshold: [float/integer], optional, default is None.\n            threshold value if the value of the cell is greater, the plotted\n            numbers will be black, and if smaller the plotted number will be white\n            if None given the max value/2 is considered.\n\n    Returns\n    -------\n    axes: [figure axes].\n        the axes of the matplotlib figure\n    fig: [matplotlib figure object]\n        the figure object\n\n    Examples\n    --------\n    - Create an array and instantiate the `Array` object.\n        ```python\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Customized Plot\", title_size=18)\n        &gt;&gt;&gt; fig, ax = array.plot()\n        ```\n    ![image](../_images/array-plot.png)\n\n    - Color bar customization:\n\n        - Create an array and instantiate the `Array` object with custom options.\n            ```python\n            &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Customized color bar\", title_size=18)\n            &gt;&gt;&gt; fig, ax = array.plot(\n            ...     cbar_orientation=\"horizontal\",\n            ...     cbar_label_rotation=-90,\n            ...     cbar_label_location=\"center\",\n            ...     cbar_length=0.7,\n            ...     cbar_label_size=12,\n            ...     cbar_label=\"Discharge m3/s\",\n            ...     ticks_spacing=5,\n            ...     color_scale=\"linear\",\n            ...     cmap=\"coolwarm_r\",\n            ... )\n            ```\n            ![image](../_images/color-bar-customization.png)\n\n            - Color bar customization:\n\n    - Display values for each cell:\n\n        - you can display the values for each cell by using thr parameter `display_cell_value`, and customize how\n            the values are displayed using the parameter `background_color_threshold` and `num_size`.\n            ```python\n            &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Display array values\", title_size=18)\n            &gt;&gt;&gt; fig, ax = array.plot(\n            ...     display_cell_value=True,\n            ...     num_size=12\n            ... )\n            ```\n            ![image](../_images/display-cell-values.png)\n\n    - Plot points at specific locations in the array:\n\n        - you can display points in specific cells in the array and also display a value for each of these points.\n            The point parameter takes an array with the first column as the values to be displayed on top of the\n            points, the second and third columns are the row and column index of the point in the array.\n        - The `point_color` and `point_size` parameters are used to customize the appearance of the points,\n            while the `pid_color` and `pid_size` parameters are used to customize the appearance of the point\n            IDs/text.\n            ```python\n            &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Display Points in top of the array\", title_size=14)\n            &gt;&gt;&gt; points = np.array([[1, 0, 0], [2, 1, 1], [3, 2, 2]])\n            &gt;&gt;&gt; fig, ax = array.plot(\n            ...     points=points,\n            ...     point_color=\"black\",\n            ...     point_size=100,\n            ...     pid_color=\"orange\",\n            ...     pid_size=30,\n            ... )\n            ```\n            ![image](../_images/display-points.png)\n\n    - Color scale customization:\n\n        - Power scale.\n\n            - The default power scale uses a gamma value of 0.5.\n                ```python\n                &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Power scale\", title_size=18)\n                &gt;&gt;&gt; fig, ax = array.plot(\n                ...     cbar_label_rotation=-90,\n                ...     cbar_label=\"Discharge m3/s\",\n                ...     color_scale=\"power\",\n                ...     cmap=\"coolwarm_r\",\n                ... )\n                ```\n                ![image](../_images/power-scale.png)\n\n            - change the gamma of 0.8.\n                ```python\n                &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Power scale: gamma=0.8\", title_size=18)\n                &gt;&gt;&gt; fig, ax = array.plot(\n                ...     cbar_label_rotation=-90,\n                ...     cbar_label=\"Discharge m3/s\",\n                ...     color_scale=\"power\",\n                ...     gamma=0.8,\n                ...     cmap=\"coolwarm_r\",\n                ... )\n                ```\n                ![image](../_images/power-scale-gamma-0.8.png)\n\n            - change the gamma of 0.1.\n                ```python\n                &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Power scale: gamma=0.1\", title_size=18)\n                &gt;&gt;&gt; fig, ax = array.plot(\n                ...     cbar_label_rotation=-90,\n                ...     cbar_label=\"Discharge m3/s\",\n                ...     color_scale=\"power\",\n                ...     gamma=0.1,\n                ...     cmap=\"coolwarm_r\",\n                ... )\n                ```\n                ![image](../_images/power-scale-gamma-0.1.png)\n\n        - Logarithmic scale.\n\n            - the logarithmic scale uses to parameters `line_threshold` and `line_scale` with a default\n            value if 0.0001, and 0.001 respectively.\n                ```python\n                &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"logarithmic scale\", title_size=18)\n                &gt;&gt;&gt; fig, ax = array.plot(\n                ...     cbar_label_rotation=-90,\n                ...     cbar_label=\"Discharge m3/s\",\n                ...     color_scale=\"sym-lognorm\",\n                ...     cmap=\"coolwarm_r\",\n                ... )\n                ```\n                ![image](../_images/log-scale.png)\n\n            - you can change the `line_threshold` and `line_scale` values.\n                ```python\n                &gt;&gt;&gt; array = ArrayGlyph(\n                ...     arr, figsize=(6, 6), title=\"Logarithmic scale: Customized Parameter\", title_size=12\n                ... )\n                &gt;&gt;&gt; fig, ax = array.plot(\n                ...     cbar_label_rotation=-90,\n                ...     cbar_label=\"Discharge m3/s\",\n                ...     color_scale=\"sym-lognorm\",\n                ...     cmap=\"coolwarm_r\",\n                ...     line_threshold=0.015,\n                ...     line_scale=0.1,\n                ... )\n                ```\n                ![image](../_images/log-scale-custom-parameters.png)\n\n        - Defined boundary scale.\n            ```python\n            &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Defined boundary scale\", title_size=18)\n            &gt;&gt;&gt; fig, ax = array.plot(\n            ...     cbar_label_rotation=-90,\n            ...     cbar_label=\"Discharge m3/s\",\n            ...     color_scale=\"boundary-norm\",\n            ...     cmap=\"coolwarm_r\",\n            ... )\n            ```\n            ![image](../_images/boundary-scale.png)\n\n            - You can also define the boundaries.\n                ```python\n                &gt;&gt;&gt; array = ArrayGlyph(\n                ...     arr, figsize=(6, 6), title=\"Defined boundary scale: defined bounds\", title_size=18\n                ... )\n                &gt;&gt;&gt; bounds = [0, 5, 10]\n                &gt;&gt;&gt; fig, ax = array.plot(\n                ...     cbar_label_rotation=-90,\n                ...     cbar_label=\"Discharge m3/s\",\n                ...     color_scale=\"boundary-norm\",\n                ...     bounds=bounds,\n                ...     cmap=\"coolwarm_r\",\n                ... )\n                ```\n                ![image](../_images/boundary-scale-defined-bounds.png)\n\n        - Midpoint scale.\n            ```python\n            in the midpoint scale you can define a value that splits the scale into half.\n            &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Midpoint scale\", title_size=18)\n            &gt;&gt;&gt; fig, ax = array.plot(\n            ...     cbar_label_rotation=-90,\n            ...     cbar_label=\"Discharge m3/s\",\n            ...     color_scale=\"midpoint\",\n            ...     cmap=\"coolwarm_r\",\n            ...     midpoint=2,\n            ... )\n            ```\n            ![image](../_images/midpoint-scale-costom-parameters.png)\n    \"\"\"\n    for key, val in kwargs.items():\n        if key not in self.default_options.keys():\n            raise ValueError(\n                f\"The given keyword argument:{key} is not correct, possible parameters are,\"\n                f\" {DEFAULT_OPTIONS}\"\n            )\n        else:\n            self.default_options[key] = val\n\n    arr = self.arr\n    fig, ax = self.fig, self.ax\n\n    if self.rgb:\n        ax.imshow(arr, extent=self.extent)\n    else:\n        # if user did not input ticks spacing use the calculated one.\n        if \"ticks_spacing\" in kwargs.keys():\n            self.default_options[\"ticks_spacing\"] = kwargs[\"ticks_spacing\"]\n        else:\n            self.default_options[\"ticks_spacing\"] = self.ticks_spacing\n\n        if \"vmin\" in kwargs.keys():\n            self.default_options[\"vmin\"] = kwargs[\"vmin\"]\n        else:\n            self.default_options[\"vmin\"] = self.vmin\n\n        if \"vmax\" in kwargs.keys():\n            self.default_options[\"vmax\"] = kwargs[\"vmax\"]\n        else:\n            self.default_options[\"vmax\"] = self.vmax\n\n        # creating the ticks/bounds\n        ticks = self.get_ticks()\n        im, cbar_kw = self._plot_im_get_cbar_kw(ax, arr, ticks)\n\n        # Create colorbar\n        self.create_color_bar(ax, im, cbar_kw)\n\n    ax.set_title(\n        self.default_options[\"title\"], fontsize=self.default_options[\"title_size\"]\n    )\n\n    if self.extent is None:\n        ax.set_xticklabels([])\n        ax.set_yticklabels([])\n        ax.set_xticks([])\n        ax.set_yticks([])\n\n    optional_display = {}\n    if self.default_options[\"display_cell_value\"]:\n        indices = get_indices2(arr, [np.nan])\n        optional_display[\"cell_text_value\"] = self._plot_text(\n            ax, arr, indices, self.default_options\n        )\n\n    if points is not None:\n        row = points[:, 1]\n        col = points[:, 2]\n        optional_display[\"points_scatter\"] = ax.scatter(\n            col, row, color=point_color, s=point_size\n        )\n        optional_display[\"points_id\"] = self._plot_point_values(\n            ax, points, pid_color, pid_size\n        )\n\n    # # Normalize the threshold to the image color range.\n    # if self.default_options[\"background_color_threshold\"] is not None:\n    #     im.norm(self.default_options[\"background_color_threshold\"])\n    # else:\n    #     im.norm(self.vmax) / 2.0\n    plt.show()\n    return fig, ax\n</code></pre>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.prepare_array","title":"<code>prepare_array(array, rgb=None, surface_reflectance=None, cutoff=None, percentile=None)</code>","text":"<p>Prepare Array.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>array.</p> required <code>rgb</code> <code>List[int]</code> <p>the indices of the red, green, and blue bands in the given array.</p> <code>None</code> <code>surface_reflectance</code> <code>int</code> <p>surface reflectance value of the sentinel data.</p> <code>None</code> <code>cutoff</code> <code>List</code> <p>clip the range of pixel values for each band. (take only the pixel values from 0 to the value of the cutoff and scale them back to between 0 and 1).</p> <code>None</code> <code>percentile</code> <code>int</code> <p>The percentile value to be used for scaling.</p> <code>None</code> <p>Returns:</p> Type Description <code>np.ndarray: np.float32</code> <p>the rgb 3d array is converted into 2d array to be plotted using the plt.imshow function. a float32 array normalized between 0 and 1 using the percentile values.</p> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>def prepare_array(\n    self,\n    array: np.ndarray,\n    rgb: List[int] = None,\n    surface_reflectance: int = None,\n    cutoff: List = None,\n    percentile: int = None,\n) -&gt; np.ndarray:\n    \"\"\"Prepare Array.\n\n    Parameters\n    ----------\n    array: np.ndarray\n        array.\n    rgb: List, Default is [3,2,1]\n        the indices of the red, green, and blue bands in the given array.\n    surface_reflectance: int, Default is 10000.\n        surface reflectance value of the sentinel data.\n    cutoff: List, Default is None.\n        clip the range of pixel values for each band. (take only the pixel values from 0 to the value of the cutoff\n        and scale them back to between 0 and 1).\n    percentile: int\n        The percentile value to be used for scaling.\n\n    Returns\n    -------\n    np.ndarray: np.float32\n        the rgb 3d array is converted into 2d array to be plotted using the plt.imshow function.\n        a float32 array normalized between 0 and 1 using the percentile values.\n    \"\"\"\n    # take the rgb arrays and reorder them to have the red-green-blue, if the order is not given, assume the\n    # order as sentinel data. [3, 2, 1]\n    array = array[rgb].transpose(1, 2, 0)\n\n    if percentile is not None:\n        array = self.scale_percentile(array, percentile=percentile)\n    elif surface_reflectance is not None:\n        array = self._prepare_sentinel_rgb(\n            array,\n            rgb=rgb,\n            surface_reflectance=surface_reflectance,\n            cutoff=cutoff,\n        )\n    return array\n</code></pre>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.save_animation","title":"<code>save_animation(path, fps=2)</code>","text":"<p>Save the animation.</p> <pre><code>- video format is taken from the given path. available [\"gif\", \"mov\", \"avi\", \"mp4\"].\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path</p> required <code>fps</code> <code>int</code> <p>frames per second. Default is 2.</p> <code>2</code> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>def save_animation(self, path: str, fps: int = 2):\n    \"\"\"Save the animation.\n\n        - video format is taken from the given path. available [\"gif\", \"mov\", \"avi\", \"mp4\"].\n\n    Parameters\n    ----------\n    path: [str]\n        path\n    fps: [int]\n        frames per second. Default is 2.\n    \"\"\"\n    video_format = path.split(\".\")[-1]\n    if video_format not in SUPPORTED_VIDEO_FORMAT:\n        raise ValueError(\n            f\"The given extension {video_format} implies a format that is not supported, \"\n            f\"only {SUPPORTED_VIDEO_FORMAT} are supported\"\n        )\n\n    if video_format == \"gif\":\n        writer_gif = animation.PillowWriter(fps=fps)\n        self.anim.save(path, writer=writer_gif)\n    else:\n        try:\n            if video_format == \"avi\" or video_format == \"mov\":\n                writer_video = animation.FFMpegWriter(fps=fps, bitrate=1800)\n                self.anim.save(path, writer=writer_video)\n            elif video_format == \"mp4\":\n                writer_mp4 = animation.FFMpegWriter(fps=fps, bitrate=1800)\n                self.anim.save(path, writer=writer_mp4)\n        except FileNotFoundError:\n            print(\n                \"Please visit https://ffmpeg.org/ and download a version of ffmpeg compatible with your operating\"\n                \"system, for more details please check the method definition\"\n            )\n</code></pre>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.scale_percentile","title":"<code>scale_percentile(arr, percentile=1)</code>  <code>staticmethod</code>","text":"<p>Scale the array.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>ndarray</code> <p>The array to be scaled.</p> required <code>percentile</code> <code>int</code> <p>The percentile value to be used for scaling.</p> <code>1</code> <p>Returns:</p> Type Description <code>np.ndarray: float32</code> <p>The scaled array, normalized between 0 and 1. using the percentile values.</p> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>@staticmethod\ndef scale_percentile(arr: np.ndarray, percentile: int = 1) -&gt; np.ndarray:\n    \"\"\"Scale the array.\n\n    Parameters\n    ----------\n    arr: np.ndarray\n        The array to be scaled.\n    percentile: int\n        The percentile value to be used for scaling.\n\n    Returns\n    -------\n    np.ndarray: float32\n        The scaled array, normalized between 0 and 1. using the percentile values.\n    \"\"\"\n    rows, columns, bands = arr.shape\n    # flatten image.\n    arr = np.reshape(arr, [rows * columns, bands]).astype(np.float32)\n    # lower percentile values (one value for each band).\n    lower_percent = np.percentile(arr, percentile, axis=0)\n    # 98 percentile values.\n    upper_percent = np.percentile(arr, 100 - percentile, axis=0) - lower_percent\n    # normalize the 3 bands using the percentile values for each band.\n    arr = (arr - lower_percent[None, :]) / upper_percent[None, :]\n    arr = np.reshape(arr, [rows, columns, bands])\n    # discard outliers.\n    arr = arr.clip(0, 1)\n\n    return arr\n</code></pre>"},{"location":"api/array-glyph-class/#examples","title":"Examples","text":""},{"location":"api/array-glyph-class/#basic-array-plot","title":"Basic Array Plot","text":"<pre><code>import numpy as np\nfrom cleopatra.array_glyph import ArrayGlyph\n\n# Create a sample array\narray = np.random.rand(10, 10)\n\n# Create an ArrayGlyph object\narray_glyph = ArrayGlyph(array)\n\n# Plot the array\nfig, ax, im, cbar = array_glyph.plot()\n</code></pre>"},{"location":"api/array-glyph-class/#display-cell-values","title":"Display Cell Values","text":"<pre><code># Plot the array with cell values displayed\nfig, ax, im, cbar = array_glyph.plot(display_cell_values=True)\n</code></pre>"},{"location":"api/array-glyph-class/#display-points","title":"Display Points","text":"<pre><code># Create some points to display on the array\npoints = np.array([[2, 3, 1], [5, 7, 2], [8, 1, 3]])\n\n# Plot the array with points\nfig, ax, im, cbar = array_glyph.plot(points=points)\n</code></pre>"},{"location":"api/array-glyph-class/#animation","title":"Animation","text":"<pre><code>import numpy as np\nfrom cleopatra.array_glyph import ArrayGlyph\n\n# Create a time series of arrays\ntime_series = [np.random.rand(10, 10) for _ in range(5)]\ntime_labels = [\"t1\", \"t2\", \"t3\", \"t4\", \"t5\"]\n\n# Create an ArrayGlyph object with the first array\narray_glyph = ArrayGlyph(time_series[0])\n\n# Animate the array over time\nanim = array_glyph.animate(time=time_labels, points=points)\n\n# Save the animation\narray_glyph.save_animation(\"animation.gif\", fps=2)\n</code></pre>"},{"location":"api/colors-class/","title":"Colors Class","text":"<p>The <code>Colors</code> class provides functionality for working with colors, including converting between different color formats (hex, RGB), validating color values, and getting the type of color.</p>"},{"location":"api/colors-class/#class-documentation","title":"Class Documentation","text":""},{"location":"api/colors-class/#cleopatra.colors.Colors","title":"<code>cleopatra.colors.Colors</code>","text":"<p>Colors class for Cleopatra.</p> Source code in <code>cleopatra/colors.py</code> <pre><code>class Colors:\n    \"\"\"Colors class for Cleopatra.\"\"\"\n\n    def __init__(\n        self,\n        color_value: Union[\n            List[str], str, Tuple[float, float, float], List[Tuple[float, float, float]]\n        ],\n    ):\n        \"\"\"\n\n        Parameters\n        ----------\n        color_value: List[str]/Tuple[float, float, float]/str.\n            the color value could be a list of hex colors, a tuple of RGB values, or a single hex/RGB color.\n\n        Examples\n        --------\n        - Create a color object from a hex color:\n            ```python\n            &gt;&gt;&gt; hex_number = \"ff0000\"\n            &gt;&gt;&gt; color = Colors(hex_number)\n            &gt;&gt;&gt; print(color.color_value)\n            ['ff0000']\n            ```\n        - Create a color object from an RGB color (values are between 0 and 1):\n            ```python\n            &gt;&gt;&gt; rgb_color = (0.5, 0.2, 0.8)\n            &gt;&gt;&gt; color = Colors(rgb_color)\n            &gt;&gt;&gt; print(color.color_value)\n            [(0.5, 0.2, 0.8)]\n            ```\n        - Create a color object from an RGB color (values are between 0 and 255):\n            ```python\n            &gt;&gt;&gt; rgb_color = (128, 51, 204)\n            &gt;&gt;&gt; color = Colors(rgb_color)\n            &gt;&gt;&gt; print(color.color_value)\n            [(128, 51, 204)]\n            ```\n        \"\"\"\n        # convert the hex color to a list if it is a string\n        if isinstance(color_value, str) or isinstance(color_value, tuple):\n            color_value = [color_value]\n        elif not isinstance(color_value, list):\n            raise ValueError(\n                \"The color_value must be a list of hex colors, list of tuples (RGB color), a single hex \"\n                \"or single RGB tuple color.\"\n            )\n\n        self._color_value = color_value\n\n    def get_type(self) -&gt; List[str]:\n        \"\"\"get_type.\n\n        Returns\n        -------\n        List[str]\n\n        Examples\n        --------\n        - Create a color object from a hex color:\n            ```python\n            &gt;&gt;&gt; hex_number = \"#23a9dd\"\n            &gt;&gt;&gt; color = Colors(hex_number)\n            &gt;&gt;&gt; print(color.get_type())\n            ['hex']\n            ```\n        - Create a color object from an RGB color (values are between 0 and 1):\n            ```python\n            &gt;&gt;&gt; rgb_color = (0.5, 0.2, 0.8)\n            &gt;&gt;&gt; color = Colors(rgb_color)\n            &gt;&gt;&gt; print(color.get_type())\n            ['rgb-normalized']\n            ```\n        - Create a color object from an RGB color (values are between 0 and 255):\n            ```python\n            &gt;&gt;&gt; rgb_color = (128, 51, 204)\n            &gt;&gt;&gt; color = Colors(rgb_color)\n            &gt;&gt;&gt; print(color.get_type())\n            ['rgb']\n            ```\n        \"\"\"\n        color_type = []\n        for color_i in self.color_value:\n            if self.is_valid_rgb_norm(color_i):\n                color_type.append(\"rgb-normalized\")\n            elif self.is_valid_rgb_255(color_i):\n                color_type.append(\"rgb\")\n            elif self.is_valid_hex_i(color_i):\n                color_type.append(\"hex\")\n\n        return color_type\n\n    @property\n    def color_value(self) -&gt; Union[List[str], Tuple[float, float, float]]:\n        \"\"\"Color values given by the user.\n\n        Returns\n        -------\n        List[str]\n        \"\"\"\n        return self._color_value\n\n    def to_hex(self) -&gt; List[str]:\n        \"\"\"Convert colors to hexdecimal format.\n\n        Returns\n        -------\n        List[str]\n            list of hec colors.\n\n        Examples\n        --------\n        - Create a color object from a mixed list of hex and RGB colors:\n            ```python\n            &gt;&gt;&gt; mixed_color = [(128, 51, 204), \"#23a9dd\", (0.5, 0.2, 0.8)]\n            &gt;&gt;&gt; color = Colors(mixed_color)\n            &gt;&gt;&gt; print(color.to_hex())\n            ['#8033cc', '#23a9dd', '#8033cc']\n            ```\n        \"\"\"\n        converted_color = []\n        color_type = self.get_type()\n        for ind, color_i in enumerate(self.color_value):\n            if color_type[ind] == \"hex\":\n                converted_color.append(color_i)\n            elif color_type[ind] == \"rgb\":\n                # Normalize the RGB values to be between 0 and 1\n                rgb_color_normalized = tuple(value / 255 for value in color_i)\n                converted_color.append(mcolors.to_hex(rgb_color_normalized))\n            else:\n                converted_color.append(mcolors.to_hex(color_i))\n        return converted_color\n\n    def is_valid_hex(self) -&gt; List[bool]:\n        \"\"\"is_valid_hex.\n\n            is_valid_hex\n\n        Parameters\n        ----------\n\n        Returns\n        -------\n\n        \"\"\"\n        return [self.is_valid_hex_i(col) for col in self.color_value]\n\n    @staticmethod\n    def is_valid_hex_i(hex_color: str) -&gt; bool:\n        \"\"\"is_valid_hex for single color.\n\n\n        Parameters\n        ----------\n        hex_color: str.\n            single hex color.\n        Returns\n        -------\n        bool\n        \"\"\"\n        return True if mcolors.is_color_like(hex_color) else False\n\n    def is_valid_rgb(self) -&gt; List[bool]:\n        \"\"\"is_valid_rgb.\n\n        Returns\n        -------\n        List[bool]\n            List of boolean values for each color\n        \"\"\"\n        return [\n            self.is_valid_rgb_norm(col) or self.is_valid_rgb_255(col)\n            for col in self.color_value\n        ]\n\n    @staticmethod\n    def is_valid_rgb_255(rgb_tuple: Any) -&gt; bool:\n        \"\"\"validate a single color whither it is rgb or not.\"\"\"\n        if isinstance(rgb_tuple, tuple) and len(rgb_tuple) == 3:\n            if all(isinstance(value, int) for value in rgb_tuple):\n                return all(0 &lt;= value &lt;= 255 for value in rgb_tuple)\n        return False\n\n    @staticmethod\n    def is_valid_rgb_norm(rgb_tuple: Any) -&gt; bool:\n        \"\"\"validate a single color whither it is rgb or not.\"\"\"\n        if isinstance(rgb_tuple, tuple) and len(rgb_tuple) == 3:\n            if all(isinstance(value, float) for value in rgb_tuple):\n                return all(0.0 &lt;= value &lt;= 1.0 for value in rgb_tuple)\n        return False\n\n    def to_rgb(\n        self, normalized: bool = True\n    ) -&gt; List[Tuple[Union[int, float], Union[int, float]]]:\n        \"\"\"get_rgb.\n\n        Parameters\n        ----------\n        normalized: int, Default is True.\n            True if you want the RGB values to be scaled between 0 and 1. False if you want the RGB values to be scaled\n            between 0 and 255.\n\n        Returns\n        -------\n        List[Tuples]\n        \"\"\"\n        color_type = self.get_type()\n        rgb = []\n        if normalized:\n            for ind, color_i in enumerate(self.color_value):\n                # if the color is in RGB format (0-255), normalize the values to be between 0 and 1\n                if color_type[ind] == \"rgb\":\n                    rgb_color_normalized = tuple(value / 255 for value in color_i)\n                    rgb.append(rgb_color_normalized)\n                else:\n                    # any other format, just convert it to RGB\n                    rgb.append(mcolors.to_rgb(color_i))\n        else:\n            for ind, color_i in enumerate(self.color_value):\n                # if the color is in RGB format (0-255), normalize the values to be between 0 and 1\n                if color_type[ind] == \"rgb\":\n                    rgb.append(color_i)\n                else:\n                    # any other format, just convert it to RGB\n                    rgb.append(tuple([int(c * 255) for c in mcolors.to_rgb(color_i)]))\n\n        return rgb\n</code></pre>"},{"location":"api/colors-class/#cleopatra.colors.Colors.color_value","title":"<code>color_value</code>  <code>property</code>","text":"<p>Color values given by the user.</p> <p>Returns:</p> Type Description <code>List[str]</code>"},{"location":"api/colors-class/#cleopatra.colors.Colors.__init__","title":"<code>__init__(color_value)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>color_value</code> <code>Union[List[str], str, Tuple[float, float, float], List[Tuple[float, float, float]]]</code> <p>the color value could be a list of hex colors, a tuple of RGB values, or a single hex/RGB color.</p> required <p>Examples:</p> <ul> <li>Create a color object from a hex color:     <pre><code>&gt;&gt;&gt; hex_number = \"ff0000\"\n&gt;&gt;&gt; color = Colors(hex_number)\n&gt;&gt;&gt; print(color.color_value)\n['ff0000']\n</code></pre></li> <li>Create a color object from an RGB color (values are between 0 and 1):     <pre><code>&gt;&gt;&gt; rgb_color = (0.5, 0.2, 0.8)\n&gt;&gt;&gt; color = Colors(rgb_color)\n&gt;&gt;&gt; print(color.color_value)\n[(0.5, 0.2, 0.8)]\n</code></pre></li> <li>Create a color object from an RGB color (values are between 0 and 255):     <pre><code>&gt;&gt;&gt; rgb_color = (128, 51, 204)\n&gt;&gt;&gt; color = Colors(rgb_color)\n&gt;&gt;&gt; print(color.color_value)\n[(128, 51, 204)]\n</code></pre></li> </ul> Source code in <code>cleopatra/colors.py</code> <pre><code>def __init__(\n    self,\n    color_value: Union[\n        List[str], str, Tuple[float, float, float], List[Tuple[float, float, float]]\n    ],\n):\n    \"\"\"\n\n    Parameters\n    ----------\n    color_value: List[str]/Tuple[float, float, float]/str.\n        the color value could be a list of hex colors, a tuple of RGB values, or a single hex/RGB color.\n\n    Examples\n    --------\n    - Create a color object from a hex color:\n        ```python\n        &gt;&gt;&gt; hex_number = \"ff0000\"\n        &gt;&gt;&gt; color = Colors(hex_number)\n        &gt;&gt;&gt; print(color.color_value)\n        ['ff0000']\n        ```\n    - Create a color object from an RGB color (values are between 0 and 1):\n        ```python\n        &gt;&gt;&gt; rgb_color = (0.5, 0.2, 0.8)\n        &gt;&gt;&gt; color = Colors(rgb_color)\n        &gt;&gt;&gt; print(color.color_value)\n        [(0.5, 0.2, 0.8)]\n        ```\n    - Create a color object from an RGB color (values are between 0 and 255):\n        ```python\n        &gt;&gt;&gt; rgb_color = (128, 51, 204)\n        &gt;&gt;&gt; color = Colors(rgb_color)\n        &gt;&gt;&gt; print(color.color_value)\n        [(128, 51, 204)]\n        ```\n    \"\"\"\n    # convert the hex color to a list if it is a string\n    if isinstance(color_value, str) or isinstance(color_value, tuple):\n        color_value = [color_value]\n    elif not isinstance(color_value, list):\n        raise ValueError(\n            \"The color_value must be a list of hex colors, list of tuples (RGB color), a single hex \"\n            \"or single RGB tuple color.\"\n        )\n\n    self._color_value = color_value\n</code></pre>"},{"location":"api/colors-class/#cleopatra.colors.Colors.get_type","title":"<code>get_type()</code>","text":"<p>get_type.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>Examples:</p> <ul> <li>Create a color object from a hex color:     <pre><code>&gt;&gt;&gt; hex_number = \"#23a9dd\"\n&gt;&gt;&gt; color = Colors(hex_number)\n&gt;&gt;&gt; print(color.get_type())\n['hex']\n</code></pre></li> <li>Create a color object from an RGB color (values are between 0 and 1):     <pre><code>&gt;&gt;&gt; rgb_color = (0.5, 0.2, 0.8)\n&gt;&gt;&gt; color = Colors(rgb_color)\n&gt;&gt;&gt; print(color.get_type())\n['rgb-normalized']\n</code></pre></li> <li>Create a color object from an RGB color (values are between 0 and 255):     <pre><code>&gt;&gt;&gt; rgb_color = (128, 51, 204)\n&gt;&gt;&gt; color = Colors(rgb_color)\n&gt;&gt;&gt; print(color.get_type())\n['rgb']\n</code></pre></li> </ul> Source code in <code>cleopatra/colors.py</code> <pre><code>def get_type(self) -&gt; List[str]:\n    \"\"\"get_type.\n\n    Returns\n    -------\n    List[str]\n\n    Examples\n    --------\n    - Create a color object from a hex color:\n        ```python\n        &gt;&gt;&gt; hex_number = \"#23a9dd\"\n        &gt;&gt;&gt; color = Colors(hex_number)\n        &gt;&gt;&gt; print(color.get_type())\n        ['hex']\n        ```\n    - Create a color object from an RGB color (values are between 0 and 1):\n        ```python\n        &gt;&gt;&gt; rgb_color = (0.5, 0.2, 0.8)\n        &gt;&gt;&gt; color = Colors(rgb_color)\n        &gt;&gt;&gt; print(color.get_type())\n        ['rgb-normalized']\n        ```\n    - Create a color object from an RGB color (values are between 0 and 255):\n        ```python\n        &gt;&gt;&gt; rgb_color = (128, 51, 204)\n        &gt;&gt;&gt; color = Colors(rgb_color)\n        &gt;&gt;&gt; print(color.get_type())\n        ['rgb']\n        ```\n    \"\"\"\n    color_type = []\n    for color_i in self.color_value:\n        if self.is_valid_rgb_norm(color_i):\n            color_type.append(\"rgb-normalized\")\n        elif self.is_valid_rgb_255(color_i):\n            color_type.append(\"rgb\")\n        elif self.is_valid_hex_i(color_i):\n            color_type.append(\"hex\")\n\n    return color_type\n</code></pre>"},{"location":"api/colors-class/#cleopatra.colors.Colors.is_valid_hex","title":"<code>is_valid_hex()</code>","text":"<p>is_valid_hex.</p> <pre><code>is_valid_hex\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>Returns</code> required Source code in <code>cleopatra/colors.py</code> <pre><code>def is_valid_hex(self) -&gt; List[bool]:\n    \"\"\"is_valid_hex.\n\n        is_valid_hex\n\n    Parameters\n    ----------\n\n    Returns\n    -------\n\n    \"\"\"\n    return [self.is_valid_hex_i(col) for col in self.color_value]\n</code></pre>"},{"location":"api/colors-class/#cleopatra.colors.Colors.is_valid_hex_i","title":"<code>is_valid_hex_i(hex_color)</code>  <code>staticmethod</code>","text":"<p>is_valid_hex for single color.</p> <p>Parameters:</p> Name Type Description Default <code>hex_color</code> <code>str</code> <p>single hex color.</p> required <p>Returns:</p> Type Description <code>bool</code> Source code in <code>cleopatra/colors.py</code> <pre><code>@staticmethod\ndef is_valid_hex_i(hex_color: str) -&gt; bool:\n    \"\"\"is_valid_hex for single color.\n\n\n    Parameters\n    ----------\n    hex_color: str.\n        single hex color.\n    Returns\n    -------\n    bool\n    \"\"\"\n    return True if mcolors.is_color_like(hex_color) else False\n</code></pre>"},{"location":"api/colors-class/#cleopatra.colors.Colors.is_valid_rgb","title":"<code>is_valid_rgb()</code>","text":"<p>is_valid_rgb.</p> <p>Returns:</p> Type Description <code>List[bool]</code> <p>List of boolean values for each color</p> Source code in <code>cleopatra/colors.py</code> <pre><code>def is_valid_rgb(self) -&gt; List[bool]:\n    \"\"\"is_valid_rgb.\n\n    Returns\n    -------\n    List[bool]\n        List of boolean values for each color\n    \"\"\"\n    return [\n        self.is_valid_rgb_norm(col) or self.is_valid_rgb_255(col)\n        for col in self.color_value\n    ]\n</code></pre>"},{"location":"api/colors-class/#cleopatra.colors.Colors.is_valid_rgb_255","title":"<code>is_valid_rgb_255(rgb_tuple)</code>  <code>staticmethod</code>","text":"<p>validate a single color whither it is rgb or not.</p> Source code in <code>cleopatra/colors.py</code> <pre><code>@staticmethod\ndef is_valid_rgb_255(rgb_tuple: Any) -&gt; bool:\n    \"\"\"validate a single color whither it is rgb or not.\"\"\"\n    if isinstance(rgb_tuple, tuple) and len(rgb_tuple) == 3:\n        if all(isinstance(value, int) for value in rgb_tuple):\n            return all(0 &lt;= value &lt;= 255 for value in rgb_tuple)\n    return False\n</code></pre>"},{"location":"api/colors-class/#cleopatra.colors.Colors.is_valid_rgb_norm","title":"<code>is_valid_rgb_norm(rgb_tuple)</code>  <code>staticmethod</code>","text":"<p>validate a single color whither it is rgb or not.</p> Source code in <code>cleopatra/colors.py</code> <pre><code>@staticmethod\ndef is_valid_rgb_norm(rgb_tuple: Any) -&gt; bool:\n    \"\"\"validate a single color whither it is rgb or not.\"\"\"\n    if isinstance(rgb_tuple, tuple) and len(rgb_tuple) == 3:\n        if all(isinstance(value, float) for value in rgb_tuple):\n            return all(0.0 &lt;= value &lt;= 1.0 for value in rgb_tuple)\n    return False\n</code></pre>"},{"location":"api/colors-class/#cleopatra.colors.Colors.to_hex","title":"<code>to_hex()</code>","text":"<p>Convert colors to hexdecimal format.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>list of hec colors.</p> <p>Examples:</p> <ul> <li>Create a color object from a mixed list of hex and RGB colors:     <pre><code>&gt;&gt;&gt; mixed_color = [(128, 51, 204), \"#23a9dd\", (0.5, 0.2, 0.8)]\n&gt;&gt;&gt; color = Colors(mixed_color)\n&gt;&gt;&gt; print(color.to_hex())\n['#8033cc', '#23a9dd', '#8033cc']\n</code></pre></li> </ul> Source code in <code>cleopatra/colors.py</code> <pre><code>def to_hex(self) -&gt; List[str]:\n    \"\"\"Convert colors to hexdecimal format.\n\n    Returns\n    -------\n    List[str]\n        list of hec colors.\n\n    Examples\n    --------\n    - Create a color object from a mixed list of hex and RGB colors:\n        ```python\n        &gt;&gt;&gt; mixed_color = [(128, 51, 204), \"#23a9dd\", (0.5, 0.2, 0.8)]\n        &gt;&gt;&gt; color = Colors(mixed_color)\n        &gt;&gt;&gt; print(color.to_hex())\n        ['#8033cc', '#23a9dd', '#8033cc']\n        ```\n    \"\"\"\n    converted_color = []\n    color_type = self.get_type()\n    for ind, color_i in enumerate(self.color_value):\n        if color_type[ind] == \"hex\":\n            converted_color.append(color_i)\n        elif color_type[ind] == \"rgb\":\n            # Normalize the RGB values to be between 0 and 1\n            rgb_color_normalized = tuple(value / 255 for value in color_i)\n            converted_color.append(mcolors.to_hex(rgb_color_normalized))\n        else:\n            converted_color.append(mcolors.to_hex(color_i))\n    return converted_color\n</code></pre>"},{"location":"api/colors-class/#cleopatra.colors.Colors.to_rgb","title":"<code>to_rgb(normalized=True)</code>","text":"<p>get_rgb.</p> <p>Parameters:</p> Name Type Description Default <code>normalized</code> <code>bool</code> <p>True if you want the RGB values to be scaled between 0 and 1. False if you want the RGB values to be scaled between 0 and 255.</p> <code>True</code> <p>Returns:</p> Type Description <code>List[Tuples]</code> Source code in <code>cleopatra/colors.py</code> <pre><code>def to_rgb(\n    self, normalized: bool = True\n) -&gt; List[Tuple[Union[int, float], Union[int, float]]]:\n    \"\"\"get_rgb.\n\n    Parameters\n    ----------\n    normalized: int, Default is True.\n        True if you want the RGB values to be scaled between 0 and 1. False if you want the RGB values to be scaled\n        between 0 and 255.\n\n    Returns\n    -------\n    List[Tuples]\n    \"\"\"\n    color_type = self.get_type()\n    rgb = []\n    if normalized:\n        for ind, color_i in enumerate(self.color_value):\n            # if the color is in RGB format (0-255), normalize the values to be between 0 and 1\n            if color_type[ind] == \"rgb\":\n                rgb_color_normalized = tuple(value / 255 for value in color_i)\n                rgb.append(rgb_color_normalized)\n            else:\n                # any other format, just convert it to RGB\n                rgb.append(mcolors.to_rgb(color_i))\n    else:\n        for ind, color_i in enumerate(self.color_value):\n            # if the color is in RGB format (0-255), normalize the values to be between 0 and 1\n            if color_type[ind] == \"rgb\":\n                rgb.append(color_i)\n            else:\n                # any other format, just convert it to RGB\n                rgb.append(tuple([int(c * 255) for c in mcolors.to_rgb(color_i)]))\n\n    return rgb\n</code></pre>"},{"location":"api/colors-class/#examples","title":"Examples","text":""},{"location":"api/colors-class/#creating-color-objects","title":"Creating Color Objects","text":"<pre><code>from cleopatra.colors import Colors\n\n# Create a Colors object with a hex color\nhex_color = Colors(\"#FF5733\")\n\n# Create a Colors object with an RGB color (normalized)\nrgb_color = Colors((1.0, 0.34, 0.2))\n\n# Create a Colors object with an RGB color (0-255)\nrgb_255_color = Colors((255, 87, 51))\n\n# Create a Colors object with a named color\nnamed_color = Colors(\"red\")\n\n# Create a Colors object with a list of colors\ncolor_list = Colors([\"red\", \"green\", \"blue\"])\n</code></pre>"},{"location":"api/colors-class/#converting-between-color-formats","title":"Converting Between Color Formats","text":"<pre><code># Convert to hex\nhex_value = rgb_color.to_hex()\nprint(hex_value)  # \"#FF5733\"\n\n# Convert to RGB (normalized)\nrgb_value = hex_color.to_rgb(normalized=True)\nprint(rgb_value)  # (1.0, 0.34, 0.2)\n\n# Convert to RGB (0-255)\nrgb_255_value = hex_color.to_rgb(normalized=False)\nprint(rgb_255_value)  # (255, 87, 51)\n</code></pre>"},{"location":"api/colors-class/#validating-color-values","title":"Validating Color Values","text":"<pre><code># Check if a hex color is valid\nis_valid = hex_color.is_valid_hex()\nprint(is_valid)  # True\n\n# Check if an RGB color is valid\nis_valid = rgb_color.is_valid_rgb()\nprint(is_valid)  # True\n</code></pre>"},{"location":"api/statistics-class/","title":"Statistic Class","text":"<p>The <code>Statistic</code> module provides a class for creating statistical plots, specifically histograms. The class, <code>Statistic</code>, is designed to handle both 1D (single-dimensional) and 2D (multi-dimensional) data.</p>"},{"location":"api/statistics-class/#class-documentation","title":"Class Documentation","text":""},{"location":"api/statistics-class/#cleopatra.statistics.Statistic","title":"<code>cleopatra.statistics.Statistic</code>","text":"<p>A class for creating statistical plots, specifically histograms.</p> <p>This class provides methods for initializing the class with numerical values and optional keyword arguments, and for creating histograms from the given values.</p> <p>Attributes: _values: numpy.ndarray     The numerical values to be plotted as histograms. _default_options: dict     The default options for creating histograms, including the number of bins, color, alpha, rwidth, grid_alpha,     xlabel, ylabel, xlabel_font_size, ylabel_font_size, xtick_font_size, and ytick_font_size.</p> <p>Methods: init(self, values: Union[List, np.ndarray], kwargs):     Initializes the class with numerical values and optional keyword arguments. histogram(self, kwargs) -&gt; [Figure, Axes, Dict]:     Creates a histogram from the given values and optional keyword arguments.</p> Example <pre><code>&gt;&gt;&gt; np.random.seed(1)\n&gt;&gt;&gt; x = 4 + np.random.normal(0, 1.5, 200)\n&gt;&gt;&gt; stat_plot = Statistic(x)\n&gt;&gt;&gt; fig, ax, hist = stat_plot.histogram()\n&gt;&gt;&gt; print(hist) # doctest: +SKIP\n{'n': [array([ 2.,  4.,  3., 10., 11., 20., 30., 27., 31., 25., 17.,  8.,  5.,\n                    6.,  1.])], 'bins': [array([0.34774335, 0.8440597 , 1.34037605, 1.8366924 , 2.33300874,\n                   2.82932509, 3.32564144, 3.82195778, 4.31827413, 4.81459048,\n                   5.31090682, 5.80722317, 6.30353952, 6.79985587, 7.29617221,\n                   7.79248856])], 'patches': [&lt;BarContainer object of 15 artists&gt;]}\n</code></pre> <p></p> Source code in <code>cleopatra/statistics.py</code> <pre><code>class Statistic:\n    \"\"\"\n    A class for creating statistical plots, specifically histograms.\n\n    This class provides methods for initializing the class with numerical values and optional keyword arguments,\n    and for creating histograms from the given values.\n\n    Attributes:\n    _values: numpy.ndarray\n        The numerical values to be plotted as histograms.\n    _default_options: dict\n        The default options for creating histograms, including the number of bins, color, alpha, rwidth, grid_alpha,\n        xlabel, ylabel, xlabel_font_size, ylabel_font_size, xtick_font_size, and ytick_font_size.\n\n    Methods:\n    __init__(self, values: Union[List, np.ndarray], **kwargs):\n        Initializes the class with numerical values and optional keyword arguments.\n    histogram(self, **kwargs) -&gt; [Figure, Axes, Dict]:\n        Creates a histogram from the given values and optional keyword arguments.\n\n    Example\n    -------\n        &gt;&gt;&gt; np.random.seed(1)\n        &gt;&gt;&gt; x = 4 + np.random.normal(0, 1.5, 200)\n        &gt;&gt;&gt; stat_plot = Statistic(x)\n        &gt;&gt;&gt; fig, ax, hist = stat_plot.histogram()\n        &gt;&gt;&gt; print(hist) # doctest: +SKIP\n        {'n': [array([ 2.,  4.,  3., 10., 11., 20., 30., 27., 31., 25., 17.,  8.,  5.,\n                            6.,  1.])], 'bins': [array([0.34774335, 0.8440597 , 1.34037605, 1.8366924 , 2.33300874,\n                           2.82932509, 3.32564144, 3.82195778, 4.31827413, 4.81459048,\n                           5.31090682, 5.80722317, 6.30353952, 6.79985587, 7.29617221,\n                           7.79248856])], 'patches': [&lt;BarContainer object of 15 artists&gt;]}\n\n    ![image](../_images/one-histogram.png)\n    \"\"\"\n\n    def __init__(\n        self,\n        values: Union[List, np.ndarray],\n        **kwargs,\n    ):\n        \"\"\"\n\n        Parameters\n        ----------\n        values: [list/array]\n            values to be plotted as histogram.\n        \"\"\"\n        self._values = values\n        options_dict = DEFAULT_OPTIONS.copy()\n        options_dict.update(kwargs)\n        self._default_options = options_dict\n\n    @property\n    def values(self):\n        \"\"\"numerical values\"\"\"\n        return self._values\n\n    @values.setter\n    def values(self, values):\n        self._values = values\n\n    @property\n    def default_options(self) -&gt; Dict:\n        \"\"\"Default plot options\"\"\"\n        return self._default_options\n\n    def histogram(self, **kwargs) -&gt; [Figure, Axes, Dict]:\n        \"\"\"\n\n        Parameters\n        ----------\n        **kwargs: [dict]\n            keys:\n                bins: int, Default is 15.\n                    number of bins.\n                color: List[str], default is [\"#0504aa\"]\n                    color of the bins, the number of colors should be equal to the number of samples (columns of the\n                    given array).\n                alpha: float, default is 0.7\n                     degree of transparency.\n                rwidth: float, default is 0.85\n                    width of the bins.\n                grid_alpha:\n                    alpha of the grid.\n                xlabel: str\n                    x-axis label.\n                ylabel: str\n                    y-axis label.\n                xlabel_font_size: int\n                    x-axis label font size.\n                ylabel_font_size: int\n                    y-axis label font size.\n                xtick_font_size: int\n                    x-axis tick font size.\n                 ytick_font_size: int\n                    y-axis tick font size.\n\n        Raises\n        ------\n        ValueError\n            If the number of colors given by the `color` kwars is not equal to the number of samples.\n\n        Example\n        -------\n            - 1D data.\n\n                - First genearte some random data and plot the histogram.\n                    ```python\n                    &gt;&gt;&gt; np.random.seed(1)\n                    &gt;&gt;&gt; x = 4 + np.random.normal(0, 1.5, 200)\n                    &gt;&gt;&gt; stat_plot = Statistic(x)\n                    &gt;&gt;&gt; fig, ax, hist = stat_plot.histogram()\n                    &gt;&gt;&gt; print(hist) # doctest: +SKIP\n                    {'n': [array([ 2.,  4.,  3., 10., 11., 20., 30., 27., 31., 25., 17.,  8.,  5.,\n                            6.,  1.])], 'bins': [array([0.34774335, 0.8440597 , 1.34037605, 1.8366924 , 2.33300874,\n                           2.82932509, 3.32564144, 3.82195778, 4.31827413, 4.81459048,\n                           5.31090682, 5.80722317, 6.30353952, 6.79985587, 7.29617221,\n                           7.79248856])], 'patches': [&lt;BarContainer object of 15 artists&gt;]}\n                    ```\n                ![image](../_images/one-histogram.png)\n\n            - 2D data.\n\n                - First genearte some random data and plot the histogram.\n                    ```python\n                    &gt;&gt;&gt; np.random.seed(1)\n                    &gt;&gt;&gt; x = 4 + np.random.normal(0, 1.5, (200, 3))\n                    &gt;&gt;&gt; stat_plot = Statistic(x, color=[\"red\", \"green\", \"blue\"], alpha=0.4, rwidth=0.8)\n                    &gt;&gt;&gt; fig, ax, hist = stat_plot.histogram()\n                    &gt;&gt;&gt; print(hist) # doctest: +SKIP\n                    {'n': [array([ 1.,  2.,  4., 10., 13., 19., 20., 32., 27., 23., 24., 11.,  5.,\n                            5.,  4.]), array([ 3.,  4.,  9., 12., 20., 41., 29., 32., 25., 14.,  9.,  1.,  0.,\n                            0.,  1.]), array([ 3.,  4.,  6.,  7., 25., 26., 31., 24., 30., 19., 11.,  9.,  4.,\n                            0.,  1.])], 'bins': [array([-0.1896275 ,  0.33461786,  0.85886323,  1.38310859,  1.90735396,\n                            2.43159932,  2.95584469,  3.48009005,  4.00433542,  4.52858078,\n                            5.05282615,  5.57707151,  6.10131688,  6.62556224,  7.14980761,\n                            7.67405297]), array([-0.1738017 ,  0.50031202,  1.17442573,  1.84853945,  2.52265317,\n                            3.19676688,  3.8708806 ,  4.54499432,  5.21910804,  5.89322175,\n                            6.56733547,  7.24144919,  7.9155629 ,  8.58967662,  9.26379034,\n                            9.93790406]), array([0.24033902, 0.7940688 , 1.34779857, 1.90152835, 2.45525813,\n                           3.0089879 , 3.56271768, 4.11644746, 4.67017723, 5.22390701,\n                           5.77763679, 6.33136656, 6.88509634, 7.43882612, 7.99255589,\n                           8.54628567])], 'patches': [&lt;BarContainer object of 15 artists&gt;,\n                           &lt;BarContainer object of 15 artists&gt;, &lt;BarContainer object of 15 artists&gt;]}\n                    ```\n\n                ![image](../_images/three-histogram.png)\n        \"\"\"\n        for key, val in kwargs.items():\n            if key not in self.default_options.keys():\n                raise ValueError(\n                    f\"The given keyword argument:{key} is not correct, possible parameters are,\"\n                    f\" {self.default_options}\"\n                )\n            else:\n                self.default_options[key] = val\n\n        fig, ax = plt.subplots(figsize=self.default_options[\"figsize\"])\n\n        n = []\n        bins = []\n        patches = []\n        bins_val = self.default_options[\"bins\"]\n        color = self.default_options[\"color\"]\n        alpha = self.default_options[\"alpha\"]\n        rwidth = self.default_options[\"rwidth\"]\n        if self.values.ndim == 2:\n            num_samples = self.values.shape[1]\n            if len(color) != num_samples:\n                raise ValueError(\n                    f\"The number of colors:{len(color)} should be equal to the number of samples:{num_samples}\"\n                )\n        else:\n            num_samples = 1\n\n        for i in range(num_samples):\n            if self.values.ndim == 1:\n                vals = self.values\n            else:\n                vals = self.values[:, i]\n\n            n_i, bins_i, patches_i = ax.hist(\n                x=vals,\n                bins=bins_val,\n                color=color[i],\n                alpha=alpha,\n                rwidth=rwidth,\n            )\n            n.append(n_i)\n            bins.append(bins_i)\n            patches.append(patches_i)\n\n        plt.grid(axis=\"y\", alpha=self.default_options[\"grid_alpha\"])\n        plt.xlabel(\n            self.default_options[\"xlabel\"],\n            fontsize=self.default_options[\"xlabel_font_size\"],\n        )\n        plt.ylabel(\n            self.default_options[\"ylabel\"],\n            fontsize=self.default_options[\"ylabel_font_size\"],\n        )\n        plt.xticks(fontsize=self.default_options[\"xtick_font_size\"])\n        plt.yticks(fontsize=self.default_options[\"ytick_font_size\"])\n        hist = {\"n\": n, \"bins\": bins, \"patches\": patches}\n        plt.show()\n        return fig, ax, hist\n</code></pre>"},{"location":"api/statistics-class/#cleopatra.statistics.Statistic.default_options","title":"<code>default_options</code>  <code>property</code>","text":"<p>Default plot options</p>"},{"location":"api/statistics-class/#cleopatra.statistics.Statistic.values","title":"<code>values</code>  <code>property</code> <code>writable</code>","text":"<p>numerical values</p>"},{"location":"api/statistics-class/#cleopatra.statistics.Statistic.__init__","title":"<code>__init__(values, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>values</code> <code>Union[List, ndarray]</code> <p>values to be plotted as histogram.</p> required Source code in <code>cleopatra/statistics.py</code> <pre><code>def __init__(\n    self,\n    values: Union[List, np.ndarray],\n    **kwargs,\n):\n    \"\"\"\n\n    Parameters\n    ----------\n    values: [list/array]\n        values to be plotted as histogram.\n    \"\"\"\n    self._values = values\n    options_dict = DEFAULT_OPTIONS.copy()\n    options_dict.update(kwargs)\n    self._default_options = options_dict\n</code></pre>"},{"location":"api/statistics-class/#cleopatra.statistics.Statistic.histogram","title":"<code>histogram(**kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>keys:     bins: int, Default is 15.         number of bins.     color: List[str], default is [\"#0504aa\"]         color of the bins, the number of colors should be equal to the number of samples (columns of the         given array).     alpha: float, default is 0.7          degree of transparency.     rwidth: float, default is 0.85         width of the bins.     grid_alpha:         alpha of the grid.     xlabel: str         x-axis label.     ylabel: str         y-axis label.     xlabel_font_size: int         x-axis label font size.     ylabel_font_size: int         y-axis label font size.     xtick_font_size: int         x-axis tick font size.      ytick_font_size: int         y-axis tick font size.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the number of colors given by the <code>color</code> kwars is not equal to the number of samples.</p> Example <pre><code>- 1D data.\n\n    - First genearte some random data and plot the histogram.\n        ```python\n        &gt;&gt;&gt; np.random.seed(1)\n        &gt;&gt;&gt; x = 4 + np.random.normal(0, 1.5, 200)\n        &gt;&gt;&gt; stat_plot = Statistic(x)\n        &gt;&gt;&gt; fig, ax, hist = stat_plot.histogram()\n        &gt;&gt;&gt; print(hist) # doctest: +SKIP\n        {'n': [array([ 2.,  4.,  3., 10., 11., 20., 30., 27., 31., 25., 17.,  8.,  5.,\n                6.,  1.])], 'bins': [array([0.34774335, 0.8440597 , 1.34037605, 1.8366924 , 2.33300874,\n               2.82932509, 3.32564144, 3.82195778, 4.31827413, 4.81459048,\n               5.31090682, 5.80722317, 6.30353952, 6.79985587, 7.29617221,\n               7.79248856])], 'patches': [&lt;BarContainer object of 15 artists&gt;]}\n        ```\n    ![image](../_images/one-histogram.png)\n\n- 2D data.\n\n    - First genearte some random data and plot the histogram.\n        ```python\n        &gt;&gt;&gt; np.random.seed(1)\n        &gt;&gt;&gt; x = 4 + np.random.normal(0, 1.5, (200, 3))\n        &gt;&gt;&gt; stat_plot = Statistic(x, color=[\"red\", \"green\", \"blue\"], alpha=0.4, rwidth=0.8)\n        &gt;&gt;&gt; fig, ax, hist = stat_plot.histogram()\n        &gt;&gt;&gt; print(hist) # doctest: +SKIP\n        {'n': [array([ 1.,  2.,  4., 10., 13., 19., 20., 32., 27., 23., 24., 11.,  5.,\n                5.,  4.]), array([ 3.,  4.,  9., 12., 20., 41., 29., 32., 25., 14.,  9.,  1.,  0.,\n                0.,  1.]), array([ 3.,  4.,  6.,  7., 25., 26., 31., 24., 30., 19., 11.,  9.,  4.,\n                0.,  1.])], 'bins': [array([-0.1896275 ,  0.33461786,  0.85886323,  1.38310859,  1.90735396,\n                2.43159932,  2.95584469,  3.48009005,  4.00433542,  4.52858078,\n                5.05282615,  5.57707151,  6.10131688,  6.62556224,  7.14980761,\n                7.67405297]), array([-0.1738017 ,  0.50031202,  1.17442573,  1.84853945,  2.52265317,\n                3.19676688,  3.8708806 ,  4.54499432,  5.21910804,  5.89322175,\n                6.56733547,  7.24144919,  7.9155629 ,  8.58967662,  9.26379034,\n                9.93790406]), array([0.24033902, 0.7940688 , 1.34779857, 1.90152835, 2.45525813,\n               3.0089879 , 3.56271768, 4.11644746, 4.67017723, 5.22390701,\n               5.77763679, 6.33136656, 6.88509634, 7.43882612, 7.99255589,\n               8.54628567])], 'patches': [&lt;BarContainer object of 15 artists&gt;,\n               &lt;BarContainer object of 15 artists&gt;, &lt;BarContainer object of 15 artists&gt;]}\n        ```\n\n    ![image](../_images/three-histogram.png)\n</code></pre> Source code in <code>cleopatra/statistics.py</code> <pre><code>def histogram(self, **kwargs) -&gt; [Figure, Axes, Dict]:\n    \"\"\"\n\n    Parameters\n    ----------\n    **kwargs: [dict]\n        keys:\n            bins: int, Default is 15.\n                number of bins.\n            color: List[str], default is [\"#0504aa\"]\n                color of the bins, the number of colors should be equal to the number of samples (columns of the\n                given array).\n            alpha: float, default is 0.7\n                 degree of transparency.\n            rwidth: float, default is 0.85\n                width of the bins.\n            grid_alpha:\n                alpha of the grid.\n            xlabel: str\n                x-axis label.\n            ylabel: str\n                y-axis label.\n            xlabel_font_size: int\n                x-axis label font size.\n            ylabel_font_size: int\n                y-axis label font size.\n            xtick_font_size: int\n                x-axis tick font size.\n             ytick_font_size: int\n                y-axis tick font size.\n\n    Raises\n    ------\n    ValueError\n        If the number of colors given by the `color` kwars is not equal to the number of samples.\n\n    Example\n    -------\n        - 1D data.\n\n            - First genearte some random data and plot the histogram.\n                ```python\n                &gt;&gt;&gt; np.random.seed(1)\n                &gt;&gt;&gt; x = 4 + np.random.normal(0, 1.5, 200)\n                &gt;&gt;&gt; stat_plot = Statistic(x)\n                &gt;&gt;&gt; fig, ax, hist = stat_plot.histogram()\n                &gt;&gt;&gt; print(hist) # doctest: +SKIP\n                {'n': [array([ 2.,  4.,  3., 10., 11., 20., 30., 27., 31., 25., 17.,  8.,  5.,\n                        6.,  1.])], 'bins': [array([0.34774335, 0.8440597 , 1.34037605, 1.8366924 , 2.33300874,\n                       2.82932509, 3.32564144, 3.82195778, 4.31827413, 4.81459048,\n                       5.31090682, 5.80722317, 6.30353952, 6.79985587, 7.29617221,\n                       7.79248856])], 'patches': [&lt;BarContainer object of 15 artists&gt;]}\n                ```\n            ![image](../_images/one-histogram.png)\n\n        - 2D data.\n\n            - First genearte some random data and plot the histogram.\n                ```python\n                &gt;&gt;&gt; np.random.seed(1)\n                &gt;&gt;&gt; x = 4 + np.random.normal(0, 1.5, (200, 3))\n                &gt;&gt;&gt; stat_plot = Statistic(x, color=[\"red\", \"green\", \"blue\"], alpha=0.4, rwidth=0.8)\n                &gt;&gt;&gt; fig, ax, hist = stat_plot.histogram()\n                &gt;&gt;&gt; print(hist) # doctest: +SKIP\n                {'n': [array([ 1.,  2.,  4., 10., 13., 19., 20., 32., 27., 23., 24., 11.,  5.,\n                        5.,  4.]), array([ 3.,  4.,  9., 12., 20., 41., 29., 32., 25., 14.,  9.,  1.,  0.,\n                        0.,  1.]), array([ 3.,  4.,  6.,  7., 25., 26., 31., 24., 30., 19., 11.,  9.,  4.,\n                        0.,  1.])], 'bins': [array([-0.1896275 ,  0.33461786,  0.85886323,  1.38310859,  1.90735396,\n                        2.43159932,  2.95584469,  3.48009005,  4.00433542,  4.52858078,\n                        5.05282615,  5.57707151,  6.10131688,  6.62556224,  7.14980761,\n                        7.67405297]), array([-0.1738017 ,  0.50031202,  1.17442573,  1.84853945,  2.52265317,\n                        3.19676688,  3.8708806 ,  4.54499432,  5.21910804,  5.89322175,\n                        6.56733547,  7.24144919,  7.9155629 ,  8.58967662,  9.26379034,\n                        9.93790406]), array([0.24033902, 0.7940688 , 1.34779857, 1.90152835, 2.45525813,\n                       3.0089879 , 3.56271768, 4.11644746, 4.67017723, 5.22390701,\n                       5.77763679, 6.33136656, 6.88509634, 7.43882612, 7.99255589,\n                       8.54628567])], 'patches': [&lt;BarContainer object of 15 artists&gt;,\n                       &lt;BarContainer object of 15 artists&gt;, &lt;BarContainer object of 15 artists&gt;]}\n                ```\n\n            ![image](../_images/three-histogram.png)\n    \"\"\"\n    for key, val in kwargs.items():\n        if key not in self.default_options.keys():\n            raise ValueError(\n                f\"The given keyword argument:{key} is not correct, possible parameters are,\"\n                f\" {self.default_options}\"\n            )\n        else:\n            self.default_options[key] = val\n\n    fig, ax = plt.subplots(figsize=self.default_options[\"figsize\"])\n\n    n = []\n    bins = []\n    patches = []\n    bins_val = self.default_options[\"bins\"]\n    color = self.default_options[\"color\"]\n    alpha = self.default_options[\"alpha\"]\n    rwidth = self.default_options[\"rwidth\"]\n    if self.values.ndim == 2:\n        num_samples = self.values.shape[1]\n        if len(color) != num_samples:\n            raise ValueError(\n                f\"The number of colors:{len(color)} should be equal to the number of samples:{num_samples}\"\n            )\n    else:\n        num_samples = 1\n\n    for i in range(num_samples):\n        if self.values.ndim == 1:\n            vals = self.values\n        else:\n            vals = self.values[:, i]\n\n        n_i, bins_i, patches_i = ax.hist(\n            x=vals,\n            bins=bins_val,\n            color=color[i],\n            alpha=alpha,\n            rwidth=rwidth,\n        )\n        n.append(n_i)\n        bins.append(bins_i)\n        patches.append(patches_i)\n\n    plt.grid(axis=\"y\", alpha=self.default_options[\"grid_alpha\"])\n    plt.xlabel(\n        self.default_options[\"xlabel\"],\n        fontsize=self.default_options[\"xlabel_font_size\"],\n    )\n    plt.ylabel(\n        self.default_options[\"ylabel\"],\n        fontsize=self.default_options[\"ylabel_font_size\"],\n    )\n    plt.xticks(fontsize=self.default_options[\"xtick_font_size\"])\n    plt.yticks(fontsize=self.default_options[\"ytick_font_size\"])\n    hist = {\"n\": n, \"bins\": bins, \"patches\": patches}\n    plt.show()\n    return fig, ax, hist\n</code></pre>"},{"location":"api/statistics-class/#examples","title":"Examples","text":""},{"location":"api/statistics-class/#1d-data-example","title":"1D Data Example","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom cleopatra.statistics import Statistic\n\n# Create some random 1D data\nnp.random.seed(1)\ndata_1d = 4 + np.random.normal(0, 1.5, 200)\n\n# Create a Statistic object with the 1D data\nstat_plot_1d = Statistic(data_1d)\n\n# Generate a histogram plot for the 1D data\nfig_1d, ax_1d, hist_1d = stat_plot_1d.histogram()\n</code></pre>"},{"location":"api/statistics-class/#2d-data-example","title":"2D Data Example","text":"<pre><code># Create some random 2D data\ndata_2d = 4 + np.random.normal(0, 1.5, (200, 3))\n\n# Create a Statistic object with the 2D data\nstat_plot_2d = Statistic(data_2d, color=[\"red\", \"green\", \"blue\"], alpha=0.4, rwidth=0.8)\n\n# Generate a histogram plot for the 2D data\nfig_2d, ax_2d, hist_2d = stat_plot_2d.histogram()\n</code></pre>"},{"location":"api/styles-class/","title":"Styles Module","text":"<p>The <code>styles</code> module provides classes and functions for styling plots, including line styles, marker styles, scaling functions, and color normalization.</p>"},{"location":"api/styles-class/#styles-class","title":"Styles Class","text":""},{"location":"api/styles-class/#cleopatra.styles.Styles","title":"<code>cleopatra.styles.Styles</code>","text":"<p>Styles</p> Source code in <code>cleopatra/styles.py</code> <pre><code>class Styles:\n    \"\"\"Styles\"\"\"\n\n    line_styles = OrderedDict(\n        [\n            (\"solid\", (0, ())),  # 0\n            (\"loosely dotted\", (0, (1, 10))),  # 1\n            (\"dotted\", (0, (1, 5))),  # 2\n            (\"densely dotted\", (0, (1, 1))),  # 3\n            (\"loosely dashed\", (0, (5, 10))),  # 4\n            (\"dashed\", (0, (5, 5))),  # 5\n            (\"densely dashed\", (0, (5, 1))),  # 6\n            (\"loosely dashdotted\", (0, (3, 10, 1, 10))),  # 7\n            (\"dashdotted\", (0, (3, 5, 1, 5))),  # 8\n            (\"densely dashdotted\", (0, (3, 1, 1, 1))),  # 9\n            (\"loosely dashdotdotted\", (0, (3, 10, 1, 10, 1, 10))),  # 10\n            (\"dashdotdotted\", (0, (3, 5, 1, 5, 1, 5))),  # 11\n            (\"densely dashdotdotted\", (0, (3, 1, 1, 1, 1, 1))),  # 12\n            (\"densely dashdotdottededited\", (0, (6, 1, 1, 1, 1, 1))),  # 13\n        ]\n    )\n\n    marker_style_list = [\n        \"--o\",\n        \":D\",\n        \"-.H\",\n        \"--x\",\n        \":v\",\n        \"--|\",\n        \"-+\",\n        \"-^\",\n        \"--s\",\n        \"-.*\",\n        \"-.h\",\n    ]\n\n    @staticmethod\n    def get_line_style(style: Union[str, int] = \"loosely dotted\"):\n        \"\"\"LineStyle.\n\n        Line styles for plotting\n\n        Parameters\n        ----------\n        style : TYPE, optional\n            DESCRIPTION. The default is 'loosely dotted'.\n\n        Returns\n        -------\n        TYPE\n            DESCRIPTION.\n        \"\"\"\n        if isinstance(style, str):\n            try:\n                return Styles.line_styles[style]\n            except KeyError:\n                msg = (\n                    f\" The style name you entered-{style}-does not exist please\"\n                    \"choose from the available styles\"\n                )\n                print(msg)\n                print(list(Styles.line_styles))\n        else:\n            return list(Styles.line_styles.items())[style][1]\n\n    @staticmethod\n    def get_marker_style(style: int):\n        \"\"\"Marker styles for plotting.\n\n        Parameters\n        ----------\n        style: [int]\n            DESCRIPTION.\n\n        Returns\n        -------\n        TYPE\n            DESCRIPTION.\n        \"\"\"\n        if style &gt; len(Styles.marker_style_list) - 1:\n            style = style % len(Styles.marker_style_list)\n        return Styles.marker_style_list[style]\n</code></pre>"},{"location":"api/styles-class/#cleopatra.styles.Styles.get_line_style","title":"<code>get_line_style(style='loosely dotted')</code>  <code>staticmethod</code>","text":"<p>LineStyle.</p> <p>Line styles for plotting</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>TYPE</code> <p>DESCRIPTION. The default is 'loosely dotted'.</p> <code>'loosely dotted'</code> <p>Returns:</p> Type Description <code>TYPE</code> <p>DESCRIPTION.</p> Source code in <code>cleopatra/styles.py</code> <pre><code>@staticmethod\ndef get_line_style(style: Union[str, int] = \"loosely dotted\"):\n    \"\"\"LineStyle.\n\n    Line styles for plotting\n\n    Parameters\n    ----------\n    style : TYPE, optional\n        DESCRIPTION. The default is 'loosely dotted'.\n\n    Returns\n    -------\n    TYPE\n        DESCRIPTION.\n    \"\"\"\n    if isinstance(style, str):\n        try:\n            return Styles.line_styles[style]\n        except KeyError:\n            msg = (\n                f\" The style name you entered-{style}-does not exist please\"\n                \"choose from the available styles\"\n            )\n            print(msg)\n            print(list(Styles.line_styles))\n    else:\n        return list(Styles.line_styles.items())[style][1]\n</code></pre>"},{"location":"api/styles-class/#cleopatra.styles.Styles.get_marker_style","title":"<code>get_marker_style(style)</code>  <code>staticmethod</code>","text":"<p>Marker styles for plotting.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>int</code> <p>DESCRIPTION.</p> required <p>Returns:</p> Type Description <code>TYPE</code> <p>DESCRIPTION.</p> Source code in <code>cleopatra/styles.py</code> <pre><code>@staticmethod\ndef get_marker_style(style: int):\n    \"\"\"Marker styles for plotting.\n\n    Parameters\n    ----------\n    style: [int]\n        DESCRIPTION.\n\n    Returns\n    -------\n    TYPE\n        DESCRIPTION.\n    \"\"\"\n    if style &gt; len(Styles.marker_style_list) - 1:\n        style = style % len(Styles.marker_style_list)\n    return Styles.marker_style_list[style]\n</code></pre>"},{"location":"api/styles-class/#scale-class","title":"Scale Class","text":""},{"location":"api/styles-class/#cleopatra.styles.Scale","title":"<code>cleopatra.styles.Scale</code>","text":"<p>different scale object.</p> Source code in <code>cleopatra/styles.py</code> <pre><code>class Scale:\n    \"\"\"different scale object.\"\"\"\n\n    def __init__(self):\n        \"\"\"Different scale object.\"\"\"\n        pass\n\n    @staticmethod\n    def log_scale(val):\n        \"\"\"log_scale.\n\n            logarithmic scale\n\n        Parameters\n        ----------\n        val\n\n        Returns\n        -------\n        \"\"\"\n\n        # def scalar(val):\n        #     \"\"\"scalar.\n        #\n        #         scalar\n        #\n        #     Parameters\n        #     ----------\n        #     val\n        #\n        #     Returns\n        #     -------\n        #     \"\"\"\n        #   val = val + abs(minval) + 1\n        # return scalar\n        return np.log10(val)\n\n    @staticmethod\n    def power_scale(min_val) -&gt; float:\n        \"\"\"power_scale.\n\n            power scale\n\n        Parameters\n        ----------\n        min_val: float\n            minimum value.\n\n        Returns\n        -------\n        float:\n            power scale value.\n        \"\"\"\n\n        def scalar(val):\n            val = val + abs(min_val) + 1\n            return (val / 1000) ** 2\n\n        return scalar\n\n    @staticmethod\n    def identity_scale(min_val, max_val):\n        \"\"\"identity_scale.\n\n            identity_scale\n\n        Parameters\n        ----------\n        min_val\n        max_val\n\n        Returns\n        -------\n        \"\"\"\n\n        def scalar(val):\n            return 2\n\n        return scalar\n\n    @staticmethod\n    def rescale(old_value, old_min, old_max, new_min, new_max):\n        \"\"\"Rescale.\n\n        Rescale method rescales a value between two boundaries to a new value between two other boundaries\n\n        Parameters\n        ----------\n        old_value: float\n            The value that need to be transformed.\n        old_min: float\n            min old value\n        old_max: float\n            max old value\n        new_min: float\n            min new value\n        new_max: float\n            max new value\n\n        Returns\n        -------\n        new_value: float\n            transformed new value\n        \"\"\"\n        old_range = old_max - old_min\n        new_range = new_max - new_min\n        new_value = (((old_value - old_min) * new_range) / old_range) + new_min\n\n        return new_value\n</code></pre>"},{"location":"api/styles-class/#cleopatra.styles.Scale.__init__","title":"<code>__init__()</code>","text":"<p>Different scale object.</p> Source code in <code>cleopatra/styles.py</code> <pre><code>def __init__(self):\n    \"\"\"Different scale object.\"\"\"\n    pass\n</code></pre>"},{"location":"api/styles-class/#cleopatra.styles.Scale.identity_scale","title":"<code>identity_scale(min_val, max_val)</code>  <code>staticmethod</code>","text":"<p>identity_scale.</p> <pre><code>identity_scale\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>min_val</code> required <code>max_val</code> required Source code in <code>cleopatra/styles.py</code> <pre><code>@staticmethod\ndef identity_scale(min_val, max_val):\n    \"\"\"identity_scale.\n\n        identity_scale\n\n    Parameters\n    ----------\n    min_val\n    max_val\n\n    Returns\n    -------\n    \"\"\"\n\n    def scalar(val):\n        return 2\n\n    return scalar\n</code></pre>"},{"location":"api/styles-class/#cleopatra.styles.Scale.log_scale","title":"<code>log_scale(val)</code>  <code>staticmethod</code>","text":"<p>log_scale.</p> <pre><code>logarithmic scale\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>val</code> required Source code in <code>cleopatra/styles.py</code> <pre><code>@staticmethod\ndef log_scale(val):\n    \"\"\"log_scale.\n\n        logarithmic scale\n\n    Parameters\n    ----------\n    val\n\n    Returns\n    -------\n    \"\"\"\n\n    # def scalar(val):\n    #     \"\"\"scalar.\n    #\n    #         scalar\n    #\n    #     Parameters\n    #     ----------\n    #     val\n    #\n    #     Returns\n    #     -------\n    #     \"\"\"\n    #   val = val + abs(minval) + 1\n    # return scalar\n    return np.log10(val)\n</code></pre>"},{"location":"api/styles-class/#cleopatra.styles.Scale.power_scale","title":"<code>power_scale(min_val)</code>  <code>staticmethod</code>","text":"<p>power_scale.</p> <pre><code>power scale\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>min_val</code> <p>minimum value.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>power scale value.</p> Source code in <code>cleopatra/styles.py</code> <pre><code>@staticmethod\ndef power_scale(min_val) -&gt; float:\n    \"\"\"power_scale.\n\n        power scale\n\n    Parameters\n    ----------\n    min_val: float\n        minimum value.\n\n    Returns\n    -------\n    float:\n        power scale value.\n    \"\"\"\n\n    def scalar(val):\n        val = val + abs(min_val) + 1\n        return (val / 1000) ** 2\n\n    return scalar\n</code></pre>"},{"location":"api/styles-class/#cleopatra.styles.Scale.rescale","title":"<code>rescale(old_value, old_min, old_max, new_min, new_max)</code>  <code>staticmethod</code>","text":"<p>Rescale.</p> <p>Rescale method rescales a value between two boundaries to a new value between two other boundaries</p> <p>Parameters:</p> Name Type Description Default <code>old_value</code> <p>The value that need to be transformed.</p> required <code>old_min</code> <p>min old value</p> required <code>old_max</code> <p>max old value</p> required <code>new_min</code> <p>min new value</p> required <code>new_max</code> <p>max new value</p> required <p>Returns:</p> Name Type Description <code>new_value</code> <code>float</code> <p>transformed new value</p> Source code in <code>cleopatra/styles.py</code> <pre><code>@staticmethod\ndef rescale(old_value, old_min, old_max, new_min, new_max):\n    \"\"\"Rescale.\n\n    Rescale method rescales a value between two boundaries to a new value between two other boundaries\n\n    Parameters\n    ----------\n    old_value: float\n        The value that need to be transformed.\n    old_min: float\n        min old value\n    old_max: float\n        max old value\n    new_min: float\n        min new value\n    new_max: float\n        max new value\n\n    Returns\n    -------\n    new_value: float\n        transformed new value\n    \"\"\"\n    old_range = old_max - old_min\n    new_range = new_max - new_min\n    new_value = (((old_value - old_min) * new_range) / old_range) + new_min\n\n    return new_value\n</code></pre>"},{"location":"api/styles-class/#midpointnormalize-class","title":"MidpointNormalize Class","text":""},{"location":"api/styles-class/#cleopatra.styles.MidpointNormalize","title":"<code>cleopatra.styles.MidpointNormalize</code>","text":"<p>               Bases: <code>Normalize</code></p> <p>MidpointNormalize.</p> <p>!TODO needs docs</p> Source code in <code>cleopatra/styles.py</code> <pre><code>class MidpointNormalize(colors.Normalize):\n    \"\"\"MidpointNormalize.\n\n    !TODO needs docs\n    \"\"\"\n\n    def __init__(self, vmin=None, vmax=None, midpoint=None, clip=False):\n        \"\"\"MidpointNormalize.\n\n        Parameters\n        ----------\n        vmin\n        vmax\n        midpoint\n        clip\n        \"\"\"\n        self.midpoint = midpoint\n        colors.Normalize.__init__(self, vmin, vmax, clip)\n\n    def __call__(self, value, clip=None):\n        \"\"\"MidpointNormalize.\n\n        ! TODO needs docs\n\n        Parameters\n        ----------\n        value : TYPE\n            DESCRIPTION.\n        clip : TYPE, optional\n            DESCRIPTION. The default is None.\n\n        Returns\n        -------\n        TYPE\n            DESCRIPTION.\n        \"\"\"\n        # I'm ignoring masked values and all kinds of edge cases to make a\n        # simple example...\n        x, y = [self.vmin, self.midpoint, self.vmax], [0, 0.5, 1]\n\n        return np.ma.masked_array(np.interp(value, x, y))\n</code></pre>"},{"location":"api/styles-class/#cleopatra.styles.MidpointNormalize.__call__","title":"<code>__call__(value, clip=None)</code>","text":"<p>MidpointNormalize.</p> <p>! TODO needs docs</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>TYPE</code> <p>DESCRIPTION.</p> required <code>clip</code> <code>TYPE</code> <p>DESCRIPTION. The default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>TYPE</code> <p>DESCRIPTION.</p> Source code in <code>cleopatra/styles.py</code> <pre><code>def __call__(self, value, clip=None):\n    \"\"\"MidpointNormalize.\n\n    ! TODO needs docs\n\n    Parameters\n    ----------\n    value : TYPE\n        DESCRIPTION.\n    clip : TYPE, optional\n        DESCRIPTION. The default is None.\n\n    Returns\n    -------\n    TYPE\n        DESCRIPTION.\n    \"\"\"\n    # I'm ignoring masked values and all kinds of edge cases to make a\n    # simple example...\n    x, y = [self.vmin, self.midpoint, self.vmax], [0, 0.5, 1]\n\n    return np.ma.masked_array(np.interp(value, x, y))\n</code></pre>"},{"location":"api/styles-class/#cleopatra.styles.MidpointNormalize.__init__","title":"<code>__init__(vmin=None, vmax=None, midpoint=None, clip=False)</code>","text":"<p>MidpointNormalize.</p> <p>Parameters:</p> Name Type Description Default <code>vmin</code> <code>None</code> <code>vmax</code> <code>None</code> <code>midpoint</code> <code>None</code> <code>clip</code> <code>False</code> Source code in <code>cleopatra/styles.py</code> <pre><code>def __init__(self, vmin=None, vmax=None, midpoint=None, clip=False):\n    \"\"\"MidpointNormalize.\n\n    Parameters\n    ----------\n    vmin\n    vmax\n    midpoint\n    clip\n    \"\"\"\n    self.midpoint = midpoint\n    colors.Normalize.__init__(self, vmin, vmax, clip)\n</code></pre>"},{"location":"api/styles-class/#examples","title":"Examples","text":""},{"location":"api/styles-class/#log-scale","title":"Log Scale","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom cleopatra.styles import Scale\n\n# Create some data with a wide range of values\ndata = np.array([0.1, 1, 10, 100, 1000])\n\n# Apply log scale\nscale = Scale()\nlog_data = scale.log_scale(data)\n\n# Plot the original and log-scaled data\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 4))\nax1.plot(data)\nax1.set_title('Original Data')\nax2.plot(log_data)\nax2.set_title('Log-Scaled Data')\nplt.tight_layout()\n</code></pre>"},{"location":"api/styles-class/#power-scale","title":"Power Scale","text":"<pre><code># Apply power scale with gamma=0.5 (square root)\npower_data = scale.power_scale(data)(0.5)\n\n# Plot the original and power-scaled data\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 4))\nax1.plot(data)\nax1.set_title('Original Data')\nax2.plot(power_data)\nax2.set_title('Power-Scaled Data (gamma=0.5)')\nplt.tight_layout()\n</code></pre>"},{"location":"api/styles-class/#midpoint-normalize","title":"Midpoint Normalize","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom cleopatra.styles import MidpointNormalize\nimport matplotlib.colors as colors\n\n# Create some data with positive and negative values\ndata = np.random.uniform(-10, 10, (10, 10))\n\n# Create a figure with two subplots\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 4))\n\n# Plot with standard normalization\nim1 = ax1.imshow(data, cmap='RdBu_r', norm=colors.Normalize(vmin=-10, vmax=10))\nax1.set_title('Standard Normalization')\nplt.colorbar(im1, ax=ax1)\n\n# Plot with midpoint normalization (midpoint at 0)\nim2 = ax2.imshow(data, cmap='RdBu_r', norm=MidpointNormalize(vmin=-10, vmax=10, midpoint=0))\nax2.set_title('Midpoint Normalization')\nplt.colorbar(im2, ax=ax2)\n\nplt.tight_layout()\n</code></pre>"},{"location":"notebooks/array_glyph/array_glyph_examples/","title":"ArrayGlyph","text":"In\u00a0[1]: Copied! <pre>import os\nimport numpy as np\n\nfrom cleopatra.array_glyph import ArrayGlyph\nget_ipython().run_line_magic(\"matplotlib\", \"notebook\")  # noqa: F821\n# Set the random seed for reproducibility\nnp.random.seed(42)\n</pre> import os import numpy as np  from cleopatra.array_glyph import ArrayGlyph get_ipython().run_line_magic(\"matplotlib\", \"notebook\")  # noqa: F821 # Set the random seed for reproducibility np.random.seed(42) In\u00a0[2]: Copied! <pre># Create a simple 2D array\nsimple_array = np.zeros((10, 10))\nfor i in range(10):\n    for j in range(10):\n        simple_array[i, j] = i * j  # Create a multiplication table pattern\n</pre> # Create a simple 2D array simple_array = np.zeros((10, 10)) for i in range(10):     for j in range(10):         simple_array[i, j] = i * j  # Create a multiplication table pattern In\u00a0[3]: Copied! <pre># Initialize the ArrayGlyph with the array\narray_glyph = ArrayGlyph(simple_array)\n</pre> # Initialize the ArrayGlyph with the array array_glyph = ArrayGlyph(simple_array) In\u00a0[4]: Copied! <pre># Plot the array with default settings\nfig, ax = array_glyph.plot()\n\n# Display information about the array\nprint(f\"Array shape: {simple_array.shape}\")\nprint(f\"Min value: {simple_array.min()}\")\nprint(f\"Max value: {simple_array.max()}\")\n</pre> # Plot the array with default settings fig, ax = array_glyph.plot()  # Display information about the array print(f\"Array shape: {simple_array.shape}\") print(f\"Min value: {simple_array.min()}\") print(f\"Max value: {simple_array.max()}\") <pre>Array shape: (10, 10)\nMin value: 0.0\nMax value: 81.0\n</pre> <p>Create a more complex array</p> In\u00a0[5]: Copied! <pre>complex_array = np.random.rand(20, 20)  # Random values between 0 and 1\ncomplex_array[5:15, 5:15] = complex_array[5:15, 5:15] * 2  # Increase values in the center\n</pre> complex_array = np.random.rand(20, 20)  # Random values between 0 and 1 complex_array[5:15, 5:15] = complex_array[5:15, 5:15] * 2  # Increase values in the center <ul> <li>Initialize the ArrayGlyph with the array</li> </ul> In\u00a0[6]: Copied! <pre>array_glyph_custom = ArrayGlyph(complex_array)\n\n# Plot with custom settings\nfig, ax = array_glyph_custom.plot(\n    cmap=\"viridis\",           # Use the viridis colormap\n    title=\"Custom Array Plot\", # Add a title\n    ticks_spacing=0.5,          # Set tick spacing\n    figsize=(10, 8)           # Set figure size\n)\n</pre> array_glyph_custom = ArrayGlyph(complex_array)  # Plot with custom settings fig, ax = array_glyph_custom.plot(     cmap=\"viridis\",           # Use the viridis colormap     title=\"Custom Array Plot\", # Add a title     ticks_spacing=0.5,          # Set tick spacing     figsize=(10, 8)           # Set figure size ) <ul> <li>Create an array with positive and negative values</li> </ul> In\u00a0[7]: Copied! <pre>mixed_array = np.random.randn(15, 15)  # Random values from a normal distribution\n</pre> mixed_array = np.random.randn(15, 15)  # Random values from a normal distribution <ul> <li>Initialize the ArrayGlyph with the array</li> </ul> In\u00a0[8]: Copied! <pre>array_glyph_scales = ArrayGlyph(mixed_array)\n</pre> array_glyph_scales = ArrayGlyph(mixed_array) In\u00a0[9]: Copied! <pre>fig1, ax1 = array_glyph_scales.plot(\n    color_scale=\"linear\",\n    cmap=\"RdBu_r\",\n    title=\"Linear Scale\"\n)\n</pre> fig1, ax1 = array_glyph_scales.plot(     color_scale=\"linear\",     cmap=\"RdBu_r\",     title=\"Linear Scale\" ) In\u00a0[10]: Copied! <pre>array_glyph_scales = ArrayGlyph(mixed_array)\nfig2, ax2 = array_glyph_scales.plot(\n    color_scale=\"power\",\n    cmap=\"RdBu_r\",\n    title=\"Power Scale\"\n)\n</pre> array_glyph_scales = ArrayGlyph(mixed_array) fig2, ax2 = array_glyph_scales.plot(     color_scale=\"power\",     cmap=\"RdBu_r\",     title=\"Power Scale\" ) In\u00a0[11]: Copied! <pre># For log scale, we need positive values\npositive_array = np.abs(mixed_array) + 0.1  # Make all values positive and non-zero\narray_glyph_positive = ArrayGlyph(positive_array)\n\nfig3, ax3 = array_glyph_positive.plot(\n    color_scale=\"sym-lognorm\",\n    cmap=\"viridis\",\n    title=\"Log Scale\"\n)\n</pre> # For log scale, we need positive values positive_array = np.abs(mixed_array) + 0.1  # Make all values positive and non-zero array_glyph_positive = ArrayGlyph(positive_array)  fig3, ax3 = array_glyph_positive.plot(     color_scale=\"sym-lognorm\",     cmap=\"viridis\",     title=\"Log Scale\" ) In\u00a0[12]: Copied! <pre>array_glyph_scales = ArrayGlyph(mixed_array)\nfig4, ax4 = array_glyph_scales.plot(\n    color_scale=\"midpoint\",\n    midpoint=0,  # Set the midpoint at 0\n    cmap=\"RdBu_r\",\n    title=\"Midpoint Scale\"\n)\n</pre> array_glyph_scales = ArrayGlyph(mixed_array) fig4, ax4 = array_glyph_scales.plot(     color_scale=\"midpoint\",     midpoint=0,  # Set the midpoint at 0     cmap=\"RdBu_r\",     title=\"Midpoint Scale\" ) <ul> <li>Create a small array for better visibility of cell values</li> </ul> In\u00a0[13]: Copied! <pre># Create a small array for better visibility of cell values\nsmall_array = np.random.randint(0, 100, (5, 5))\n</pre> # Create a small array for better visibility of cell values small_array = np.random.randint(0, 100, (5, 5)) In\u00a0[14]: Copied! <pre># Initialize the ArrayGlyph with the array\narray_glyph_values = ArrayGlyph(small_array)\n\n# Plot with cell values displayed\nfig, ax = array_glyph_values.plot(\n    display_cell_value=True,   # Display cell values\n    num_size=12,               # Set text font size\n    cmap=\"viridis\",            # Use the viridis colormap\n    title=\"Array with Cell Values\",\n    figsize=(8, 6)\n)\n</pre> # Initialize the ArrayGlyph with the array array_glyph_values = ArrayGlyph(small_array)  # Plot with cell values displayed fig, ax = array_glyph_values.plot(     display_cell_value=True,   # Display cell values     num_size=12,               # Set text font size     cmap=\"viridis\",            # Use the viridis colormap     title=\"Array with Cell Values\",     figsize=(8, 6) ) In\u00a0[15]: Copied! <pre># Create an array\npoint_array = np.random.rand(15, 15)\n\n# Create some points to display on the array\n# Points are specified as [value, row, column] coordinates\npoints = np.array([\n    [1, 3, 3],    # Top-left region\n    [2, 3, 11],   # Top-right region\n    [3, 11, 3],   # Bottom-left region\n    [4, 11, 11]   # Bottom-right region\n])\n\n# Initialize the ArrayGlyph with the array\narray_glyph_points = ArrayGlyph(point_array)\n\n# Plot with points\nfig, ax = array_glyph_points.plot(\n    points=points,            # Points to display\n    point_color=\"red\",        # Set point color\n    point_size=100,           # Set point size\n    pid_color=\"blue\",         # Set point ID color\n    pid_size=16,              # Set point ID size\n    cmap=\"viridis\",           # Use the viridis colormap\n    title=\"Array with Points\",\n    figsize=(10, 8)\n)\n</pre> # Create an array point_array = np.random.rand(15, 15)  # Create some points to display on the array # Points are specified as [value, row, column] coordinates points = np.array([     [1, 3, 3],    # Top-left region     [2, 3, 11],   # Top-right region     [3, 11, 3],   # Bottom-left region     [4, 11, 11]   # Bottom-right region ])  # Initialize the ArrayGlyph with the array array_glyph_points = ArrayGlyph(point_array)  # Plot with points fig, ax = array_glyph_points.plot(     points=points,            # Points to display     point_color=\"red\",        # Set point color     point_size=100,           # Set point size     pid_color=\"blue\",         # Set point ID color     pid_size=16,              # Set point ID size     cmap=\"viridis\",           # Use the viridis colormap     title=\"Array with Points\",     figsize=(10, 8) ) In\u00a0[16]: Copied! <pre># Create a 3D array for the animation\nn_frames = 10\nx = np.linspace(0, 10, 20)\ny = np.linspace(0, 10, 20)\nX, Y = np.meshgrid(x, y)\n\n# Create a 3D array with shape (n_frames, 20, 20)\nanimation_array = np.zeros((n_frames, 20, 20))\nfor i in range(n_frames):\n    # Create a wave pattern that changes with time\n    animation_array[i] = np.sin(X + i * 0.5) * np.cos(Y + i * 0.5)\n\n# Initialize the ArrayGlyph with the 3D array\narray_glyph_animation = ArrayGlyph(animation_array)\n\n# Create the animation\nanim = array_glyph_animation.animate(\n    time=list(range(n_frames)),  # Time points\n    points=None,                 # No points to display\n    interval=200,                # Interval between frames (ms)\n    cmap=\"viridis\",              # Use the viridis colormap\n    title=\"Array Animation\",\n    figsize=(10, 8)\n)\n</pre> # Create a 3D array for the animation n_frames = 10 x = np.linspace(0, 10, 20) y = np.linspace(0, 10, 20) X, Y = np.meshgrid(x, y)  # Create a 3D array with shape (n_frames, 20, 20) animation_array = np.zeros((n_frames, 20, 20)) for i in range(n_frames):     # Create a wave pattern that changes with time     animation_array[i] = np.sin(X + i * 0.5) * np.cos(Y + i * 0.5)  # Initialize the ArrayGlyph with the 3D array array_glyph_animation = ArrayGlyph(animation_array)  # Create the animation anim = array_glyph_animation.animate(     time=list(range(n_frames)),  # Time points     points=None,                 # No points to display     interval=200,                # Interval between frames (ms)     cmap=\"viridis\",              # Use the viridis colormap     title=\"Array Animation\",     figsize=(10, 8) ) <ul> <li>Note: To save the animation, you would use:</li> </ul> In\u00a0[17]: Copied! <pre>array_glyph_animation.save_animation(\"animation.gif\", fps=5)\n</pre> array_glyph_animation.save_animation(\"animation.gif\", fps=5) In\u00a0[18]: Copied! <pre>os.listdir(\".\")\n</pre> os.listdir(\".\") Out[18]: <pre>['.ipynb_checkpoints', 'animation.gif', 'array_glyph_examples.ipynb']</pre> In\u00a0[19]: Copied! <pre># Create an array with a wide range of values\nwide_range_array = np.random.exponential(scale=2.0, size=(15, 15))\n\n# Initialize the ArrayGlyph with cutoff values\narray_glyph_cutoff = ArrayGlyph(\n    wide_range_array,\n    cutoff=[1.0, 5.0]  # Set minimum and maximum values\n)\n\n# Plot the array\nfig, ax = array_glyph_cutoff.plot(\n    title=\"Array with Cutoff Values\",\n    figsize=(8, 6)\n)\n</pre> # Create an array with a wide range of values wide_range_array = np.random.exponential(scale=2.0, size=(15, 15))  # Initialize the ArrayGlyph with cutoff values array_glyph_cutoff = ArrayGlyph(     wide_range_array,     cutoff=[1.0, 5.0]  # Set minimum and maximum values )  # Plot the array fig, ax = array_glyph_cutoff.plot(     title=\"Array with Cutoff Values\",     figsize=(8, 6) ) In\u00a0[20]: Copied! <pre># Initialize the ArrayGlyph with percentile cutoff\narray_glyph_percentile = ArrayGlyph(\n    wide_range_array,\n    percentile=2  # Exclude values below 2nd percentile and above 98th percentile\n)\n\n# Plot the array\nfig, ax = array_glyph_percentile.plot(\n    title=\"Array with Percentile Cutoff\",\n    figsize=(8, 6)\n)\n</pre> # Initialize the ArrayGlyph with percentile cutoff array_glyph_percentile = ArrayGlyph(     wide_range_array,     percentile=2  # Exclude values below 2nd percentile and above 98th percentile )  # Plot the array fig, ax = array_glyph_percentile.plot(     title=\"Array with Percentile Cutoff\",     figsize=(8, 6) ) In\u00a0[21]: Copied! <pre># Create an array with some specific values to exclude\nexclude_array = np.random.rand(15, 15)\nexclude_array[5:10, 5:10] = -9999  # Set some values to -9999 (to be excluded)\n\n# Initialize the ArrayGlyph with excluded values\narray_glyph_exclude = ArrayGlyph(\n    exclude_array,\n    exclude_value=[-9999]  # Exclude values equal to -9999\n)\n\n# Plot the array\nfig, ax = array_glyph_exclude.plot(\n    title=\"Array with Excluded Values\",\n    figsize=(8, 6)\n)\n</pre> # Create an array with some specific values to exclude exclude_array = np.random.rand(15, 15) exclude_array[5:10, 5:10] = -9999  # Set some values to -9999 (to be excluded)  # Initialize the ArrayGlyph with excluded values array_glyph_exclude = ArrayGlyph(     exclude_array,     exclude_value=[-9999]  # Exclude values equal to -9999 )  # Plot the array fig, ax = array_glyph_exclude.plot(     title=\"Array with Excluded Values\",     figsize=(8, 6) ) In\u00a0[22]: Copied! <pre># Create an array\ncolorbar_array = np.random.rand(15, 15)\n\n# Initialize the ArrayGlyph with the array\narray_glyph_colorbar = ArrayGlyph(colorbar_array)\n\n# Plot with a custom colorbar\nfig, ax = array_glyph_colorbar.plot(\n    cbar_label=\"Values\",              # Set colorbar label\n    cbar_orientation=\"horizontal\",    # Set colorbar orientation\n    cbar_length=0.8,                  # Shrink the colorbar\n    cmap=\"plasma\",                    # Use the plasma colormap\n    title=\"Array with Custom Colorbar\",\n    figsize=(10, 8)\n)\n</pre> # Create an array colorbar_array = np.random.rand(15, 15)  # Initialize the ArrayGlyph with the array array_glyph_colorbar = ArrayGlyph(colorbar_array)  # Plot with a custom colorbar fig, ax = array_glyph_colorbar.plot(     cbar_label=\"Values\",              # Set colorbar label     cbar_orientation=\"horizontal\",    # Set colorbar orientation     cbar_length=0.8,                  # Shrink the colorbar     cmap=\"plasma\",                    # Use the plasma colormap     title=\"Array with Custom Colorbar\",     figsize=(10, 8) )"},{"location":"notebooks/array_glyph/array_glyph_examples/#arrayglyph","title":"ArrayGlyph\u00b6","text":"<ul> <li>This script demonstrates the usage of the ArrayGlyph class from the Cleopatra package. The ArrayGlyph class provides functionality for visualizing arrays and creating animations.</li> </ul>"},{"location":"notebooks/array_glyph/array_glyph_examples/#1-creating-and-visualizing-a-simple-array","title":"1. Creating and Visualizing a Simple Array\u00b6","text":"<p>Let's start by creating a simple 2D array and visualizing it with ArrayGlyph.</p>"},{"location":"notebooks/array_glyph/array_glyph_examples/#2-customizing-the-array-visualization","title":"2. Customizing the Array Visualization\u00b6","text":"<p>The ArrayGlyph class provides many options for customizing the visualization.</p>"},{"location":"notebooks/array_glyph/array_glyph_examples/#3-using-different-color-scales","title":"3. Using Different Color Scales\u00b6","text":"<ul> <li>The ArrayGlyph class supports different color scales for visualizing arrays.</li> </ul>"},{"location":"notebooks/array_glyph/array_glyph_examples/#31-linear-scale-default","title":"3.1 Linear Scale (default)\u00b6","text":""},{"location":"notebooks/array_glyph/array_glyph_examples/#32-power-scale","title":"3.2 Power Scale\u00b6","text":""},{"location":"notebooks/array_glyph/array_glyph_examples/#33-log-scale","title":"3.3 Log Scale\u00b6","text":""},{"location":"notebooks/array_glyph/array_glyph_examples/#34-midpoint-scale","title":"3.4 Midpoint Scale\u00b6","text":""},{"location":"notebooks/array_glyph/array_glyph_examples/#4-displaying-cell-values","title":"4. Displaying Cell Values\u00b6","text":"<ul> <li>The ArrayGlyph class can display the values of each cell in the array.</li> </ul>"},{"location":"notebooks/array_glyph/array_glyph_examples/#5-displaying-points-on-the-array","title":"5. Displaying Points on the Array\u00b6","text":"<ul> <li>The ArrayGlyph class can display points on top of the array.</li> </ul>"},{"location":"notebooks/array_glyph/array_glyph_examples/#6-creating-an-animation","title":"6. Creating an Animation\u00b6","text":"<ul> <li>The ArrayGlyph class can create animations of arrays changing over time.</li> </ul>"},{"location":"notebooks/array_glyph/array_glyph_examples/#7-preparing-arrays-with-different-methods","title":"7. Preparing Arrays with Different Methods\u00b6","text":"<ul> <li>The ArrayGlyph class provides methods for preparing arrays for visualization.</li> </ul>"},{"location":"notebooks/array_glyph/array_glyph_examples/#71-preparing-an-array-with-cutoff-values","title":"7.1 Preparing an Array with Cutoff Values\u00b6","text":""},{"location":"notebooks/array_glyph/array_glyph_examples/#72-preparing-an-array-with-percentile-cutoff","title":"7.2 Preparing an Array with Percentile Cutoff\u00b6","text":""},{"location":"notebooks/array_glyph/array_glyph_examples/#73-preparing-an-array-with-excluded-values","title":"7.3 Preparing an Array with Excluded Values\u00b6","text":""},{"location":"notebooks/array_glyph/array_glyph_examples/#8-creating-a-custom-colorbar","title":"8. Creating a Custom Colorbar\u00b6","text":"<ul> <li>The ArrayGlyph class allows customization of the colorbar.</li> </ul>"},{"location":"notebooks/array_glyph/array_glyph_examples/#summary","title":"Summary\u00b6","text":"<p>In this notebook, we've explored the ArrayGlyph class from the Cleopatra package.</p> <p>We've seen how to:</p> <ol> <li>Create and visualize simple arrays</li> <li>Customize array visualizations</li> <li>Use different color scales</li> <li>Display cell values</li> <li>Display points on arrays</li> <li>Create animations</li> <li>Prepare arrays with different methods</li> <li>Create custom colorbars</li> </ol> <p>The ArrayGlyph class provides powerful tools for visualizing and animating arrays.</p>"},{"location":"notebooks/colors/colors_examples/","title":"Colors","text":"<ul> <li>This script demonstrates the usage of the Colors class from the Cleopatra package.</li> <li>The Colors class provides functionality for working with colors in different formats.</li> </ul> In\u00a0[26]: Copied! <pre>import matplotlib.pyplot as plt\nfrom cleopatra.colors import Colors\n</pre> import matplotlib.pyplot as plt from cleopatra.colors import Colors In\u00a0[\u00a0]: Copied! <pre>hex_color = Colors(\"#FF5733\")\nprint(f\"Hex color: {hex_color.color_value}\") # pragma: allowlist secret\n</pre> hex_color = Colors(\"#FF5733\") print(f\"Hex color: {hex_color.color_value}\") # pragma: allowlist secret In\u00a0[\u00a0]: Copied! <pre>named_color = Colors(\"blue\")\nprint(f\"Named color: {named_color.color_value}\")\n</pre> named_color = Colors(\"blue\") print(f\"Named color: {named_color.color_value}\") In\u00a0[\u00a0]: Copied! <pre>rgb_color_255 = Colors((255, 0, 0))\nprint(f\"RGB color (0-255): {rgb_color_255.color_value}\")\n</pre> rgb_color_255 = Colors((255, 0, 0)) print(f\"RGB color (0-255): {rgb_color_255.color_value}\") In\u00a0[\u00a0]: Copied! <pre>rgb_color_norm = Colors((1.0, 0.0, 0.0))\nprint(f\"RGB color (0-1): {rgb_color_norm.color_value}\")\n</pre> rgb_color_norm = Colors((1.0, 0.0, 0.0)) print(f\"RGB color (0-1): {rgb_color_norm.color_value}\") In\u00a0[6]: Copied! <pre>color_list = Colors([\"red\", \"green\", \"blue\"])\nprint(f\"Color list: {color_list.color_value}\")\n</pre> color_list = Colors([\"red\", \"green\", \"blue\"]) print(f\"Color list: {color_list.color_value}\") <pre>Color list: ['red', 'green', 'blue']\n</pre> <ul> <li>The to_hex() method converts colors to hexadecimal format.</li> </ul> In\u00a0[7]: Copied! <pre>named_to_hex = Colors(\"purple\")\nhex_value = named_to_hex.to_hex()\nprint(f\"Purple in hex: {hex_value}\")\n</pre> named_to_hex = Colors(\"purple\") hex_value = named_to_hex.to_hex() print(f\"Purple in hex: {hex_value}\") <pre>Purple in hex: ['purple']\n</pre> In\u00a0[8]: Copied! <pre>rgb_to_hex = Colors((0, 128, 0))  # Green in RGB\nhex_value = rgb_to_hex.to_hex()\nprint(f\"Green RGB in hex: {hex_value}\")\n</pre> rgb_to_hex = Colors((0, 128, 0))  # Green in RGB hex_value = rgb_to_hex.to_hex() print(f\"Green RGB in hex: {hex_value}\") <pre>Green RGB in hex: ['#008000']\n</pre> In\u00a0[9]: Copied! <pre>colors_to_hex = Colors([\"red\", (0, 0, 255), \"#00FF00\"])\nhex_values = colors_to_hex.to_hex()\nprint(f\"List of colors in hex: {hex_values}\")\n</pre> colors_to_hex = Colors([\"red\", (0, 0, 255), \"#00FF00\"]) hex_values = colors_to_hex.to_hex() print(f\"List of colors in hex: {hex_values}\") <pre>List of colors in hex: ['red', '#0000ff', '#00FF00']\n</pre> In\u00a0[10]: Copied! <pre>named_to_rgb = Colors(\"orange\")\nrgb_value = named_to_rgb.to_rgb(normalized=True)\nprint(f\"Orange in normalized RGB: {rgb_value}\")\n</pre> named_to_rgb = Colors(\"orange\") rgb_value = named_to_rgb.to_rgb(normalized=True) print(f\"Orange in normalized RGB: {rgb_value}\")  <pre>Orange in normalized RGB: [(1.0, 0.6470588235294118, 0.0)]\n</pre> In\u00a0[11]: Copied! <pre>named_to_rgb_255 = Colors(\"orange\")\nrgb_value_255 = named_to_rgb_255.to_rgb(normalized=False)\nprint(f\"Orange in RGB (0-255): {rgb_value_255}\")\n</pre> named_to_rgb_255 = Colors(\"orange\") rgb_value_255 = named_to_rgb_255.to_rgb(normalized=False) print(f\"Orange in RGB (0-255): {rgb_value_255}\") <pre>Orange in RGB (0-255): [(255, 165, 0)]\n</pre> In\u00a0[12]: Copied! <pre>hex_to_rgb = Colors(\"#4287f5\")  # Blue-ish color\nrgb_value = hex_to_rgb.to_rgb(normalized=True)\nprint(f\"#4287f5 in normalized RGB: {rgb_value}\")\n</pre> hex_to_rgb = Colors(\"#4287f5\")  # Blue-ish color rgb_value = hex_to_rgb.to_rgb(normalized=True) print(f\"#4287f5 in normalized RGB: {rgb_value}\") <pre>#4287f5 in normalized RGB: [(0.25882352941176473, 0.5294117647058824, 0.9607843137254902)]\n</pre> In\u00a0[13]: Copied! <pre>colors_to_rgb = Colors([\"red\", \"#00FF00\", (0, 0, 255)])\nrgb_values = colors_to_rgb.to_rgb(normalized=True)\nprint(f\"List of colors in normalized RGB: {rgb_values}\")\n</pre> colors_to_rgb = Colors([\"red\", \"#00FF00\", (0, 0, 255)]) rgb_values = colors_to_rgb.to_rgb(normalized=True) print(f\"List of colors in normalized RGB: {rgb_values}\") <pre>List of colors in normalized RGB: [(1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)]\n</pre> In\u00a0[14]: Copied! <pre>valid_hex = Colors.is_valid_hex_i(\"#FF5733\")\ninvalid_hex = Colors.is_valid_hex_i(\"#XYZ\")\nprint(f\"Is #FF5733 a valid hex color? {valid_hex}\")\nprint(f\"Is #XYZ a valid hex color? {invalid_hex}\")\n</pre> valid_hex = Colors.is_valid_hex_i(\"#FF5733\") invalid_hex = Colors.is_valid_hex_i(\"#XYZ\") print(f\"Is #FF5733 a valid hex color? {valid_hex}\") print(f\"Is #XYZ a valid hex color? {invalid_hex}\") <pre>Is #FF5733 a valid hex color? True\nIs #XYZ a valid hex color? False\n</pre> In\u00a0[15]: Copied! <pre>valid_rgb_255 = Colors.is_valid_rgb_255((255, 0, 0))\ninvalid_rgb_255 = Colors.is_valid_rgb_255((300, 0, 0))  # 300 is out of range\nprint(f\"Is (255, 0, 0) a valid RGB color? {valid_rgb_255}\")\nprint(f\"Is (300, 0, 0) a valid RGB color? {invalid_rgb_255}\")\n</pre> valid_rgb_255 = Colors.is_valid_rgb_255((255, 0, 0)) invalid_rgb_255 = Colors.is_valid_rgb_255((300, 0, 0))  # 300 is out of range print(f\"Is (255, 0, 0) a valid RGB color? {valid_rgb_255}\") print(f\"Is (300, 0, 0) a valid RGB color? {invalid_rgb_255}\") <pre>Is (255, 0, 0) a valid RGB color? True\nIs (300, 0, 0) a valid RGB color? False\n</pre> In\u00a0[16]: Copied! <pre>valid_rgb_norm = Colors.is_valid_rgb_norm((0.5, 0.5, 0.5))\ninvalid_rgb_norm = Colors.is_valid_rgb_norm((1.5, 0.5, 0.5))  # 1.5 is out of range\nprint(f\"Is (0.5, 0.5, 0.5) a valid normalized RGB color? {valid_rgb_norm}\")\nprint(f\"Is (1.5, 0.5, 0.5) a valid normalized RGB color? {invalid_rgb_norm}\")\n</pre> valid_rgb_norm = Colors.is_valid_rgb_norm((0.5, 0.5, 0.5)) invalid_rgb_norm = Colors.is_valid_rgb_norm((1.5, 0.5, 0.5))  # 1.5 is out of range print(f\"Is (0.5, 0.5, 0.5) a valid normalized RGB color? {valid_rgb_norm}\") print(f\"Is (1.5, 0.5, 0.5) a valid normalized RGB color? {invalid_rgb_norm}\") <pre>Is (0.5, 0.5, 0.5) a valid normalized RGB color? True\nIs (1.5, 0.5, 0.5) a valid normalized RGB color? False\n</pre> In\u00a0[17]: Copied! <pre>hex_color_type = Colors(\"#FF5733\")\nprint(f\"Type of #FF5733: {hex_color_type.get_type()}\")\n</pre> hex_color_type = Colors(\"#FF5733\") print(f\"Type of #FF5733: {hex_color_type.get_type()}\") <pre>Type of #FF5733: ['hex']\n</pre> In\u00a0[18]: Copied! <pre>named_color_type = Colors(\"blue\")\nprint(f\"Type of 'blue': {named_color_type.get_type()}\")\n</pre> named_color_type = Colors(\"blue\") print(f\"Type of 'blue': {named_color_type.get_type()}\") <pre>Type of 'blue': ['hex']\n</pre> In\u00a0[19]: Copied! <pre>rgb_color_type = Colors((255, 0, 0))\nprint(f\"Type of (255, 0, 0): {rgb_color_type.get_type()}\")\n</pre> rgb_color_type = Colors((255, 0, 0)) print(f\"Type of (255, 0, 0): {rgb_color_type.get_type()}\") <pre>Type of (255, 0, 0): ['rgb']\n</pre> In\u00a0[20]: Copied! <pre>color_list_type = Colors([\"red\", \"green\", \"blue\"])\nprint(f\"Type of ['red', 'green', 'blue']: {color_list_type.get_type()}\")\n</pre> color_list_type = Colors([\"red\", \"green\", \"blue\"]) print(f\"Type of ['red', 'green', 'blue']: {color_list_type.get_type()}\") <pre>Type of ['red', 'green', 'blue']: ['hex', 'hex', 'hex']\n</pre> In\u00a0[21]: Copied! <pre>color_names = [\"red\", \"green\", \"blue\", \"yellow\", \"purple\", \"orange\", \"cyan\", \"magenta\"]\ncolors_obj = Colors(color_names)\nhex_colors = colors_obj.to_hex()\n</pre> color_names = [\"red\", \"green\", \"blue\", \"yellow\", \"purple\", \"orange\", \"cyan\", \"magenta\"] colors_obj = Colors(color_names) hex_colors = colors_obj.to_hex() In\u00a0[22]: Copied! <pre>plt.figure(figsize=(10, 6))\nbars = plt.bar(range(len(color_names)), [1] * len(color_names), color=hex_colors)\n\n# Add color names as labels\nfor i, bar in enumerate(bars):\n    plt.text(bar.get_x() + bar.get_width()/2, 0.5, color_names[i], \n             ha='center', va='center', color='white' if color_names[i] in ['blue', 'purple'] else 'black')\n\nplt.title(\"Visualization of Different Colors\")\nplt.xticks([])\nplt.yticks([])\nplt.show()\n</pre> plt.figure(figsize=(10, 6)) bars = plt.bar(range(len(color_names)), [1] * len(color_names), color=hex_colors)  # Add color names as labels for i, bar in enumerate(bars):     plt.text(bar.get_x() + bar.get_width()/2, 0.5, color_names[i],               ha='center', va='center', color='white' if color_names[i] in ['blue', 'purple'] else 'black')  plt.title(\"Visualization of Different Colors\") plt.xticks([]) plt.yticks([]) plt.show() In\u00a0[23]: Copied! <pre>custom_colors = [\n    \"#1f77b4\",  # Blue\n    \"#ff7f0e\",  # Orange\n    \"#2ca02c\",  # Green\n    \"#d62728\",  # Red\n    \"#9467bd\",  # Purple\n    \"#8c564b\",  # Brown\n    \"#e377c2\",  # Pink\n    \"#7f7f7f\"   # Gray\n]\n</pre> custom_colors = [     \"#1f77b4\",  # Blue     \"#ff7f0e\",  # Orange     \"#2ca02c\",  # Green     \"#d62728\",  # Red     \"#9467bd\",  # Purple     \"#8c564b\",  # Brown     \"#e377c2\",  # Pink     \"#7f7f7f\"   # Gray ] In\u00a0[24]: Copied! <pre>custom_palette = Colors(custom_colors)\nrgb_palette = custom_palette.to_rgb(normalized=True)\n</pre> custom_palette = Colors(custom_colors) rgb_palette = custom_palette.to_rgb(normalized=True) In\u00a0[25]: Copied! <pre>plt.figure(figsize=(10, 6))\nbars = plt.bar(range(len(custom_colors)), [1] * len(custom_colors), color=custom_colors)\n\n# Add RGB values as labels\nfor i, bar in enumerate(bars):\n    rgb_values = [round(val, 2) for val in rgb_palette[i]]\n    plt.text(bar.get_x() + bar.get_width()/2, 0.5, str(rgb_values), \n             ha='center', va='center', color='white' if i in [0, 2, 4, 5] else 'black')\n\nplt.title(\"Custom Color Palette with RGB Values\")\nplt.xticks([])\nplt.yticks([])\nplt.show()\n</pre> plt.figure(figsize=(10, 6)) bars = plt.bar(range(len(custom_colors)), [1] * len(custom_colors), color=custom_colors)  # Add RGB values as labels for i, bar in enumerate(bars):     rgb_values = [round(val, 2) for val in rgb_palette[i]]     plt.text(bar.get_x() + bar.get_width()/2, 0.5, str(rgb_values),               ha='center', va='center', color='white' if i in [0, 2, 4, 5] else 'black')  plt.title(\"Custom Color Palette with RGB Values\") plt.xticks([]) plt.yticks([]) plt.show()"},{"location":"notebooks/colors/colors_examples/#colors","title":"Colors\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#1-initializing-colors-with-different-formats","title":"1. Initializing Colors with Different Formats\u00b6","text":"<p>The Colors class can be initialized with different color formats:</p> <ul> <li>Hex color strings (e.g., \"#FF5733\")</li> <li>Named colors (e.g., \"red\", \"blue\")</li> <li>RGB tuples (e.g., (255, 0, 0) or (1.0, 0.0, 0.0))</li> <li>Lists of any of the above</li> </ul>"},{"location":"notebooks/colors/colors_examples/#11-initializing-with-hex-colors","title":"1.1 Initializing with Hex Colors\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#12-initializing-with-named-colors","title":"1.2 Initializing with Named Colors\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#13-initializing-with-rgb-tuples-0-255","title":"1.3 Initializing with RGB Tuples (0-255)\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#14-initializing-with-rgb-tuples-0-1","title":"1.4 Initializing with RGB Tuples (0-1)\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#15-initializing-with-a-list-of-colors","title":"1.5 Initializing with a List of Colors\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#2-converting-colors-to-hex-format","title":"2. Converting Colors to Hex Format\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#21-converting-a-named-color-to-hex","title":"2.1 Converting a Named Color to Hex\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#22-converting-rgb-to-hex","title":"2.2 Converting RGB to Hex\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#23-converting-a-list-of-colors-to-hex","title":"2.3 Converting a List of Colors to Hex\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#3-converting-colors-to-rgb-format","title":"3. Converting Colors to RGB Format\u00b6","text":"<ul> <li>The to_rgb() method converts colors to RGB format.</li> </ul>"},{"location":"notebooks/colors/colors_examples/#31-converting-a-named-color-to-rgb-normalized","title":"3.1 Converting a Named Color to RGB (normalized)\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#32-converting-a-named-color-to-rgb-0-255","title":"3.2 Converting a Named Color to RGB (0-255)\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#33-converting-hex-to-rgb","title":"3.3 Converting Hex to RGB\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#34-converting-a-list-of-colors-to-rgb","title":"3.4 Converting a List of Colors to RGB\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#4-checking-color-validity","title":"4. Checking Color Validity\u00b6","text":"<ul> <li>The Colors class provides methods to check if colors are valid.</li> </ul>"},{"location":"notebooks/colors/colors_examples/#41-checking-if-a-hex-color-is-valid","title":"4.1 Checking if a Hex Color is Valid\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#42-checking-if-an-rgb-color-is-valid-0-255","title":"4.2 Checking if an RGB Color is Valid (0-255)\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#43-checking-if-an-rgb-color-is-valid-0-1","title":"4.3 Checking if an RGB Color is Valid (0-1)\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#5-getting-the-type-of-color","title":"5. Getting the Type of Color\u00b6","text":"<ul> <li>The get_type() method returns the type of color.</li> </ul>"},{"location":"notebooks/colors/colors_examples/#51-getting-the-type-of-a-hex-color","title":"5.1 Getting the Type of a Hex Color\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#52-getting-the-type-of-a-named-color","title":"5.2 Getting the Type of a Named Color\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#53-getting-the-type-of-an-rgb-color","title":"5.3 Getting the Type of an RGB Color\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#54-getting-the-type-of-a-list-of-colors","title":"5.4 Getting the Type of a List of Colors\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#6-visualizing-colors","title":"6. Visualizing Colors\u00b6","text":"<ul> <li>Let's visualize some colors using matplotlib.</li> </ul>"},{"location":"notebooks/colors/colors_examples/#61-create-a-list-of-colors","title":"6.1 Create a list of colors\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#62-create-a-bar-chart-with-these-colors","title":"6.2 Create a bar chart with these colors\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#7-creating-a-custom-color-palette","title":"7. Creating a Custom Color Palette\u00b6","text":"<ul> <li>Let's create a custom color palette and visualize it.</li> </ul>"},{"location":"notebooks/colors/colors_examples/#71-define-a-list-of-custom-colors","title":"7.1 Define a list of custom colors\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#72-create-a-colors-object-and-convert-to-rgb","title":"7.2 Create a Colors object and convert to RGB\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#73-visualize-the-palette","title":"7.3 Visualize the palette\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#summary","title":"Summary\u00b6","text":"<p>In this notebook, we've explored the Colors class from the Cleopatra package. We've seen how to:</p> <ol> <li>Initialize the Colors class with different color formats</li> <li>Convert colors to hexadecimal format</li> <li>Convert colors to RGB format</li> <li>Check if colors are valid</li> <li>Get the type of color</li> <li>Visualize colors</li> <li>Create custom color palettes</li> </ol> <p>The Colors class provides a convenient way to work with colors in different formats for data visualization and plotting.</p>"},{"location":"notebooks/statistics/statistics_examples/","title":"Statistics","text":"<ul> <li>This script demonstrates the usage of the Statistic class from the Cleopatra package.</li> <li>The Statistic class provides functionality for creating statistical plots, specifically histograms.</li> </ul> In\u00a0[1]: Copied! <pre>import numpy as np\nfrom cleopatra.statistics import Statistic\n\n# Set the random seed for reproducibility\nnp.random.seed(1)\n</pre> import numpy as np from cleopatra.statistics import Statistic  # Set the random seed for reproducibility np.random.seed(1) In\u00a0[2]: Copied! <pre>data_1d = 4 + np.random.normal(0, 1.5, 200)\n</pre> data_1d = 4 + np.random.normal(0, 1.5, 200) In\u00a0[3]: Copied! <pre>stat_plot_1d = Statistic(data_1d)\n</pre> stat_plot_1d = Statistic(data_1d) In\u00a0[4]: Copied! <pre>fig_1d, ax_1d, hist_1d = stat_plot_1d.histogram()\n\n# Display information about the histogram\nprint(f\"Number of bins: {len(hist_1d['n'][0])}\")\nprint(f\"Bin counts: {hist_1d['n'][0]}\")\nprint(f\"Bin edges: {hist_1d['bins'][0][:5]}... (showing first 5)\")\n</pre> fig_1d, ax_1d, hist_1d = stat_plot_1d.histogram()  # Display information about the histogram print(f\"Number of bins: {len(hist_1d['n'][0])}\") print(f\"Bin counts: {hist_1d['n'][0]}\") print(f\"Bin edges: {hist_1d['bins'][0][:5]}... (showing first 5)\") <pre>Number of bins: 15\nBin counts: [ 2.  4.  3. 10. 11. 20. 30. 27. 31. 25. 17.  8.  5.  6.  1.]\nBin edges: [0.34774335 0.8440597  1.34037605 1.8366924  2.33300874]... (showing first 5)\n</pre> In\u00a0[5]: Copied! <pre>stat_plot_1d_custom = Statistic(data_1d)\n</pre> stat_plot_1d_custom = Statistic(data_1d) In\u00a0[6]: Copied! <pre>fig_1d_custom, ax_1d_custom, hist_1d_custom = stat_plot_1d_custom.histogram(\n    bins=20,                # Increase the number of bins\n    color=[\"#FF5733\"],      # Change the color to orange-red\n    alpha=0.8,              # Slightly increase transparency\n    rwidth=0.9,             # Increase the width of the bins\n    xlabel=\"Values\",         # Add x-axis label\n    ylabel=\"Frequency\",      # Add y-axis label\n    xlabel_font_size=12,    # Set x-axis label font size\n    ylabel_font_size=12,    # Set y-axis label font size\n    grid_alpha=0.3          # Reduce grid transparency\n)\n</pre> fig_1d_custom, ax_1d_custom, hist_1d_custom = stat_plot_1d_custom.histogram(     bins=20,                # Increase the number of bins     color=[\"#FF5733\"],      # Change the color to orange-red     alpha=0.8,              # Slightly increase transparency     rwidth=0.9,             # Increase the width of the bins     xlabel=\"Values\",         # Add x-axis label     ylabel=\"Frequency\",      # Add y-axis label     xlabel_font_size=12,    # Set x-axis label font size     ylabel_font_size=12,    # Set y-axis label font size     grid_alpha=0.3          # Reduce grid transparency ) In\u00a0[7]: Copied! <pre>data_2d = np.zeros((200, 3))\ndata_2d[:, 0] = 3 + np.random.normal(0, 1.0, 200)  # Mean of 3, std of 1.0\ndata_2d[:, 1] = 5 + np.random.normal(0, 1.2, 200)  # Mean of 5, std of 1.2\ndata_2d[:, 2] = 7 + np.random.normal(0, 0.8, 200)  # Mean of 7, std of 0.8\n</pre> data_2d = np.zeros((200, 3)) data_2d[:, 0] = 3 + np.random.normal(0, 1.0, 200)  # Mean of 3, std of 1.0 data_2d[:, 1] = 5 + np.random.normal(0, 1.2, 200)  # Mean of 5, std of 1.2 data_2d[:, 2] = 7 + np.random.normal(0, 0.8, 200)  # Mean of 7, std of 0.8 In\u00a0[8]: Copied! <pre>stat_plot_2d = Statistic(data_2d)\n</pre> stat_plot_2d = Statistic(data_2d) <ul> <li><p>Generate a histogram plot for the 2D data</p> </li> <li><p>Note: We need to provide colors for each column</p> </li> </ul> In\u00a0[9]: Copied! <pre>fig_2d, ax_2d, hist_2d = stat_plot_2d.histogram(color=[\"red\", \"green\", \"blue\"])\n</pre> fig_2d, ax_2d, hist_2d = stat_plot_2d.histogram(color=[\"red\", \"green\", \"blue\"]) In\u00a0[10]: Copied! <pre>stat_plot_2d_custom = Statistic(\n    data_2d,\n    color=[\"#FF5733\", \"#33FF57\", \"#3357FF\"],  # Custom colors\n    alpha=0.5,                                # Set transparency\n    rwidth=0.8                                # Set bin width\n)\n</pre> stat_plot_2d_custom = Statistic(     data_2d,     color=[\"#FF5733\", \"#33FF57\", \"#3357FF\"],  # Custom colors     alpha=0.5,                                # Set transparency     rwidth=0.8                                # Set bin width ) In\u00a0[11]: Copied! <pre>fig_2d_custom, ax_2d_custom, hist_2d_custom = stat_plot_2d_custom.histogram(\n    bins=25,                # Increase the number of bins\n    xlabel=\"Values\",         # Add x-axis label\n    ylabel=\"Frequency\",      # Add y-axis label\n    xlabel_font_size=14,    # Set x-axis label font size\n    ylabel_font_size=14,    # Set y-axis label font size\n    xtick_font_size=10,     # Set x-axis tick font size\n    ytick_font_size=10,     # Set y-axis tick font size\n    grid_alpha=0.2,         # Reduce grid transparency\n    figsize=(10, 6)         # Set figure size\n)\n</pre> fig_2d_custom, ax_2d_custom, hist_2d_custom = stat_plot_2d_custom.histogram(     bins=25,                # Increase the number of bins     xlabel=\"Values\",         # Add x-axis label     ylabel=\"Frequency\",      # Add y-axis label     xlabel_font_size=14,    # Set x-axis label font size     ylabel_font_size=14,    # Set y-axis label font size     xtick_font_size=10,     # Set x-axis tick font size     ytick_font_size=10,     # Set y-axis tick font size     grid_alpha=0.2,         # Reduce grid transparency     figsize=(10, 6)         # Set figure size ) In\u00a0[12]: Copied! <pre>n_samples = 1000\ndata_distributions = np.zeros((n_samples, 3))\n</pre> n_samples = 1000 data_distributions = np.zeros((n_samples, 3)) In\u00a0[13]: Copied! <pre>data_distributions[:, 0] = np.random.normal(0, 1, n_samples)\n</pre> data_distributions[:, 0] = np.random.normal(0, 1, n_samples) In\u00a0[14]: Copied! <pre>data_distributions[:, 1] = np.random.exponential(1, n_samples)\n</pre> data_distributions[:, 1] = np.random.exponential(1, n_samples) In\u00a0[15]: Copied! <pre>data_distributions[:, 2] = np.random.uniform(-1.5, 1.5, n_samples)\n</pre> data_distributions[:, 2] = np.random.uniform(-1.5, 1.5, n_samples) In\u00a0[16]: Copied! <pre>stat_plot_distributions = Statistic(\n    data_distributions,\n    color=[\"#3498DB\", \"#E74C3C\", \"#2ECC71\"],  # Blue, Red, Green\n    alpha=0.6,\n    rwidth=0.9\n)\n</pre> stat_plot_distributions = Statistic(     data_distributions,     color=[\"#3498DB\", \"#E74C3C\", \"#2ECC71\"],  # Blue, Red, Green     alpha=0.6,     rwidth=0.9 ) In\u00a0[17]: Copied! <pre>fig_dist, ax_dist, hist_dist = stat_plot_distributions.histogram(\n    bins=30,\n    xlabel=\"Values\",\n    ylabel=\"Frequency\",\n    figsize=(12, 7)\n)\n\n# Add a legend to identify the distributions\nax_dist.legend([\"Normal\", \"Exponential\", \"Uniform\"])\n</pre> fig_dist, ax_dist, hist_dist = stat_plot_distributions.histogram(     bins=30,     xlabel=\"Values\",     ylabel=\"Frequency\",     figsize=(12, 7) )  # Add a legend to identify the distributions ax_dist.legend([\"Normal\", \"Exponential\", \"Uniform\"]) Out[17]: <pre>&lt;matplotlib.legend.Legend at 0x175e8aba660&gt;</pre> In\u00a0[18]: Copied! <pre>try:\n    # Create a Statistic object with 2D data but only 2 colors for 3 columns\n    stat_plot_error = Statistic(data_2d)\n    \n    # This should raise an error because we're providing only 2 colors for 3 columns\n    fig_error, ax_error, hist_error = stat_plot_error.histogram(color=[\"red\", \"green\"])\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n</pre> try:     # Create a Statistic object with 2D data but only 2 colors for 3 columns     stat_plot_error = Statistic(data_2d)          # This should raise an error because we're providing only 2 colors for 3 columns     fig_error, ax_error, hist_error = stat_plot_error.histogram(color=[\"red\", \"green\"]) except ValueError as e:     print(f\"Error: {e}\") <pre>Error: The number of colors:2 should be equal to the number of samples:3\n</pre>"},{"location":"notebooks/statistics/statistics_examples/#statistics","title":"Statistics\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#1-creating-histograms-with-1d-data","title":"1. Creating Histograms with 1D Data\u00b6","text":"<ul> <li>Let's start by creating a histogram for 1D data.</li> <li>We'll generate some random data and use the Statistic class to create a histogram.</li> </ul>"},{"location":"notebooks/statistics/statistics_examples/#generate-1d-data","title":"Generate 1D data\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#create-a-statistic-object-with-the-1d-data","title":"Create a Statistic object with the 1D data\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#generate-a-histogram-plot-for-the-1d-data","title":"Generate a histogram plot for the 1D data\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#11-customizing-the-histogram","title":"1.1 Customizing the Histogram\u00b6","text":"<ul> <li>Now let's customize the histogram by changing the number of bins, color, transparency, and width.</li> </ul>"},{"location":"notebooks/statistics/statistics_examples/#create-a-statistic-object-with-the-1d-data","title":"Create a Statistic object with the 1D data\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#generate-a-customized-histogram-plot","title":"Generate a customized histogram plot\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#2-creating-histograms-with-2d-data","title":"2. Creating Histograms with 2D Data\u00b6","text":"<ul> <li>The Statistic class can also handle 2D data, creating multiple histograms in the same plot.</li> <li>Let's generate some 2D data and create histograms.</li> </ul>"},{"location":"notebooks/statistics/statistics_examples/#generate-2d-data-with-3-columns","title":"Generate 2D data with 3 columns\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#create-a-statistic-object-with-the-2d-data","title":"Create a Statistic object with the 2D data\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#21-customizing-the-2d-histogram","title":"2.1 Customizing the 2D Histogram\u00b6","text":"<ul> <li>Let's customize the 2D histogram with more options.</li> </ul>"},{"location":"notebooks/statistics/statistics_examples/#create-a-statistic-object-with-the-2d-data-and-custom-parameters","title":"Create a Statistic object with the 2D data and custom parameters\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#generate-a-customized-histogram-plot","title":"Generate a customized histogram plot\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#3-comparing-distributions","title":"3. Comparing Distributions\u00b6","text":"<ul> <li>The Statistic class is particularly useful for comparing multiple distributions.</li> <li>Let's create an example that compares different distributions.</li> </ul>"},{"location":"notebooks/statistics/statistics_examples/#generate-data-from-different-distributions","title":"Generate data from different distributions\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#normal-distribution","title":"Normal distribution\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#exponential-distribution","title":"Exponential distribution\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#uniform-distribution","title":"Uniform distribution\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#create-a-statistic-object-with-the-distribution-data","title":"Create a Statistic object with the distribution data\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#generate-a-histogram-plot-comparing-the-distributions","title":"Generate a histogram plot comparing the distributions\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#4-error-handling","title":"4. Error Handling\u00b6","text":"<ul> <li>The Statistic class includes error handling to ensure that the number of colors</li> <li>provided matches the number of samples in the data.</li> <li>Let's see what happens when we provide an incorrect number of colors.</li> </ul>"},{"location":"notebooks/statistics/statistics_examples/#summary","title":"Summary\u00b6","text":"<p>In this notebook, we've explored the Statistic class from the Cleopatra package. We've seen how to:</p> <ol> <li>Create histograms for 1D data</li> <li>Create histograms for 2D data</li> <li>Customize histograms with various parameters</li> <li>Compare different distributions</li> <li>Handle errors when using the class</li> </ol> <p>The Statistic class provides a convenient way to create and customize histograms for statistical analysis and visualization.</p>"},{"location":"notebooks/styles/styles_examples/","title":"Styles","text":"In\u00a0[13]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nfrom cleopatra.styles import Styles, Scale, MidpointNormalize\nimport matplotlib.colors as colors\n</pre> import numpy as np import matplotlib.pyplot as plt from cleopatra.styles import Styles, Scale, MidpointNormalize import matplotlib.colors as colors In\u00a0[14]: Copied! <pre># Get a list of available line style names\nline_style_names = [\n    \"solid\", \"dotted\", \"dashed\", \"dashdot\", \n    \"loosely dotted\", \"densely dotted\", \n    \"loosely dashed\", \"densely dashed\", \n    \"loosely dashdotted\", \"densely dashdotted\"\n]\n\n# Create a figure to display different line styles\nplt.figure(figsize=(12, 8))\n\n# Plot each line style\nfor i, style_name in enumerate(line_style_names):\n    # Get the line style\n    line_style = Styles.get_line_style(style_name)\n\n    # Plot a line with this style\n    plt.plot([0, 1], [i, i], linestyle=line_style, linewidth=2, color='blue', label=style_name)\n\n    # Add the style name as text\n    plt.text(1.1, i, style_name, va='center')\n\nplt.xlim(0, 2)\nplt.ylim(-0.5, len(line_style_names) - 0.5)\nplt.title(\"Line Styles Available in Styles Class\")\nplt.grid(True, linestyle='--', alpha=0.7)\nplt.tight_layout()\nplt.show()\n</pre> # Get a list of available line style names line_style_names = [     \"solid\", \"dotted\", \"dashed\", \"dashdot\",      \"loosely dotted\", \"densely dotted\",      \"loosely dashed\", \"densely dashed\",      \"loosely dashdotted\", \"densely dashdotted\" ]  # Create a figure to display different line styles plt.figure(figsize=(12, 8))  # Plot each line style for i, style_name in enumerate(line_style_names):     # Get the line style     line_style = Styles.get_line_style(style_name)      # Plot a line with this style     plt.plot([0, 1], [i, i], linestyle=line_style, linewidth=2, color='blue', label=style_name)      # Add the style name as text     plt.text(1.1, i, style_name, va='center')  plt.xlim(0, 2) plt.ylim(-0.5, len(line_style_names) - 0.5) plt.title(\"Line Styles Available in Styles Class\") plt.grid(True, linestyle='--', alpha=0.7) plt.tight_layout() plt.show() <pre> The style name you entered-dashdot-does not exist pleasechoose from the available styles\n['solid', 'loosely dotted', 'dotted', 'densely dotted', 'loosely dashed', 'dashed', 'densely dashed', 'loosely dashdotted', 'dashdotted', 'densely dashdotted', 'loosely dashdotdotted', 'dashdotdotted', 'densely dashdotdotted', 'densely dashdotdottededited']\n</pre> In\u00a0[15]: Copied! <pre># Create a list of standard matplotlib markers\nstandard_markers = ['o', 's', 'D', '^', 'v', '&lt;', '&gt;', 'p', '*', 'h', '+', 'x', '|', '_', '.', ',', '1', '2', '3', '4', '8']\n\n# Create a figure to display different marker styles\nplt.figure(figsize=(12, 8))\n\n# Plot markers\nfor i, marker in enumerate(standard_markers):\n    if i &gt;= 21:  # Limit to 21 markers to match the original example\n        break\n\n    # Calculate grid position (5 markers per row)\n    row = i // 5\n    col = i % 5\n\n    # Plot the marker\n    plt.plot(col, row, marker=marker, markersize=15, color='blue')\n\n    # Add the marker as text\n    plt.text(col + 0.2, row, f\"Marker '{marker}'\", va='center')\n\nplt.xlim(-0.5, 5.5)\nplt.ylim(-0.5, 4.5)\nplt.gca().invert_yaxis()  # Invert y-axis to have marker 0 at the top\nplt.title(\"Standard Matplotlib Markers\")\nplt.grid(False)\nplt.tight_layout()\nplt.show()\n</pre> # Create a list of standard matplotlib markers standard_markers = ['o', 's', 'D', '^', 'v', '&lt;', '&gt;', 'p', '*', 'h', '+', 'x', '|', '_', '.', ',', '1', '2', '3', '4', '8']  # Create a figure to display different marker styles plt.figure(figsize=(12, 8))  # Plot markers for i, marker in enumerate(standard_markers):     if i &gt;= 21:  # Limit to 21 markers to match the original example         break      # Calculate grid position (5 markers per row)     row = i // 5     col = i % 5      # Plot the marker     plt.plot(col, row, marker=marker, markersize=15, color='blue')      # Add the marker as text     plt.text(col + 0.2, row, f\"Marker '{marker}'\", va='center')  plt.xlim(-0.5, 5.5) plt.ylim(-0.5, 4.5) plt.gca().invert_yaxis()  # Invert y-axis to have marker 0 at the top plt.title(\"Standard Matplotlib Markers\") plt.grid(False) plt.tight_layout() plt.show() In\u00a0[16]: Copied! <pre># Create some sample data\nx = np.linspace(0, 10, 100)\ny = np.exp(x/5)  # Exponential data that grows quickly\n\n# 2.1 Log Scale\n# The log_scale method applies a logarithmic scale to the data.\n\n# Apply log scale to the data\ny_log = Scale.log_scale(y)\n\n# Plot original and log-scaled data\nplt.figure(figsize=(12, 6))\n\nplt.subplot(1, 2, 1)\nplt.plot(x, y, 'b-', linewidth=2)\nplt.title(\"Original Data (Exponential)\")\nplt.grid(True)\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\n\nplt.subplot(1, 2, 2)\nplt.plot(x, y_log, 'r-', linewidth=2)\nplt.title(\"Log-Scaled Data\")\nplt.grid(True)\nplt.xlabel(\"x\")\nplt.ylabel(\"log(y)\")\n\nplt.tight_layout()\nplt.show()\n</pre> # Create some sample data x = np.linspace(0, 10, 100) y = np.exp(x/5)  # Exponential data that grows quickly  # 2.1 Log Scale # The log_scale method applies a logarithmic scale to the data.  # Apply log scale to the data y_log = Scale.log_scale(y)  # Plot original and log-scaled data plt.figure(figsize=(12, 6))  plt.subplot(1, 2, 1) plt.plot(x, y, 'b-', linewidth=2) plt.title(\"Original Data (Exponential)\") plt.grid(True) plt.xlabel(\"x\") plt.ylabel(\"y\")  plt.subplot(1, 2, 2) plt.plot(x, y_log, 'r-', linewidth=2) plt.title(\"Log-Scaled Data\") plt.grid(True) plt.xlabel(\"x\") plt.ylabel(\"log(y)\")  plt.tight_layout() plt.show() In\u00a0[17]: Copied! <pre># Create power scale functions with different minimum values\npower_scale_func1 = Scale.power_scale(min_val=0)\npower_scale_func2 = Scale.power_scale(min_val=1)\npower_scale_func3 = Scale.power_scale(min_val=2)\n\n# Apply power scale to the data\ny_power_1 = power_scale_func1(y)  # Power scale with min_val=0\ny_power_2 = power_scale_func2(y)  # Power scale with min_val=1\ny_power_3 = power_scale_func3(y)  # Power scale with min_val=2\n\n# Plot original and power-scaled data\nplt.figure(figsize=(12, 8))\n\nplt.subplot(2, 2, 1)\nplt.plot(x, y, 'b-', linewidth=2)\nplt.title(\"Original Data\")\nplt.grid(True)\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\n\nplt.subplot(2, 2, 2)\nplt.plot(x, y_power_1, 'r-', linewidth=2)\nplt.title(\"Power Scale (min_val=0)\")\nplt.grid(True)\nplt.xlabel(\"x\")\nplt.ylabel(\"y (power scaled)\")\n\nplt.subplot(2, 2, 3)\nplt.plot(x, y_power_2, 'g-', linewidth=2)\nplt.title(\"Power Scale (min_val=1)\")\nplt.grid(True)\nplt.xlabel(\"x\")\nplt.ylabel(\"y (power scaled)\")\n\nplt.subplot(2, 2, 4)\nplt.plot(x, y_power_3, 'm-', linewidth=2)\nplt.title(\"Power Scale (min_val=2)\")\nplt.grid(True)\nplt.xlabel(\"x\")\nplt.ylabel(\"y (power scaled)\")\n\nplt.tight_layout()\nplt.show()\n</pre> # Create power scale functions with different minimum values power_scale_func1 = Scale.power_scale(min_val=0) power_scale_func2 = Scale.power_scale(min_val=1) power_scale_func3 = Scale.power_scale(min_val=2)  # Apply power scale to the data y_power_1 = power_scale_func1(y)  # Power scale with min_val=0 y_power_2 = power_scale_func2(y)  # Power scale with min_val=1 y_power_3 = power_scale_func3(y)  # Power scale with min_val=2  # Plot original and power-scaled data plt.figure(figsize=(12, 8))  plt.subplot(2, 2, 1) plt.plot(x, y, 'b-', linewidth=2) plt.title(\"Original Data\") plt.grid(True) plt.xlabel(\"x\") plt.ylabel(\"y\")  plt.subplot(2, 2, 2) plt.plot(x, y_power_1, 'r-', linewidth=2) plt.title(\"Power Scale (min_val=0)\") plt.grid(True) plt.xlabel(\"x\") plt.ylabel(\"y (power scaled)\")  plt.subplot(2, 2, 3) plt.plot(x, y_power_2, 'g-', linewidth=2) plt.title(\"Power Scale (min_val=1)\") plt.grid(True) plt.xlabel(\"x\") plt.ylabel(\"y (power scaled)\")  plt.subplot(2, 2, 4) plt.plot(x, y_power_3, 'm-', linewidth=2) plt.title(\"Power Scale (min_val=2)\") plt.grid(True) plt.xlabel(\"x\") plt.ylabel(\"y (power scaled)\")  plt.tight_layout() plt.show() In\u00a0[18]: Copied! <pre># Create some data with values between -10 and 10\nx = np.linspace(0, 10, 100)\ny = np.sin(x) * 10\n\n# Create a custom scaling function that scales data to range [0, 1]\ndef custom_scale(values, old_min=-10, old_max=10):\n    \"\"\"Scale values from range [old_min, old_max] to range [0, 1]\"\"\"\n    return (values - old_min) / (old_max - old_min)\n\n# Apply custom scale to the data\ny_scaled = custom_scale(y)\n\n# Plot original and identity-scaled data\nplt.figure(figsize=(12, 6))\n\nplt.subplot(1, 2, 1)\nplt.plot(x, y, 'b-', linewidth=2)\nplt.title(\"Original Data\")\nplt.grid(True)\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.ylim(-12, 12)\n\nplt.subplot(1, 2, 2)\nplt.plot(x, y_scaled, 'r-', linewidth=2)\nplt.title(\"Custom-Scaled Data (0-1)\")\nplt.grid(True)\nplt.xlabel(\"x\")\nplt.ylabel(\"Scaled y\")\nplt.ylim(-0.2, 1.2)\n\nplt.tight_layout()\nplt.show()\n</pre> # Create some data with values between -10 and 10 x = np.linspace(0, 10, 100) y = np.sin(x) * 10  # Create a custom scaling function that scales data to range [0, 1] def custom_scale(values, old_min=-10, old_max=10):     \"\"\"Scale values from range [old_min, old_max] to range [0, 1]\"\"\"     return (values - old_min) / (old_max - old_min)  # Apply custom scale to the data y_scaled = custom_scale(y)  # Plot original and identity-scaled data plt.figure(figsize=(12, 6))  plt.subplot(1, 2, 1) plt.plot(x, y, 'b-', linewidth=2) plt.title(\"Original Data\") plt.grid(True) plt.xlabel(\"x\") plt.ylabel(\"y\") plt.ylim(-12, 12)  plt.subplot(1, 2, 2) plt.plot(x, y_scaled, 'r-', linewidth=2) plt.title(\"Custom-Scaled Data (0-1)\") plt.grid(True) plt.xlabel(\"x\") plt.ylabel(\"Scaled y\") plt.ylim(-0.2, 1.2)  plt.tight_layout() plt.show() In\u00a0[19]: Copied! <pre># Create some data\nx = np.linspace(0, 10, 100)\ny = np.sin(x)  # Values between -1 and 1\n\n# Rescale the data from range [-1, 1] to range [0, 100]\ny_rescaled = Scale.rescale(y, old_min=-1, old_max=1, new_min=0, new_max=100)\n\n# Plot original and rescaled data\nplt.figure(figsize=(12, 6))\n\nplt.subplot(1, 2, 1)\nplt.plot(x, y, 'b-', linewidth=2)\nplt.title(\"Original Data (Range: -1 to 1)\")\nplt.grid(True)\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.ylim(-1.2, 1.2)\n\nplt.subplot(1, 2, 2)\nplt.plot(x, y_rescaled, 'r-', linewidth=2)\nplt.title(\"Rescaled Data (Range: 0 to 100)\")\nplt.grid(True)\nplt.xlabel(\"x\")\nplt.ylabel(\"Rescaled y\")\nplt.ylim(-10, 110)\n\nplt.tight_layout()\nplt.show()\n</pre> # Create some data x = np.linspace(0, 10, 100) y = np.sin(x)  # Values between -1 and 1  # Rescale the data from range [-1, 1] to range [0, 100] y_rescaled = Scale.rescale(y, old_min=-1, old_max=1, new_min=0, new_max=100)  # Plot original and rescaled data plt.figure(figsize=(12, 6))  plt.subplot(1, 2, 1) plt.plot(x, y, 'b-', linewidth=2) plt.title(\"Original Data (Range: -1 to 1)\") plt.grid(True) plt.xlabel(\"x\") plt.ylabel(\"y\") plt.ylim(-1.2, 1.2)  plt.subplot(1, 2, 2) plt.plot(x, y_rescaled, 'r-', linewidth=2) plt.title(\"Rescaled Data (Range: 0 to 100)\") plt.grid(True) plt.xlabel(\"x\") plt.ylabel(\"Rescaled y\") plt.ylim(-10, 110)  plt.tight_layout() plt.show() In\u00a0[20]: Copied! <pre># Create a 2D array with positive and negative values\ndelta = 0.025\nx = np.arange(-3.0, 3.0, delta)\ny = np.arange(-2.0, 2.0, delta)\nX, Y = np.meshgrid(x, y)\nZ = np.sin(X) * np.cos(Y) * 3  # Values between -3 and 3\n\n# 3.1 Standard Normalization\n# First, let's use the standard normalization for comparison\nplt.figure(figsize=(15, 5))\n\nplt.subplot(1, 3, 1)\nstandard_norm = plt.pcolormesh(X, Y, Z, cmap='RdBu_r', shading='auto')\nplt.colorbar(standard_norm)\nplt.title(\"Standard Normalization\")\nplt.axis('equal')\n\n# 3.2 MidpointNormalize with midpoint=0\n# Now, let's use MidpointNormalize with midpoint at 0\nmidpoint_norm_0 = MidpointNormalize(vmin=-3, vmax=3, midpoint=0)\nplt.subplot(1, 3, 2)\nmid_norm_plot = plt.pcolormesh(X, Y, Z, norm=midpoint_norm_0, cmap='RdBu_r', shading='auto')\nplt.colorbar(mid_norm_plot)\nplt.title(\"MidpointNormalize (midpoint=0)\")\nplt.axis('equal')\n\n# 3.3 MidpointNormalize with midpoint=1\n# Let's use MidpointNormalize with midpoint at 1\nmidpoint_norm_1 = MidpointNormalize(vmin=-3, vmax=3, midpoint=1)\nplt.subplot(1, 3, 3)\nmid_norm_plot_1 = plt.pcolormesh(X, Y, Z, norm=midpoint_norm_1, cmap='RdBu_r', shading='auto')\nplt.colorbar(mid_norm_plot_1)\nplt.title(\"MidpointNormalize (midpoint=1)\")\nplt.axis('equal')\n\nplt.tight_layout()\nplt.show()\n</pre> # Create a 2D array with positive and negative values delta = 0.025 x = np.arange(-3.0, 3.0, delta) y = np.arange(-2.0, 2.0, delta) X, Y = np.meshgrid(x, y) Z = np.sin(X) * np.cos(Y) * 3  # Values between -3 and 3  # 3.1 Standard Normalization # First, let's use the standard normalization for comparison plt.figure(figsize=(15, 5))  plt.subplot(1, 3, 1) standard_norm = plt.pcolormesh(X, Y, Z, cmap='RdBu_r', shading='auto') plt.colorbar(standard_norm) plt.title(\"Standard Normalization\") plt.axis('equal')  # 3.2 MidpointNormalize with midpoint=0 # Now, let's use MidpointNormalize with midpoint at 0 midpoint_norm_0 = MidpointNormalize(vmin=-3, vmax=3, midpoint=0) plt.subplot(1, 3, 2) mid_norm_plot = plt.pcolormesh(X, Y, Z, norm=midpoint_norm_0, cmap='RdBu_r', shading='auto') plt.colorbar(mid_norm_plot) plt.title(\"MidpointNormalize (midpoint=0)\") plt.axis('equal')  # 3.3 MidpointNormalize with midpoint=1 # Let's use MidpointNormalize with midpoint at 1 midpoint_norm_1 = MidpointNormalize(vmin=-3, vmax=3, midpoint=1) plt.subplot(1, 3, 3) mid_norm_plot_1 = plt.pcolormesh(X, Y, Z, norm=midpoint_norm_1, cmap='RdBu_r', shading='auto') plt.colorbar(mid_norm_plot_1) plt.title(\"MidpointNormalize (midpoint=1)\") plt.axis('equal')  plt.tight_layout() plt.show() In\u00a0[21]: Copied! <pre># Create some data\nx = np.linspace(0, 10, 100)\ny1 = np.sin(x)\ny2 = np.cos(x)\ny3 = np.sin(x) * np.exp(x/10)\ny4 = np.cos(x) * np.exp(-x/10)\n\n# Create a figure with different line styles and markers\nplt.figure(figsize=(12, 8))\n\n# Define standard matplotlib markers to use\nmarkers = ['o', 's', '^', 'D']\n\n# Plot with solid line style\nplt.plot(x, y1, linestyle=Styles.get_line_style(\"solid\"), \n         marker=markers[0], markersize=8, \n         markevery=10, linewidth=2, label=\"sin(x)\")\n\n# Plot with dashed line style\nplt.plot(x, y2, linestyle=Styles.get_line_style(\"dashed\"), \n         marker=markers[1], markersize=8, \n         markevery=10, linewidth=2, label=\"cos(x)\")\n\n# Plot with dashdot line style\nplt.plot(x, y3, linestyle=Styles.get_line_style(\"dashdot\"), \n         marker=markers[2], markersize=8, \n         markevery=10, linewidth=2, label=\"sin(x) * exp(x/10)\")\n\n# Plot with dotted line style\nplt.plot(x, y4, linestyle=Styles.get_line_style(\"dotted\"), \n         marker=markers[3], markersize=8, \n         markevery=10, linewidth=2, label=\"cos(x) * exp(-x/10)\")\n\nplt.title(\"Combining Different Styles\")\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.grid(True, linestyle='--', alpha=0.7)\nplt.legend()\nplt.tight_layout()\nplt.show()\n</pre> # Create some data x = np.linspace(0, 10, 100) y1 = np.sin(x) y2 = np.cos(x) y3 = np.sin(x) * np.exp(x/10) y4 = np.cos(x) * np.exp(-x/10)  # Create a figure with different line styles and markers plt.figure(figsize=(12, 8))  # Define standard matplotlib markers to use markers = ['o', 's', '^', 'D']  # Plot with solid line style plt.plot(x, y1, linestyle=Styles.get_line_style(\"solid\"),           marker=markers[0], markersize=8,           markevery=10, linewidth=2, label=\"sin(x)\")  # Plot with dashed line style plt.plot(x, y2, linestyle=Styles.get_line_style(\"dashed\"),           marker=markers[1], markersize=8,           markevery=10, linewidth=2, label=\"cos(x)\")  # Plot with dashdot line style plt.plot(x, y3, linestyle=Styles.get_line_style(\"dashdot\"),           marker=markers[2], markersize=8,           markevery=10, linewidth=2, label=\"sin(x) * exp(x/10)\")  # Plot with dotted line style plt.plot(x, y4, linestyle=Styles.get_line_style(\"dotted\"),           marker=markers[3], markersize=8,           markevery=10, linewidth=2, label=\"cos(x) * exp(-x/10)\")  plt.title(\"Combining Different Styles\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.grid(True, linestyle='--', alpha=0.7) plt.legend() plt.tight_layout() plt.show() <pre> The style name you entered-dashdot-does not exist pleasechoose from the available styles\n['solid', 'loosely dotted', 'dotted', 'densely dotted', 'loosely dashed', 'dashed', 'densely dashed', 'loosely dashdotted', 'dashdotted', 'densely dashdotted', 'loosely dashdotdotted', 'dashdotdotted', 'densely dashdotdotted', 'densely dashdotdottededited']\n</pre>"},{"location":"notebooks/styles/styles_examples/#styles","title":"Styles\u00b6","text":"<ul> <li><p>This notebook demonstrates the usage of the Styles, Scale, and MidpointNormalize classes from the Cleopatra package.</p> </li> <li><p>The styles class provides functionality for styling and scaling visualizations.</p> </li> </ul>"},{"location":"notebooks/styles/styles_examples/#1-using-the-styles-class","title":"1. Using the Styles Class\u00b6","text":"<ul> <li>The Styles class provides methods for getting line and marker styles.</li> </ul>"},{"location":"notebooks/styles/styles_examples/#11-getting-line-styles","title":"1.1 Getting Line Styles\u00b6","text":"<ul> <li>The get_line_style method returns line styles for matplotlib plots.</li> </ul>"},{"location":"notebooks/styles/styles_examples/#12-using-standard-matplotlib-markers","title":"1.2 Using Standard Matplotlib Markers\u00b6","text":"<ul> <li>Instead of using Styles.get_marker_style, we'll use standard matplotlib markers.</li> </ul>"},{"location":"notebooks/styles/styles_examples/#2-using-the-scale-class","title":"2. Using the Scale Class\u00b6","text":"<ul> <li>The Scale class provides methods for scaling data in different ways.</li> </ul>"},{"location":"notebooks/styles/styles_examples/#22-power-scale","title":"2.2 Power Scale\u00b6","text":"<ul> <li>The power_scale method applies a power scale to the data.</li> </ul>"},{"location":"notebooks/styles/styles_examples/#23-custom-scaling-function","title":"2.3 Custom Scaling Function\u00b6","text":"<ul> <li>Instead of using Scale.identity_scale, we'll create our own scaling function</li> </ul>"},{"location":"notebooks/styles/styles_examples/#24-rescale","title":"2.4 Rescale\u00b6","text":"<ul> <li>The rescale method rescales values from one range to another.</li> </ul>"},{"location":"notebooks/styles/styles_examples/#3-using-the-midpointnormalize-class","title":"3. Using the MidpointNormalize Class\u00b6","text":"<ul> <li>The MidpointNormalize class is a normalization that maps a range of values to colors, with a specific midpoint value that maps to a specific color.</li> </ul>"},{"location":"notebooks/styles/styles_examples/#4-combining-different-styles-and-scales","title":"4. Combining Different Styles and Scales\u00b6","text":"<ul> <li>Let's combine different styles and scales in a single visualization.</li> </ul>"},{"location":"notebooks/styles/styles_examples/#summary","title":"Summary\u00b6","text":"<ul> <li>In this notebook, we've explored the Styles, Scale, and MidpointNormalize classes from the Cleopatra package.</li> <li>We've seen how to:</li> </ul> <ol> <li>Use the Styles class to get line styles</li> <li>Use standard matplotlib markers</li> <li>Use the Scale class to apply different scaling methods:<ul> <li>Log scale</li> <li>Power scale</li> <li>Identity scale</li> <li>Rescale</li> </ul> </li> <li>Use the MidpointNormalize class to create color maps with specific midpoints</li> <li>Combine different styles and scales in visualizations</li> </ol> <p>These classes provide powerful tools for customizing and enhancing visualizations.</p>"}]}