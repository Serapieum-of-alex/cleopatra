{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cleopatra - Matplotlib utility package","text":"<p>cleopatra is a Python package providing a fast and flexible way to build visualize data using matplotlib. It provides functionalities to handle 3D arrays and perform various operations on them, such as plotting, animating, and displaying the array. It also provides functionalities for creating statistical plots.</p>"},{"location":"#main-features","title":"Main Features","text":"<p>The <code>Array</code> class has the following functionalities:</p> <ul> <li>Initialize an array object with the provided parameters.</li> <li>Plot the array with optional parameters to customize the appearance and display cell values.</li> <li>Animate the array over time with optional parameters to customize the animation speed and display points.</li> <li>Display the array with optional parameters to customize the appearance and display point IDs.</li> </ul> <p>The <code>Statistic</code> module provides a class for creating statistical plots, specifically histograms. The class, <code>Statistic</code>, is designed to handle both 1D (single-dimensional) and 2D (multi-dimensional) data.</p>"},{"location":"change-log/","title":"Changelog","text":""},{"location":"change-log/#010-2022-05-24","title":"0.1.0 (2022-05-24)","text":"<ul> <li>First release on PyPI.</li> </ul>"},{"location":"change-log/#024-2022-12-26","title":"0.2.4 (2022-12-26)","text":"<ul> <li>bump up numpy versions to 1.23.5, add pandas</li> </ul>"},{"location":"change-log/#025-2022-12-26","title":"0.2.5 (2022-12-26)","text":"<ul> <li>plot array with discrete bounds takes the bounds as a parameter</li> </ul>"},{"location":"change-log/#026-2023-01-31","title":"0.2.6 (2023-01-31)","text":"<ul> <li>bump up versions</li> <li>add serapeum_utils as a dependency</li> </ul>"},{"location":"change-log/#027-2023-01-31","title":"0.2.7 (2023-01-31)","text":"<ul> <li>bump up numpy to version 1.24.1</li> </ul>"},{"location":"change-log/#030-2023-04-11","title":"0.3.0 (2023-04-11)","text":"<ul> <li>change API to work completly with numpy array inputs</li> <li>chenge to conda config</li> <li>add hpc-utils to filter and access arrays</li> <li>restructure the whole modules to array, statistics, and styles modules.</li> <li>all modules has classes.</li> <li>save animation function using ffmpeg.</li> </ul>"},{"location":"change-log/#031-2023-04-17","title":"0.3.1 (2023-04-17)","text":"<ul> <li>plot RGB plots</li> </ul>"},{"location":"change-log/#032-2023-04-23","title":"0.3.2 (2023-04-23)","text":"<ul> <li>bump up hpc version</li> </ul>"},{"location":"change-log/#033-2023-04-25","title":"0.3.3 (2023-04-25)","text":"<ul> <li>change the default value for the color bar label.</li> </ul>"},{"location":"change-log/#034-2023-04-26","title":"0.3.4 (2023-04-26)","text":"<ul> <li>pass the plot kwargs to the init of the array to scale the color bar using the vmin and vmax.</li> </ul>"},{"location":"change-log/#035-2023-8-31","title":"0.3.5 (2023-8-31)","text":"<ul> <li>Update dependencies</li> </ul>"},{"location":"change-log/#040-2023-9-24","title":"0.4.0 (2023-9-24)","text":"<ul> <li>Add a colors module to handle issues related to</li> <li>Converting colors from one format to another</li> <li>Creating colormaps</li> </ul>"},{"location":"change-log/#041-2024-1-11","title":"0.4.1 (2024-1-11)","text":"<ul> <li>add extent to the array plot.</li> </ul>"},{"location":"change-log/#042-2024-06-30","title":"0.4.2 (2024-06-30)","text":"<ul> <li>Update dependencies</li> </ul>"},{"location":"change-log/#043-2024-07-13","title":"0.4.3 (2024-07-13)","text":"<ul> <li>Add extent to the array plot when plotting an rgb array.</li> <li>Add <code>ax</code>, and <code>fig</code> parameters to the <code>Array</code> constructor method to take an Axes and plot the array on it.</li> <li>Add <code>__str__</code> to the <code>Array</code> class.</li> </ul>"},{"location":"change-log/#050-2024-07-22","title":"0.5.0 (2024-07-22)","text":""},{"location":"change-log/#arrayglyph","title":"ArrayGlyph","text":"<ul> <li>rename the <code>Array</code> class to <code>ArrayGlyph</code>.</li> <li>add <code>scale_percentile</code> method to the <code>Array</code> class to scale the array using the percentile values.</li> <li>the <code>statistic.histogram</code> can plot multiple column array.</li> <li>change the <code>color_scale</code> values to be string (<code>linear</code>, \"power\", ...)</li> <li>the <code>kwargs</code> can be provided to the constructor or the <code>plot</code> method to plot the array.</li> </ul>"},{"location":"change-log/#colors","title":"Colors","text":"<ul> <li>rename the <code>get_rgb</code> to <code>to_rgb</code></li> <li>add <code>get_type</code> to get the type of the color.</li> <li>add <code>to_hex</code> to convert the color to hex.</li> <li>add <code>to_rgb</code> to convert the color to rgb.</li> </ul>"},{"location":"change-log/#051-2024-07-24","title":"0.5.1 (2024-07-24)","text":""},{"location":"change-log/#arrayglyph_1","title":"ArrayGlyph","text":"<ul> <li>the ArrayGlyph constructor uses a masked array instead of a numpy array.</li> </ul>"},{"location":"change-log/#052-2025-05-08","title":"0.5.2 (2025-05-08)","text":""},{"location":"change-log/#dev","title":"Dev","text":"<ul> <li>replace the setup.py with pyproject.toml</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#dependencies","title":"Dependencies","text":""},{"location":"installation/#required-dependencies","title":"Required dependencies","text":"<ul> <li>Python (3.11 or later)</li> <li>numpy (2.0.0 or later)</li> <li>hpc (0.1.4 or later)</li> <li>matplotlib (3.8.4 or later)</li> <li>ffmpeg-python (0.2.0 or later)</li> </ul>"},{"location":"installation/#stable-release","title":"Stable release","text":"<p>Please install <code>cleopatra</code> in a Virtual environment so that its requirements don't tamper with your system's python.</p>"},{"location":"installation/#conda","title":"conda","text":"<p>The easiest way to install <code>cleopatra</code> is using <code>conda</code> package manager. <code>cleopatra</code> is available in the conda-forge channel. To install you can use the following command:</p> <pre><code>conda install -c conda-forge cleopatra\n</code></pre> <p>If this works it will install <code>cleopatra</code> with all dependencies including Python, and you skip the rest of the installation instructions.</p>"},{"location":"installation/#installing-python-and-gdal-dependencies","title":"Installing Python and gdal dependencies","text":"<p>The main dependencies for cleopatra are an installation of Python 3.11+</p>"},{"location":"installation/#installing-python","title":"Installing Python","text":"<p>For Python, we recommend using the Anaconda Distribution for Python 3, which is available for download from https://www.anaconda.com/download/. The installer gives the option to add <code>python</code> to your <code>PATH</code> environment variable. We will assume in the instructions below that it is available in the path, such that <code>python</code>, <code>pip</code>, and <code>conda</code> are all available from the command line.</p> <p>Note that there is no hard requirement specifically for Anaconda's Python, but often it makes installation of required dependencies easier using the conda package manager.</p>"},{"location":"installation/#install-as-a-conda-environment","title":"Install as a conda environment","text":"<p>The easiest and most robust way to install Hapi is by installing it in a separate conda environment. In the root repository directory there is an <code>environment.yml</code> file. This file lists all dependencies. Either use the <code>environment.yml</code> file from the master branch (please note that the master branch can change rapidly and break functionality without warning), or from one of the releases {release}.</p> <p>Run this command to start installing all Hapi dependencies:</p> <pre><code>conda env create -f environment.yml\n</code></pre> <p>This creates a new environment with the name <code>cleopatra</code>. To activate this environment in a session, run:</p> <pre><code>conda activate cleopatra\n</code></pre> <p>For the installation of Hapi there are two options (from the Python Package Index (PyPI) or from Github). To install a release of Hapi from the PyPI (available from release 2018.1):</p> <pre><code>pip install cleopatra=={release}\n</code></pre>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>The sources for HapiSM can be downloaded from the Github repo.</p> <p>You can either clone the public repository:</p> <pre><code>git clone git://github.com/Serapieum-of-alex/cleopatra\n</code></pre> <p>Or download the tarball:</p> <pre><code>curl -OJL https://github.com/Serapieum-of-alex/cleopatra/tarball/main\n</code></pre> <p>Once you have a copy of the source, you can install it with:</p> <pre><code>python pip install .\n</code></pre> <p>To install directly from GitHub (from the HEAD of the master branch):</p> <pre><code>pip install git+https://github.com/Serapieum-of-alex/cleopatra.git\n</code></pre> <p>or from Github from a specific release:</p> <pre><code>pip install git+https://github.com/Serapieum-of-alex/cleopatra.git@{release}\n</code></pre> <p>Now you should be able to start this environment's Python with <code>python</code>, try <code>import cleopatra</code> to see if the package is installed.</p> <p>More details on how to work with conda environments can be found here: https://conda.io/docs/user-guide/tasks/manage-environments.html</p> <p>If you are planning to make changes and contribute to the development of Hapi, it is best to make a git clone of the repository, and do a editable install in the location of you clone. This will not move a copy to your Python installation directory, but instead create a link in your Python installation pointing to the folder you installed it from, such that any changes you make there are directly reflected in your install.</p> <pre><code>git clone https://github.com/Serapieum-of-alex/cleopatra.git\ncd cleopatra\nactivate cleopatra\npip install -e .\n</code></pre> <p>Alternatively, if you want to avoid using <code>git</code> and simply want to test the latest version from the <code>main</code> branch, you can replace the first line with downloading a zip archive from GitHub: https://github.com/Serapieum-of-alex/cleopatra/archive/master.zip libraries.io.</p>"},{"location":"installation/#install-using-pip","title":"Install using pip","text":"<p>Besides the recommended conda environment setup described above, you can also install <code>cleopatra</code> with <code>pip</code>. For the more difficult to install Python dependencies, it is best to use the conda package manager:</p> <pre><code>conda install numpy gdal\n</code></pre> <p>you can check libraries.io to check versions of the libraries</p> <p>Then install a release {release} of cleopatra (available from release 2018.1) with pip:</p> <pre><code>pip install cleopatra=={release}\n</code></pre>"},{"location":"installation/#check-if-the-installation-is-successful","title":"Check if the installation is successful","text":"<p>To check it the install is successful, go to the examples directory and run the following command:</p> <pre><code>python -m cleopatra.*******\n</code></pre> <p>This should run without errors.</p> <p>Note</p> <p>This documentation was generated on {{ date }}</p> <p>Documentation for the development version: https://cleopatra.readthedocs.org/en/latest/</p> <p>Documentation for the stable version: https://cleopatra.readthedocs.org/en/stable/</p>"},{"location":"api/array-glyph-class/","title":"Array Class","text":"<p>The <code>ArrayGlyph</code> class provides functionality for visualizing and manipulating arrays, including plotting, animating, and saving animations.</p>"},{"location":"api/array-glyph-class/#class-documentation","title":"Class Documentation","text":""},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph","title":"<code>cleopatra.array_glyph.ArrayGlyph</code>","text":"<p>A class to handle arrays and perform various visualization operations on them.</p> <p>The ArrayGlyph class provides functionality for visualizing 2D and 3D arrays with various customization options. It supports plotting single arrays, RGB arrays, and creating animations from 3D arrays.</p> <p>Attributes:</p> Name Type Description <code>fig</code> <code>Figure</code> <p>The matplotlib figure object.</p> <code>ax</code> <code>Axes</code> <p>The matplotlib axes object.</p> <code>extent</code> <code>List</code> <p>The extent of the array [xmin, xmax, ymin, ymax].</p> <code>rgb</code> <code>bool</code> <p>Whether the array is an RGB array.</p> <code>no_elem</code> <code>int</code> <p>The number of elements in the array.</p> <code>anim</code> <code>FuncAnimation</code> <p>The animation object if created.</p> Notes <p>This class provides methods for: - Plotting arrays with customizable color scales, color bars, and annotations - Creating animations from 3D arrays - Displaying point values on arrays - Customizing plot appearance</p> <p>Examples:</p> <p>Create a simple array plot: ```python</p> <p>import numpy as np from cleopatra.array_glyph import ArrayGlyph arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) array_glyph = ArrayGlyph(arr) fig, ax = array_glyph.plot()</p> <p>Create an RGB plot from a 3D array: ```python</p> <pre><code>&gt;&gt;&gt; rgb_array = np.random.randint(0, 255, size=(3, 10, 10))\n&gt;&gt;&gt; rgb_glyph = ArrayGlyph(rgb_array, rgb=[0, 1, 2])\n&gt;&gt;&gt; fig, ax = rgb_glyph.plot()\n</code></pre> <p>Create an animated plot from a 3D array: ```python</p> <p>time_series = np.random.randint(1, 10, size=(5, 10, 10)) time_labels = [\"Frame 1\", \"Frame 2\", \"Frame 3\", \"Frame 4\", \"Frame 5\"] animated_glyph = ArrayGlyph(time_series) anim = animated_glyph.animate(time_labels)</p> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>class ArrayGlyph:\n    \"\"\"A class to handle arrays and perform various visualization operations on them.\n\n    The ArrayGlyph class provides functionality for visualizing 2D and 3D arrays with\n    various customization options. It supports plotting single arrays, RGB arrays,\n    and creating animations from 3D arrays.\n\n    Attributes\n    ----------\n    fig : matplotlib.figure.Figure\n        The matplotlib figure object.\n    ax : matplotlib.axes.Axes\n        The matplotlib axes object.\n    extent : List\n        The extent of the array [xmin, xmax, ymin, ymax].\n    rgb : bool\n        Whether the array is an RGB array.\n    no_elem : int\n        The number of elements in the array.\n    anim : matplotlib.animation.FuncAnimation\n        The animation object if created.\n\n    Notes\n    -----\n    This class provides methods for:\n    - Plotting arrays with customizable color scales, color bars, and annotations\n    - Creating animations from 3D arrays\n    - Displaying point values on arrays\n    - Customizing plot appearance\n\n    Examples\n    --------\n    Create a simple array plot:\n    ```python\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from cleopatra.array_glyph import ArrayGlyph\n    &gt;&gt;&gt; arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    &gt;&gt;&gt; array_glyph = ArrayGlyph(arr)\n    &gt;&gt;&gt; fig, ax = array_glyph.plot()\n\n    Create an RGB plot from a 3D array:\n    ```python\n    &gt;&gt;&gt; rgb_array = np.random.randint(0, 255, size=(3, 10, 10))\n    &gt;&gt;&gt; rgb_glyph = ArrayGlyph(rgb_array, rgb=[0, 1, 2])\n    &gt;&gt;&gt; fig, ax = rgb_glyph.plot()\n\n    Create an animated plot from a 3D array:\n    ```python\n    &gt;&gt;&gt; time_series = np.random.randint(1, 10, size=(5, 10, 10))\n    &gt;&gt;&gt; time_labels = [\"Frame 1\", \"Frame 2\", \"Frame 3\", \"Frame 4\", \"Frame 5\"]\n    &gt;&gt;&gt; animated_glyph = ArrayGlyph(time_series)\n    &gt;&gt;&gt; anim = animated_glyph.animate(time_labels)\n    \"\"\"\n\n    def __init__(\n        self,\n        array: np.ndarray,\n        exclude_value: List = np.nan,\n        extent: List = None,\n        rgb: List[int] = None,\n        surface_reflectance: int = None,\n        cutoff: List = None,\n        ax: Axes = None,\n        fig: Figure = None,\n        percentile: int = None,\n        **kwargs,\n    ):\n        \"\"\"Initialize the ArrayGlyph object with an array and optional parameters.\n\n        Parameters\n        ----------\n        array : np.ndarray\n            The array to be visualized. Can be a 2D array for single plots or a 3D array for RGB plots or animations.\n        exclude_value : List or numeric, optional\n            Value(s) used to mask cells out of the domain, by default np.nan.\n            Can be a single value or a list of values to exclude.\n        extent : List, optional\n            The extent of the array in the format [xmin, ymin, xmax, ymax], by default None.\n            If provided, the array will be plotted with these spatial boundaries.\n        rgb : List[int], optional\n            The indices of the red, green, and blue bands in the given array, by default None.\n            If provided, the array will be treated as an RGB image.\n            Can be a list of three values [r, g, b], or four values if alpha band is included [r, g, b, a].\n        surface_reflectance : int, optional\n            Surface reflectance value for normalizing satellite data, by default None.\n            Typically 10000 for Sentinel-2 data.\n        cutoff : List, optional\n            Clip the range of pixel values for each band, by default None.\n            Takes only pixel values from 0 to the value of the cutoff and scales them back to between 0 and 1.\n            Should be a list with one value per band.\n        ax : matplotlib.axes.Axes, optional\n            A pre-existing axes to plot on, by default None.\n            If None, a new axes will be created.\n        fig : matplotlib.figure.Figure, optional\n            A pre-existing figure to plot on, by default None.\n            If None, a new figure will be created.\n        percentile : int, optional\n            The percentile value to be used for scaling the array values, by default None.\n            Used to enhance contrast by stretching the histogram.\n        **kwargs : dict\n            Additional keyword arguments for customizing the plot.\n            Supported arguments include:\n                figsize : tuple, optional\n                    Figure size, by default (8, 8).\n                vmin : float, optional\n                    Minimum value for color scaling, by default min(array).\n                vmax : float, optional\n                    Maximum value for color scaling, by default max(array).\n                title : str, optional\n                    Title of the plot, by default 'Array Plot'.\n                title_size : int, optional\n                    Title font size, by default 15.\n                cmap : str, optional\n                    Colormap name, by default 'coolwarm_r'.\n\n        Raises\n        ------\n        ValueError\n            If an invalid keyword argument is provided.\n        ValueError\n            If rgb is provided but the array doesn't have enough dimensions.\n\n        Examples\n        --------\n        Basic initialization with a 2D array:\n        ```python\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from cleopatra.array_glyph import ArrayGlyph\n        &gt;&gt;&gt; arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        &gt;&gt;&gt; array_glyph = ArrayGlyph(arr)\n        &gt;&gt;&gt; fig, ax = array_glyph.plot()\n\n        ```\n        Initialization with custom figure size and title:\n        ```python\n        &gt;&gt;&gt; array_glyph = ArrayGlyph(arr, figsize=(10, 8), title=\"Custom Array Plot\")\n        &gt;&gt;&gt; fig, ax = array_glyph.plot()\n\n        ```\n        Initialization with RGB bands from a 3D array:\n        ```python\n        &gt;&gt;&gt; rgb_array = np.random.randint(0, 255, size=(3, 10, 10))\n        &gt;&gt;&gt; rgb_glyph = ArrayGlyph(rgb_array, rgb=[0, 1, 2], surface_reflectance=255)\n        &gt;&gt;&gt; fig, ax = rgb_glyph.plot()\n\n        ```\n        Initialization with custom extent:\n        ```python\n        &gt;&gt;&gt; array_glyph = ArrayGlyph(arr, extent=[0, 0, 10, 10])\n        &gt;&gt;&gt; fig, ax = array_glyph.plot()\n\n        ```\n        \"\"\"\n        self._default_options = DEFAULT_OPTIONS.copy()\n\n        for key, val in kwargs.items():\n            if key not in self.default_options.keys():\n                raise ValueError(\n                    f\"The given keyword argument:{key} is not correct, possible parameters are,\"\n                    f\" {DEFAULT_OPTIONS}\"\n                )\n            else:\n                self.default_options[key] = val\n        # first replace the no_data_value by nan\n        # convert the array to float32 to be able to replace the no data value with nan\n        if exclude_value is not np.nan:\n            if len(exclude_value) &gt; 1:\n                mask = np.logical_or(\n                    np.isclose(array, exclude_value[0], rtol=0.001),\n                    np.isclose(array, exclude_value[1], rtol=0.001),\n                )\n            else:\n                mask = np.isclose(array, exclude_value[0], rtol=0.0000001)\n            array = ma.array(array, mask=mask, dtype=array.dtype)\n        else:\n            array = ma.array(array)\n\n        # convert the extent from [xmin, ymin, xmax, ymax] to [xmin, xmax, ymin, ymax] as required by matplotlib.\n        if extent is not None:\n            extent = [extent[0], extent[2], extent[1], extent[3]]\n        self.extent = extent\n\n        if rgb is not None:\n            self.rgb = True\n            # prepare to plot rgb plot only if there are three arrays\n            if array.shape[0] &lt; 3:\n                raise ValueError(\n                    f\"To plot RGB plot the given array should have only 3 arrays, given array have \"\n                    f\"{array.shape[0]}\"\n                )\n            else:\n                array = self.prepare_array(\n                    array,\n                    rgb=rgb,\n                    surface_reflectance=surface_reflectance,\n                    cutoff=cutoff,\n                    percentile=percentile,\n                )\n        else:\n            self.rgb = False\n\n        self._exclude_value = exclude_value\n\n        self._vmax = (\n            np.nanmax(array) if kwargs.get(\"vmax\") is None else kwargs.get(\"vmax\")\n        )\n        self._vmin = (\n            np.nanmin(array) if kwargs.get(\"vmin\") is None else kwargs.get(\"vmin\")\n        )\n\n        self.arr = array\n        # get the tick spacing that has 10 ticks only\n        self.ticks_spacing = (self._vmax - self._vmin) / 10\n        shape = array.shape\n        if len(shape) == 3:\n            no_elem = array[0, :, :].count()\n        else:\n            no_elem = array.count()\n\n        self.no_elem = no_elem\n        if fig is None:\n            self.fig, self.ax = self.create_figure_axes()\n        else:\n            self.fig, self.ax = fig, ax\n\n    def prepare_array(\n        self,\n        array: np.ndarray,\n        rgb: List[int] = None,\n        surface_reflectance: int = None,\n        cutoff: List = None,\n        percentile: int = None,\n    ) -&gt; np.ndarray:\n        \"\"\"Prepare an array for RGB visualization.\n\n        This method processes a multi-band array to create an RGB image suitable for visualization.\n        It can normalize the data using either percentile-based scaling or surface reflectance values.\n\n        Parameters\n        ----------\n        array : np.ndarray\n            The input array containing multiple bands. For RGB visualization,\n            this should be a 3D array where the first dimension represents the bands.\n        rgb : List[int], optional\n            The indices of the red, green, and blue bands in the given array, by default None.\n            If None, assumes the order is [3, 2, 1] (common for Sentinel-2 data).\n        surface_reflectance : int, optional\n            Surface reflectance value for normalizing satellite data, by default None.\n            Typically 10000 for Sentinel-2 data or 255 for 8-bit imagery.\n            Used to scale values to the range [0, 1].\n        cutoff : List, optional\n            Clip the range of pixel values for each band, by default None.\n            Takes only pixel values from 0 to the value of the cutoff and scales them back to between 0 and 1.\n            Should be a list with one value per band.\n        percentile : int, optional\n            The percentile value to be used for scaling the array values, by default None.\n            Used to enhance contrast by stretching the histogram.\n            If provided, this takes precedence over surface_reflectance.\n\n        Returns\n        -------\n        np.ndarray\n            The prepared array with shape (height, width, 3) suitable for RGB visualization.\n            Values are normalized to the range [0, 1].\n\n        Raises\n        ------\n        ValueError\n            If the array shape is incompatible with the provided RGB indices.\n\n        Examples\n        --------\n        Prepare an array using percentile-based scaling:\n        ```python\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from cleopatra.array_glyph import ArrayGlyph\n        &gt;&gt;&gt; # Create a 3-band array (e.g., satellite image)\n        &gt;&gt;&gt; bands = np.random.randint(0, 10000, size=(3, 100, 100))\n        &gt;&gt;&gt; glyph = ArrayGlyph(np.zeros((1, 1)))  # Dummy initialization\n        &gt;&gt;&gt; rgb_array = glyph.prepare_array(bands, rgb=[0, 1, 2], percentile=2)\n        &gt;&gt;&gt; rgb_array.shape\n        (100, 100, 3)\n        &gt;&gt;&gt; np.all((0 &lt;= rgb_array) &amp; (rgb_array &lt;= 1))\n        True\n\n        ```\n        Prepare an array using surface reflectance normalization:\n        ```python\n        &gt;&gt;&gt; rgb_array = glyph.prepare_array(bands, rgb=[0, 1, 2], surface_reflectance=10000)\n        &gt;&gt;&gt; rgb_array.shape\n        (100, 100, 3)\n        &gt;&gt;&gt; np.all((0 &lt;= rgb_array) &amp; (rgb_array &lt;= 1))\n        True\n\n        ```\n        Prepare an array with cutoff values:\n        ```python\n        &gt;&gt;&gt; rgb_array = glyph.prepare_array(\n        ...     bands, rgb=[0, 1, 2], surface_reflectance=10000, cutoff=[5000, 5000, 5000]\n        ... )\n        &gt;&gt;&gt; rgb_array.shape\n        (100, 100, 3)\n        &gt;&gt;&gt; np.all((0 &lt;= rgb_array) &amp; (rgb_array &lt;= 1))\n        True\n\n        ```\n        \"\"\"\n        # take the rgb arrays and reorder them to have the red-green-blue, if the order is not given, assume the\n        # order as sentinel data. [3, 2, 1]\n        array = array[rgb].transpose(1, 2, 0)\n\n        if percentile is not None:\n            array = self.scale_percentile(array, percentile=percentile)\n        elif surface_reflectance is not None:\n            array = self._prepare_sentinel_rgb(\n                array,\n                rgb=rgb,\n                surface_reflectance=surface_reflectance,\n                cutoff=cutoff,\n            )\n        return array\n\n    def _prepare_sentinel_rgb(\n        self,\n        array: np.ndarray,\n        rgb: List[int] = None,\n        surface_reflectance: int = 10000,\n        cutoff: List = None,\n    ) -&gt; np.ndarray:\n        \"\"\"Prepare Sentinel satellite data for RGB visualization.\n\n        This method specifically handles Sentinel satellite imagery by normalizing the data\n        using the provided surface reflectance value and optional cutoff values.\n\n        Parameters\n        ----------\n        array : np.ndarray\n            The input array with shape (height, width, 3) containing RGB bands.\n            This array should already be transposed from the original band-first format.\n        rgb : List[int], optional\n            The indices of the red, green, and blue bands in the original array, by default None.\n            Used only for cutoff application.\n        surface_reflectance : int, optional\n            Surface reflectance value for normalizing satellite data, by default 10000.\n            Sentinel-2 data typically uses 10000 as the maximum reflectance value.\n            Used to scale values to the range [0, 1].\n        cutoff : List, optional\n            Clip the range of pixel values for each band, by default None.\n            Takes only pixel values from 0 to the value of the cutoff and scales them back to between 0 and 1.\n            Should be a list with one value per band.\n\n        Returns\n        -------\n        np.ndarray\n            The prepared array with shape (height, width, 3) suitable for RGB visualization.\n            Values are normalized to the range [0, 1].\n\n        Examples\n        --------\n        Prepare Sentinel-2 data with default surface reflectance:\n        ```python\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from cleopatra.array_glyph import ArrayGlyph\n        &gt;&gt;&gt; # Create a simulated Sentinel-2 RGB array\n        &gt;&gt;&gt; rgb_data = np.random.randint(0, 10000, size=(100, 100, 3))\n        &gt;&gt;&gt; glyph = ArrayGlyph(np.zeros((1, 1)))  # Dummy initialization\n        &gt;&gt;&gt; normalized = glyph._prepare_sentinel_rgb(rgb_data)\n        &gt;&gt;&gt; np.all((0 &lt;= normalized) &amp; (normalized &lt;= 1))\n        True\n\n        ```\n        Prepare Sentinel-2 data with custom cutoff values:\n        ```python\n        &gt;&gt;&gt; cutoffs = [8000, 7000, 9000]\n        &gt;&gt;&gt; normalized = glyph._prepare_sentinel_rgb(rgb_data, rgb=[0, 1, 2], cutoff=cutoffs)\n        &gt;&gt;&gt; np.all((0 &lt;= normalized) &amp; (normalized &lt;= 1))\n        True\n\n        ```\n        \"\"\"\n        array = np.clip(array / surface_reflectance, 0, 1)\n        if cutoff is not None:\n            array[0] = np.clip(rgb[0], 0, cutoff[0]) / cutoff[0]\n            array[1] = np.clip(rgb[1], 0, cutoff[1]) / cutoff[1]\n            array[2] = np.clip(rgb[2], 0, cutoff[2]) / cutoff[2]\n\n        return array\n\n    @staticmethod\n    def scale_percentile(arr: np.ndarray, percentile: int = 1) -&gt; np.ndarray:\n        \"\"\"Scale an array using percentile-based contrast stretching.\n\n        This method enhances the contrast of an image by stretching the histogram\n        based on percentile values. It calculates the lower and upper percentile values\n        for each band and normalizes the data to the range [0, 1].\n\n        Parameters\n        ----------\n        arr : np.ndarray\n            The array to be scaled, with shape (height, width, bands).\n            Typically an RGB image with 3 bands.\n        percentile : int, optional\n            The percentile value to be used for scaling, by default 1.\n            This value determines how much of the histogram tails to exclude.\n            Higher values result in more contrast stretching.\n            Typical values range from 1 to 5.\n\n        Returns\n        -------\n        np.ndarray\n            The scaled array, normalized between 0 and 1, with the same shape as input.\n            Data type is float32.\n\n        Notes\n        -----\n        The method works by:\n        1. Computing the lower percentile value for each band\n        2. Computing the upper percentile value (100 - percentile) for each band\n        3. Normalizing each band using these percentile values\n        4. Clipping values to the range [0, 1]\n\n        This is particularly useful for visualizing satellite imagery with high dynamic range.\n\n        Examples\n        --------\n        Scale a single-band array:\n        ```python\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from cleopatra.array_glyph import ArrayGlyph\n        &gt;&gt;&gt; # Create a test array with values between 0 and 10000\n        &gt;&gt;&gt; test_array = np.random.randint(0, 10000, size=(100, 100, 1))\n        &gt;&gt;&gt; scaled = ArrayGlyph.scale_percentile(test_array, percentile=2)\n        &gt;&gt;&gt; scaled.shape\n        (100, 100, 1)\n        &gt;&gt;&gt; np.all((0 &lt;= scaled) &amp; (scaled &lt;= 1))\n        np.True_\n\n        ```\n        Scale an RGB array:\n        ```python\n        &gt;&gt;&gt; rgb_array = np.random.randint(0, 10000, size=(100, 100, 3))\n        &gt;&gt;&gt; scaled = ArrayGlyph.scale_percentile(rgb_array, percentile=2)\n        &gt;&gt;&gt; scaled.shape\n        (100, 100, 3)\n        &gt;&gt;&gt; np.all((0 &lt;= scaled) &amp; (scaled &lt;= 1))\n        np.True_\n\n        ```\n        Using different percentile values affects contrast:\n        ```python\n        &gt;&gt;&gt; low_contrast = ArrayGlyph.scale_percentile(rgb_array, percentile=1)\n        &gt;&gt;&gt; high_contrast = ArrayGlyph.scale_percentile(rgb_array, percentile=5)\n        &gt;&gt;&gt; # Higher percentile typically results in higher contrast\n\n        ```\n        \"\"\"\n        rows, columns, bands = arr.shape\n        # flatten image.\n        arr = np.reshape(arr, [rows * columns, bands]).astype(np.float32)\n        # lower percentile values (one value for each band).\n        lower_percent = np.percentile(arr, percentile, axis=0)\n        # 98 percentile values.\n        upper_percent = np.percentile(arr, 100 - percentile, axis=0) - lower_percent\n        # normalize the 3 bands using the percentile values for each band.\n        arr = (arr - lower_percent[None, :]) / upper_percent[None, :]\n        arr = np.reshape(arr, [rows, columns, bands])\n        # discard outliers.\n        arr = arr.clip(0, 1)\n\n        return arr\n\n    def __str__(self):\n        \"\"\"String representation of the Array object.\"\"\"\n        message = f\"\"\"\n                    Min: {self.vmin}\n                    Max: {self.vmax}\n                    Exclude values: {self.exclude_value}\n                    RGB: {self.rgb}\n                \"\"\"\n        return message\n\n    @property\n    def vmin(self):\n        \"\"\"min value in the array\"\"\"\n        return self._vmin\n\n    @property\n    def vmax(self):\n        \"\"\"max value in the array\"\"\"\n        return self._vmax\n\n    @property\n    def exclude_value(self):\n        \"\"\"exclude_value\"\"\"\n        return self._exclude_value\n\n    @exclude_value.setter\n    def exclude_value(self, value):\n        self._exclude_value = value\n\n    @property\n    def default_options(self):\n        \"\"\"Default plot options\"\"\"\n        return self._default_options\n\n    @property\n    def anim(self):\n        \"\"\"Animation function\"\"\"\n        if hasattr(self, \"_anim\"):\n            val = self._anim\n        else:\n            raise ValueError(\n                \"Please first use the function animate to create the animation object\"\n            )\n        return val\n\n    def create_figure_axes(self) -&gt; Tuple[Figure, Axes]:\n        \"\"\"Create the figure and the axes.\n\n        Returns\n        -------\n        fig: matplotlib.figure.Figure\n            the created figure.\n        ax: matplotlib.axes.Axes\n            the created axes.\n        \"\"\"\n        plt.ioff()  # to prevent the empty figure from being displayed\n        fig, ax = plt.subplots(figsize=self.default_options[\"figsize\"])\n\n        return fig, ax\n\n    def get_ticks(self) -&gt; np.ndarray:\n        \"\"\"get a list of ticks for the color bar\"\"\"\n        ticks_spacing = self.default_options[\"ticks_spacing\"]\n        vmax = self.default_options[\"vmax\"]\n        vmin = self.default_options[\"vmin\"]\n        remainder = np.round(math.remainder(vmax, ticks_spacing), 3)\n        # np.mod(vmax, ticks_spacing) gives float point error, so we use the round function.\n        if remainder == 0:\n            ticks = np.arange(vmin, vmax + ticks_spacing, ticks_spacing)\n        else:\n            try:\n                ticks = np.arange(vmin, vmax + ticks_spacing, ticks_spacing)\n            except ValueError:\n                raise ValueError(\n                    \"The number of ticks exceeded the max allowed size, possible errors\"\n                    f\" is the value of the NodataValue you entered-{self.exclude_value}\"\n                )\n            ticks = np.append(\n                ticks,\n                [int(vmax / ticks_spacing) * ticks_spacing + ticks_spacing],\n            )\n        return ticks\n\n    def _plot_im_get_cbar_kw(\n        self, ax: Axes, arr: np.ndarray, ticks: np.ndarray\n    ) -&gt; Tuple[AxesImage, Dict[str, str]]:\n        \"\"\"Plot a single image and get color bar keyword arguments.\n\n        Parameters\n        ----------\n        ax: [axes]\n            matplotlib figure axes.\n        arr: [array]\n            numpy array.\n        ticks: [list]\n            color bar ticks.\n\n        Returns\n        -------\n        im: AxesImage\n            image axes.\n        cbar: Dict[str,str]\n            color bar keyword arguments.\n        \"\"\"\n        color_scale = self.default_options[\"color_scale\"]\n        cmap = self.default_options[\"cmap\"]\n        # get the vmin and vmax from the tick instead of the default values.\n        vmin: float = ticks[0]  # self.default_options[\"vmin\"]\n        vmax: float = ticks[-1]  # self.default_options[\"vmax\"]\n\n        if color_scale.lower() == \"linear\":\n            im = ax.matshow(arr, cmap=cmap, vmin=vmin, vmax=vmax, extent=self.extent)\n            cbar_kw = {\"ticks\": ticks}\n        elif color_scale.lower() == \"power\":\n            im = ax.matshow(\n                arr,\n                cmap=cmap,\n                norm=colors.PowerNorm(\n                    gamma=self.default_options[\"gamma\"], vmin=vmin, vmax=vmax\n                ),\n                extent=self.extent,\n            )\n            cbar_kw = {\"ticks\": ticks}\n        elif color_scale.lower() == \"sym-lognorm\":\n            im = ax.matshow(\n                arr,\n                cmap=cmap,\n                norm=colors.SymLogNorm(\n                    linthresh=self.default_options[\"line_threshold\"],\n                    linscale=self.default_options[\"line_scale\"],\n                    base=np.e,\n                    vmin=vmin,\n                    vmax=vmax,\n                ),\n                extent=self.extent,\n            )\n            formatter = LogFormatter(10, labelOnlyBase=False)\n            cbar_kw = {\"ticks\": ticks, \"format\": formatter}\n        elif color_scale.lower() == \"boundary-norm\":\n            if not self.default_options[\"bounds\"]:\n                bounds = ticks\n                cbar_kw = {\"ticks\": ticks}\n            else:\n                bounds = self.default_options[\"bounds\"]\n                cbar_kw = {\"ticks\": self.default_options[\"bounds\"]}\n            norm = colors.BoundaryNorm(boundaries=bounds, ncolors=256)\n            im = ax.matshow(arr, cmap=cmap, norm=norm, extent=self.extent)\n        elif color_scale.lower() == \"midpoint\":\n            arr = arr.filled(np.nan)\n            im = ax.matshow(\n                arr,\n                cmap=cmap,\n                norm=MidpointNormalize(\n                    midpoint=self.default_options[\"midpoint\"],\n                    vmin=vmin,\n                    vmax=vmax,\n                ),\n                extent=self.extent,\n            )\n            cbar_kw = {\"ticks\": ticks}\n        else:\n            raise ValueError(\n                f\"Invalid color scale option: {color_scale}. Use 'linear', 'power', 'power-norm',\"\n                \"'sym-lognorm', 'boundary-norm'\"\n            )\n\n        return im, cbar_kw\n\n    @staticmethod\n    def _plot_text(\n        ax: Axes, arr: np.ndarray, indices, default_options_dict: dict\n    ) -&gt; list:\n        \"\"\"plot values as a text in each cell.\n\n        Parameters\n        ----------\n        ax:[matplotlib ax]\n            matplotlib axes\n        indices: [array]\n            array with columns, (row, col)\n        default_options_dict: Dict\n            default options dictionary after updating the options.\n\n        Returns\n        -------\n        list:\n            list of the text object\n        \"\"\"\n        # https://github.com/Serapieum-of-alex/cleopatra/issues/75\n        # add text for the cell values\n        add_text = lambda elem: ax.text(\n            elem[1],\n            elem[0],\n            np.round(arr[elem[0], elem[1]], 2),\n            ha=\"center\",\n            va=\"center\",\n            color=\"w\",\n            fontsize=default_options_dict[\"num_size\"],\n        )\n        return list(map(add_text, indices))\n\n    @staticmethod\n    def _plot_point_values(ax, point_table: np.ndarray, pid_color, pid_size):\n        write_points = lambda x: ax.text(\n            x[2],\n            x[1],\n            x[0],\n            ha=\"center\",\n            va=\"center\",\n            color=pid_color,\n            fontsize=pid_size,\n        )\n        return list(map(write_points, point_table))\n\n    def create_color_bar(self, ax: Axes, im: AxesImage, cbar_kw: dict) -&gt; Colorbar:\n        \"\"\"Create Color bar.\n\n        Parameters\n        ----------\n        ax: Axes\n            matplotlib axes.\n        im: AxesImage\n            Image axes.\n        cbar_kw: dict\n            color bar keyword arguments.\n\n        Returns\n        -------\n        Colorbar:\n            colorbar object.\n        \"\"\"\n        # im or cax is the last image added to the axes\n        # im = ax.images[-1]\n        cbar = ax.figure.colorbar(\n            im,\n            ax=ax,\n            shrink=self.default_options[\"cbar_length\"],\n            orientation=self.default_options[\"cbar_orientation\"],\n            **cbar_kw,\n        )\n        # cbar.ax.set_ylabel(\n        #     self.default_options[\"cbar_label\"],\n        #     rotation=self.default_options[\"cbar_label_rotation\"],\n        #     va=self.default_options[\"cbar_label_location\"],\n        #     fontsize=self.default_options[\"cbar_label_size\"],\n        # )\n        cbar.ax.tick_params(labelsize=10)\n        cbar.set_label(\n            self.default_options[\"cbar_label\"],\n            fontsize=self.default_options[\"cbar_label_size\"],\n            loc=self.default_options[\"cbar_label_location\"],\n        )\n\n        return cbar\n\n    def plot(\n        self,\n        points: np.ndarray = None,\n        point_color: str = \"red\",\n        point_size: Union[int, float] = 100,\n        pid_color=\"blue\",\n        pid_size: Union[int, float] = 10,\n        **kwargs,\n    ) -&gt; Tuple[Figure, Axes]:\n        \"\"\"Plot the array with customizable visualization options.\n\n        This method creates a visualization of the array with various customization options\n        including color scales, color bars, cell value display, and point annotations.\n        It supports both regular arrays and RGB arrays.\n\n        Parameters\n        ----------\n        points : np.ndarray, optional\n            Points to display on the array, by default None.\n            Should be a 3-column array where:\n            - First column: values to display for each point\n            - Second column: row indices of the points in the array\n            - Third column: column indices of the points in the array\n        point_color : str, optional\n            Color of the points, by default \"red\".\n            Any valid matplotlib color string.\n        point_size : Union[int, float], optional\n            Size of the points, by default 100.\n            Controls the marker size.\n        pid_color : str, optional\n            Color of the point value annotations, by default \"blue\".\n            Any valid matplotlib color string.\n        pid_size : Union[int, float], optional\n            Size of the point value annotations, by default 10.\n            Controls the font size of the annotations.\n        **kwargs : dict\n            Additional keyword arguments for customizing the plot.\n\n            Plot appearance:\n            ---------------\n            title : str, optional\n                Title of the plot, by default 'Array Plot'.\n            title_size : int, optional\n                Title font size, by default 15.\n            cmap : str, optional\n                Colormap name, by default 'coolwarm_r'.\n            vmin : float, optional\n                Minimum value for color scaling, by default min(array).\n            vmax : float, optional\n                Maximum value for color scaling, by default max(array).\n\n            Color bar options:\n            ----------------\n            cbar_orientation : str, optional\n                Orientation of the color bar, by default 'vertical'.\n                Can be 'horizontal' or 'vertical'.\n            cbar_label_rotation : float, optional\n                Rotation angle of the color bar label, by default -90.\n            cbar_label_location : str, optional\n                Location of the color bar label, by default 'bottom'.\n                Options: 'top', 'bottom', 'center', 'baseline', 'center_baseline'.\n            cbar_length : float, optional\n                Ratio to control the height/width of the color bar, by default 0.75.\n            ticks_spacing : int, optional\n                Spacing between ticks on the color bar, by default 2.\n            cbar_label_size : int, optional\n                Font size of the color bar label, by default 12.\n            cbar_label : str, optional\n                Label text for the color bar, by default 'Value'.\n\n            Color scale options:\n            ------------------\n            color_scale : str, optional\n                Type of color scaling to use, by default 'linear'.\n                Options:\n                - 'linear': Linear scale\n                - 'power': Power-law normalization\n                - 'sym-lognorm': Symmetrical logarithmic scale\n                - 'boundary-norm': Discrete intervals based on boundaries\n                - 'midpoint': Scale split at a specified midpoint\n            gamma : float, optional\n                Exponent for 'power' color scale, by default 0.5.\n                Values &lt; 1 emphasize lower values, values &gt; 1 emphasize higher values.\n            line_threshold : float, optional\n                Threshold for 'sym-lognorm' color scale, by default 0.0001.\n            line_scale : float, optional\n                Scale factor for 'sym-lognorm' color scale, by default 0.001.\n            bounds : List, optional\n                Boundaries for 'boundary-norm' color scale, by default None.\n                Defines the discrete intervals for color mapping.\n            midpoint : float, optional\n                Midpoint value for 'midpoint' color scale, by default 0.\n\n            Cell value display options:\n            -------------------------\n            display_cell_value : bool, optional\n                Whether to display the values of cells as text, by default False.\n            num_size : int, optional\n                Font size of the cell value text, by default 8.\n            background_color_threshold : float, optional\n                Threshold for cell value text color, by default None.\n                If cell value &gt; threshold, text is black; otherwise, text is white.\n                If None, uses max(array)/2 as the threshold.\n\n        Returns\n        -------\n        Tuple[matplotlib.figure.Figure, matplotlib.axes.Axes]\n            A tuple containing:\n            - fig: The matplotlib Figure object\n            - ax: The matplotlib Axes object\n\n        Raises\n        ------\n        ValueError\n            If an invalid keyword argument is provided.\n\n        Examples\n        --------\n        Basic array plot:\n        ```python\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from cleopatra.array_glyph import ArrayGlyph\n        &gt;&gt;&gt; arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Customized Plot\", title_size=18)\n        &gt;&gt;&gt; fig, ax = array.plot()\n\n        ```\n        Color bar customization:\n        ```python\n        &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Customized color bar\", title_size=18)\n        &gt;&gt;&gt; fig, ax = array.plot(\n        ...     cbar_orientation=\"horizontal\",\n        ...     cbar_label_rotation=-90,\n        ...     cbar_label_location=\"center\",\n        ...     cbar_length=0.7,\n        ...     cbar_label_size=12,\n        ...     cbar_label=\"Discharge m3/s\",\n        ...     ticks_spacing=5,\n        ...     color_scale=\"linear\",\n        ...     cmap=\"coolwarm_r\",\n        ... )\n\n        ```\n        Display cell values:\n        ```python\n        &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Display array values\", title_size=18)\n        &gt;&gt;&gt; fig, ax = array.plot(\n        ...     display_cell_value=True,\n        ...     num_size=12\n        ... )\n\n        ```\n        Plot points at specific locations:\n        ```python\n        &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Display Points\", title_size=14)\n        &gt;&gt;&gt; points = np.array([[1, 0, 0], [2, 1, 1], [3, 2, 2]])\n        &gt;&gt;&gt; fig, ax = array.plot(\n        ...     points=points,\n        ...     point_color=\"black\",\n        ...     point_size=100,\n        ...     pid_color=\"orange\",\n        ...     pid_size=30,\n        ... )\n\n        ```\n        Power scale with different gamma values:\n        ```python\n        &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Power scale\", title_size=18)\n        &gt;&gt;&gt; fig, ax = array.plot(\n        ...     cbar_label=\"Discharge m3/s\",\n        ...     color_scale=\"power\",\n        ...     gamma=0.5,  # Default value\n        ...     cmap=\"coolwarm_r\",\n        ... )\n\n        &gt;&gt;&gt; # Higher gamma (0.8) emphasizes higher values less\n        &gt;&gt;&gt; fig, ax = array.plot(\n        ...     color_scale=\"power\",\n        ...     gamma=0.8,\n        ...     cmap=\"coolwarm_r\",\n        ... )\n\n        &gt;&gt;&gt; # Lower gamma (0.1) emphasizes higher values more\n        &gt;&gt;&gt; fig, ax = array.plot(\n        ...     color_scale=\"power\",\n        ...     gamma=0.1,\n        ...     cmap=\"coolwarm_r\",\n        ... )\n\n        ```\n        Logarithmic scale:\n        ```python\n        &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Logarithmic scale\", title_size=18)\n        &gt;&gt;&gt; fig, ax = array.plot(\n        ...     cbar_label=\"Discharge m3/s\",\n        ...     color_scale=\"sym-lognorm\",\n        ...     cmap=\"coolwarm_r\",\n        ... )\n\n        &gt;&gt;&gt; # Custom logarithmic scale parameters\n        &gt;&gt;&gt; fig, ax = array.plot(\n        ...     color_scale=\"sym-lognorm\",\n        ...     line_threshold=0.015,\n        ...     line_scale=0.1,\n        ...     cmap=\"coolwarm_r\",\n        ... )\n\n        ```\n        Boundary scale with custom boundaries:\n        ```python\n        &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Boundary scale\", title_size=18)\n        &gt;&gt;&gt; fig, ax = array.plot(\n        ...     color_scale=\"boundary-norm\",\n        ...     cmap=\"coolwarm_r\",\n        ... )\n\n        &gt;&gt;&gt; # Custom boundaries\n        &gt;&gt;&gt; bounds = [0, 5, 10]\n        &gt;&gt;&gt; fig, ax = array.plot(\n        ...     color_scale=\"boundary-norm\",\n        ...     bounds=bounds,\n        ...     cmap=\"coolwarm_r\",\n        ... )\n\n        ```\n        Midpoint scale:\n        ```python\n        &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Midpoint scale\", title_size=18)\n        &gt;&gt;&gt; fig, ax = array.plot(\n        ...     color_scale=\"midpoint\",\n        ...     midpoint=2,\n        ...     cmap=\"coolwarm_r\",\n        ... )\n\n        ```\n        \"\"\"\n        for key, val in kwargs.items():\n            if key not in self.default_options.keys():\n                raise ValueError(\n                    f\"The given keyword argument:{key} is not correct, possible parameters are,\"\n                    f\" {DEFAULT_OPTIONS}\"\n                )\n            else:\n                self.default_options[key] = val\n\n        arr = self.arr\n        fig, ax = self.fig, self.ax\n\n        if self.rgb:\n            ax.imshow(arr, extent=self.extent)\n        else:\n            # if user did not input ticks spacing use the calculated one.\n            if \"ticks_spacing\" in kwargs.keys():\n                self.default_options[\"ticks_spacing\"] = kwargs[\"ticks_spacing\"]\n            else:\n                self.default_options[\"ticks_spacing\"] = self.ticks_spacing\n\n            if \"vmin\" in kwargs.keys():\n                self.default_options[\"vmin\"] = kwargs[\"vmin\"]\n            else:\n                self.default_options[\"vmin\"] = self.vmin\n\n            if \"vmax\" in kwargs.keys():\n                self.default_options[\"vmax\"] = kwargs[\"vmax\"]\n            else:\n                self.default_options[\"vmax\"] = self.vmax\n\n            # creating the ticks/bounds\n            ticks = self.get_ticks()\n            im, cbar_kw = self._plot_im_get_cbar_kw(ax, arr, ticks)\n\n            # Create colorbar\n            self.create_color_bar(ax, im, cbar_kw)\n\n        ax.set_title(\n            self.default_options[\"title\"], fontsize=self.default_options[\"title_size\"]\n        )\n\n        if self.extent is None:\n            ax.set_xticklabels([])\n            ax.set_yticklabels([])\n            ax.set_xticks([])\n            ax.set_yticks([])\n\n        optional_display = {}\n        if self.default_options[\"display_cell_value\"]:\n            indices = get_indices2(arr, [np.nan])\n            optional_display[\"cell_text_value\"] = self._plot_text(\n                ax, arr, indices, self.default_options\n            )\n\n        if points is not None:\n            row = points[:, 1]\n            col = points[:, 2]\n            optional_display[\"points_scatter\"] = ax.scatter(\n                col, row, color=point_color, s=point_size\n            )\n            optional_display[\"points_id\"] = self._plot_point_values(\n                ax, points, pid_color, pid_size\n            )\n\n        # # Normalize the threshold to the image color range.\n        # if self.default_options[\"background_color_threshold\"] is not None:\n        #     im.norm(self.default_options[\"background_color_threshold\"])\n        # else:\n        #     im.norm(self.vmax) / 2.0\n        plt.show()\n        return fig, ax\n\n    def animate(\n        self,\n        time: List[Any],\n        points: np.ndarray = None,\n        text_colors=(\"white\", \"black\"),\n        interval=200,\n        text_loc: list[Any, Any] = None,\n        point_color=\"red\",\n        point_size=100,\n        pid_color=\"blue\",\n        pid_size=10,\n        **kwargs,\n    ):\n        \"\"\"Create an animation from a 3D array.\n\n        This method creates an animation by iterating through the first dimension of a 3D array.\n        Each slice of the array becomes a frame in the animation, with optional time labels,\n        point annotations, and cell value displays.\n\n        Parameters\n        ----------\n        time : List[Any]\n            A list containing labels for each frame in the animation.\n            These could be timestamps, frame numbers, or any other identifiers.\n            The length of this list should match the first dimension of the array.\n        points : np.ndarray, optional\n            Points to display on the array, by default None.\n            Should be a 3-column array where:\n            - First column: values to display for each point\n            - Second column: row indices of the points in the array\n            - Third column: column indices of the points in the array\n        text_colors : Tuple[str, str], optional\n            Two colors to be used for cell value text, by default (\"white\", \"black\").\n            The first color is used when the cell value is below the background_color_threshold,\n            and the second color is used when the cell value is above the threshold.\n        interval : int, optional\n            Delay between frames in milliseconds, by default 200.\n            Controls the speed of the animation (smaller values = faster animation).\n        text_loc : list[Any, Any], optional\n            Location of the time label text as [x, y] coordinates, by default None.\n            If None, defaults to [0.1, 0.2].\n        point_color : str, optional\n            Color of the points, by default \"red\".\n            Any valid matplotlib color string.\n        point_size : int, optional\n            Size of the points, by default 100.\n            Controls the marker size.\n        pid_color : str, optional\n            Color of the point value annotations, by default \"blue\".\n            Any valid matplotlib color string.\n        pid_size : int, optional\n            Size of the point value annotations, by default 10.\n            Controls the font size of the annotations.\n        **kwargs : dict\n            Additional keyword arguments for customizing the animation.\n\n            Plot appearance:\n            ---------------\n            title : str, optional\n                Title of the plot, by default 'Array Plot'.\n            title_size : int, optional\n                Title font size, by default 15.\n            cmap : str, optional\n                Colormap name, by default 'coolwarm_r'.\n            vmin : float, optional\n                Minimum value for color scaling, by default min(array).\n            vmax : float, optional\n                Maximum value for color scaling, by default max(array).\n\n            Color bar options:\n            ----------------\n            cbar_orientation : str, optional\n                Orientation of the color bar, by default 'vertical'.\n                Can be 'horizontal' or 'vertical'.\n            cbar_label_rotation : float, optional\n                Rotation angle of the color bar label, by default -90.\n            cbar_label_location : str, optional\n                Location of the color bar label, by default 'bottom'.\n                Options: 'top', 'bottom', 'center', 'baseline', 'center_baseline'.\n            cbar_length : float, optional\n                Ratio to control the height/width of the color bar, by default 0.75.\n            ticks_spacing : int, optional\n                Spacing between ticks on the color bar, by default 2.\n            cbar_label_size : int, optional\n                Font size of the color bar label, by default 12.\n            cbar_label : str, optional\n                Label text for the color bar, by default 'Value'.\n\n            Color scale options:\n            ------------------\n            color_scale : str, optional\n                Type of color scaling to use, by default 'linear'.\n                Options:\n                - 'linear': Linear scale\n                - 'power': Power-law normalization\n                - 'sym-lognorm': Symmetrical logarithmic scale\n                - 'boundary-norm': Discrete intervals based on boundaries\n                - 'midpoint': Scale split at a specified midpoint\n            gamma : float, optional\n                Exponent for 'power' color scale, by default 0.5.\n                Values &lt; 1 emphasize lower values, values &gt; 1 emphasize higher values.\n            line_threshold : float, optional\n                Threshold for 'sym-lognorm' color scale, by default 0.0001.\n            line_scale : float, optional\n                Scale factor for 'sym-lognorm' color scale, by default 0.001.\n            bounds : List, optional\n                Boundaries for 'boundary-norm' color scale, by default None.\n                Defines the discrete intervals for color mapping.\n            midpoint : float, optional\n                Midpoint value for 'midpoint' color scale, by default 0.\n\n            Cell value display options:\n            -------------------------\n            display_cell_value : bool, optional\n                Whether to display the values of cells as text, by default False.\n            num_size : int, optional\n                Font size of the cell value text, by default 8.\n            background_color_threshold : float, optional\n                Threshold for cell value text color, by default None.\n                If cell value &gt; threshold, text is black; otherwise, text is white.\n                If None, uses max(array)/2 as the threshold.\n\n        Returns\n        -------\n        matplotlib.animation.FuncAnimation\n            The animation object that can be displayed in a notebook or saved to a file.\n\n        Raises\n        ------\n        ValueError\n            If an invalid keyword argument is provided.\n        ValueError\n            If the length of the time list doesn't match the first dimension of the array.\n\n        Notes\n        -----\n        The animation is created by iterating through the first dimension of the array.\n        For example, if the array has shape (10, 20, 30), the animation will have 10 frames,\n        each showing a 20x30 slice of the array.\n\n        To display the animation in a Jupyter notebook, you may need to use:\n        ```python\n        from IPython.display import HTML\n        HTML(anim_obj.to_jshtml())\n        ```\n\n        To save the animation to a file, use the `save_animation` method after creating\n        the animation.\n\n        Examples\n        --------\n        Basic animation from a 3D array:\n        ```python\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from cleopatra.array_glyph import ArrayGlyph\n        &gt;&gt;&gt; # Create a 3D array with 5 frames, each 10x10\n        &gt;&gt;&gt; arr = np.random.randint(1, 10, size=(5, 10, 10))\n        &gt;&gt;&gt; # Create labels for each frame\n        &gt;&gt;&gt; frame_labels = [\"Frame 1\", \"Frame 2\", \"Frame 3\", \"Frame 4\", \"Frame 5\"]\n        &gt;&gt;&gt; # Create the ArrayGlyph object\n        &gt;&gt;&gt; animated_array = ArrayGlyph(arr, figsize=(8, 8), title=\"Animated Array\")\n        &gt;&gt;&gt; # Create the animation\n        &gt;&gt;&gt; anim_obj = animated_array.animate(frame_labels)\n\n        ```\n        Animation with custom interval (speed):\n        ```python\n        &gt;&gt;&gt; # Slower animation (500ms between frames)\n        &gt;&gt;&gt; anim_obj = animated_array.animate(frame_labels, interval=500)\n        &gt;&gt;&gt; # Faster animation (100ms between frames)\n        &gt;&gt;&gt; anim_obj = animated_array.animate(frame_labels, interval=100)\n\n        ```\n        Animation with points:\n        ```python\n        &gt;&gt;&gt; # Create points to display on the animation\n        &gt;&gt;&gt; points = np.array([[1, 2, 3], [2, 5, 5], [3, 8, 8]])\n        &gt;&gt;&gt; anim_obj = animated_array.animate(\n        ...     frame_labels,\n        ...     points=points,\n        ...     point_color=\"black\",\n        ...     point_size=150,\n        ...     pid_color=\"white\",\n        ...     pid_size=12\n        ... )\n\n        ```\n        Animation with cell values displayed:\n        ```python\n        &gt;&gt;&gt; anim_obj = animated_array.animate(\n        ...     frame_labels,\n        ...     display_cell_value=True,\n        ...     num_size=10,\n        ...     text_colors=(\"yellow\", \"blue\")\n        ... )\n\n        ```\n        Saving the animation to a file:\n        ```python\n        &gt;&gt;&gt; # Create the animation first\n        &gt;&gt;&gt; anim_obj = animated_array.animate(frame_labels)\n        &gt;&gt;&gt; # Then save it to a file\n        &gt;&gt;&gt; animated_array.save_animation(\"animation.gif\", fps=2)\n\n        ```\n        \"\"\"\n        if text_loc is None:\n            text_loc = [0.1, 0.2]\n\n        for key, val in kwargs.items():\n            if key not in self.default_options.keys():\n                raise ValueError(\n                    f\"The given keyword argument:{key} is not correct, possible parameters are,\"\n                    f\" {DEFAULT_OPTIONS}\"\n                )\n            else:\n                self.default_options[key] = val\n\n        # if user did not input ticks spacing use the calculated one.\n        if \"ticks_spacing\" in kwargs.keys():\n            self.default_options[\"ticks_spacing\"] = kwargs[\"ticks_spacing\"]\n        else:\n            self.default_options[\"ticks_spacing\"] = self.ticks_spacing\n\n        if \"vmin\" in kwargs.keys():\n            self.default_options[\"vmin\"] = kwargs[\"vmin\"]\n        else:\n            self.default_options[\"vmin\"] = self.vmin\n\n        if \"vmax\" in kwargs.keys():\n            self.default_options[\"vmax\"] = kwargs[\"vmax\"]\n        else:\n            self.default_options[\"vmax\"] = self.vmax\n\n        # if optional_display\n        precision = self.default_options[\"precision\"]\n        array = self.arr\n        fig, ax = self.fig, self.ax\n\n        ticks = self.get_ticks()\n        im, cbar_kw = self._plot_im_get_cbar_kw(ax, array[0, :, :], ticks)\n\n        # Create colorbar\n        cbar = ax.figure.colorbar(\n            im,\n            ax=ax,\n            shrink=self.default_options[\"cbar_length\"],\n            orientation=self.default_options[\"cbar_orientation\"],\n            **cbar_kw,\n        )\n        cbar.ax.set_ylabel(\n            self.default_options[\"cbar_label\"],\n            rotation=self.default_options[\"cbar_label_rotation\"],\n            va=self.default_options[\"cbar_label_location\"],\n            fontsize=self.default_options[\"cbar_label_size\"],\n        )\n        cbar.ax.tick_params(labelsize=10)\n\n        ax.set_title(\n            self.default_options[\"title\"], fontsize=self.default_options[\"title_size\"]\n        )\n        ax.set_xticklabels([])\n        ax.set_yticklabels([])\n\n        ax.set_xticks([])\n        ax.set_yticks([])\n\n        if self.default_options[\"display_cell_value\"]:\n            indices = get_indices2(array[0, :, :], [np.nan])\n            cell_text_value = self._plot_text(\n                ax, array[0, :, :], indices, self.default_options\n            )\n            indices = np.array(indices)\n\n        if points is not None:\n            row = points[:, 1]\n            col = points[:, 2]\n            points_scatter = ax.scatter(col, row, color=point_color, s=point_size)\n            points_id = self._plot_point_values(ax, points, pid_color, pid_size)\n\n        # Normalize the threshold to the image color range.\n        if self.default_options[\"background_color_threshold\"] is not None:\n            background_color_threshold = im.norm(\n                self.default_options[\"background_color_threshold\"]\n            )\n        else:\n            background_color_threshold = im.norm(np.nanmax(array)) / 2.0\n\n        day_text = ax.text(\n            text_loc[0],\n            text_loc[1],\n            \" \",\n            fontsize=self.default_options[\"cbar_label_size\"],\n        )\n\n        def init():\n            \"\"\"initialize the plot with the first array\"\"\"\n            im.set_data(array[0, :, :])\n            day_text.set_text(\"\")\n            output = [im, day_text]\n\n            if points is not None:\n                points_scatter.set_offsets(np.c_[col, row])\n                output.append(points_scatter)\n                update_points = lambda x: points_id[x].set_text(points[x, 0])\n                list(map(update_points, range(len(col))))\n\n                output += points_id\n\n            if self.default_options[\"display_cell_value\"]:\n                vals = array[0, indices[:, 0], indices[:, 1]]\n                update_cell_value = lambda x: cell_text_value[x].set_text(vals[x])\n                list(map(update_cell_value, range(self.no_elem)))\n                output += cell_text_value\n\n            return output\n\n        def animate_a(i):\n            \"\"\"plot for each element in the iterable.\"\"\"\n            im.set_data(array[i, :, :])\n            day_text.set_text(\"Date = \" + str(time[i])[0:10])\n            output = [im, day_text]\n\n            if points is not None:\n                points_scatter.set_offsets(np.c_[col, row])\n                output.append(points_scatter)\n\n                for x in range(len(col)):\n                    points_id[x].set_text(points[x, 0])\n\n                output += points_id\n\n            if self.default_options[\"display_cell_value\"]:\n                vals = array[i, indices[:, 0], indices[:, 1]]\n\n                def update_cell_value(x):\n                    \"\"\"Update cell value\"\"\"\n                    val = round(vals[x], precision)\n                    kw = {\n                        \"color\": text_colors[\n                            int(im.norm(vals[x]) &gt; background_color_threshold)\n                        ]\n                    }\n                    cell_text_value[x].update(kw)\n                    cell_text_value[x].set_text(val)\n\n                list(map(update_cell_value, range(self.no_elem)))\n\n                output += cell_text_value\n\n            return output\n\n        plt.tight_layout()\n\n        anim = FuncAnimation(\n            fig,\n            animate_a,\n            init_func=init,\n            frames=np.shape(array)[0],\n            interval=interval,\n            blit=True,\n        )\n        self._anim = anim\n        plt.show()\n        return anim\n\n    def save_animation(self, path: str, fps: int = 2):\n        \"\"\"Save the animation to a file.\n\n        This method saves the animation created by the `animate` method to a file.\n        The format of the output file is determined by the file extension in the path.\n\n        Parameters\n        ----------\n        path : str\n            The file path where the animation will be saved.\n            The file extension determines the output format.\n            Supported formats: gif, mov, avi, mp4.\n        fps : int, optional\n            Frames per second for the saved animation, by default 2.\n            Higher values create faster animations, lower values create slower animations.\n\n        Raises\n        ------\n        ValueError\n            If the file extension is not one of the supported formats.\n        FileNotFoundError\n            If FFmpeg is not installed (required for mov, avi, and mp4 formats).\n\n        Notes\n        -----\n        - For GIF format, the PillowWriter is used.\n        - For MOV, AVI, and MP4 formats, FFMpegWriter is used, which requires FFmpeg to be installed.\n        - You can download FFmpeg from https://ffmpeg.org/\n\n        Examples\n        --------\n        Save an animation as a GIF file:\n        ```python\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from cleopatra.array_glyph import ArrayGlyph\n        &gt;&gt;&gt; # Create a 3D array with 5 frames, each 10x10\n        &gt;&gt;&gt; arr = np.random.randint(1, 10, size=(5, 10, 10))\n        &gt;&gt;&gt; frame_labels = [\"Frame 1\", \"Frame 2\", \"Frame 3\", \"Frame 4\", \"Frame 5\"]\n        &gt;&gt;&gt; animated_array = ArrayGlyph(arr)\n        &gt;&gt;&gt; anim_obj = animated_array.animate(frame_labels)\n        &gt;&gt;&gt; animated_array.save_animation(\"animation.gif\")\n\n        ```\n        Save with a higher frame rate for a faster animation:\n        ```python\n        &gt;&gt;&gt; animated_array.save_animation(\"animation.gif\", fps=5)\n\n        ```\n        Save in MP4 format (requires FFmpeg):\n        ```python\n        &gt;&gt;&gt; animated_array.save_animation(\"animation.mp4\", fps=10)\n\n        ```\n        \"\"\"\n        video_format = path.split(\".\")[-1]\n        if video_format not in SUPPORTED_VIDEO_FORMAT:\n            raise ValueError(\n                f\"The given extension {video_format} implies a format that is not supported, \"\n                f\"only {SUPPORTED_VIDEO_FORMAT} are supported\"\n            )\n\n        if video_format == \"gif\":\n            writer_gif = animation.PillowWriter(fps=fps)\n            self.anim.save(path, writer=writer_gif)\n        else:\n            try:\n                if video_format == \"avi\" or video_format == \"mov\":\n                    writer_video = animation.FFMpegWriter(fps=fps, bitrate=1800)\n                    self.anim.save(path, writer=writer_video)\n                elif video_format == \"mp4\":\n                    writer_mp4 = animation.FFMpegWriter(fps=fps, bitrate=1800)\n                    self.anim.save(path, writer=writer_mp4)\n            except FileNotFoundError:\n                print(\n                    \"Please visit https://ffmpeg.org/ and download a version of ffmpeg compatible with your operating\"\n                    \"system, for more details please check the method definition\"\n                )\n</code></pre>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.anim","title":"<code>anim</code>  <code>property</code>","text":"<p>Animation function</p>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.default_options","title":"<code>default_options</code>  <code>property</code>","text":"<p>Default plot options</p>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.exclude_value","title":"<code>exclude_value</code>  <code>property</code> <code>writable</code>","text":"<p>exclude_value</p>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.vmax","title":"<code>vmax</code>  <code>property</code>","text":"<p>max value in the array</p>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.vmin","title":"<code>vmin</code>  <code>property</code>","text":"<p>min value in the array</p>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.__init__","title":"<code>__init__(array, exclude_value=np.nan, extent=None, rgb=None, surface_reflectance=None, cutoff=None, ax=None, fig=None, percentile=None, **kwargs)</code>","text":"<p>Initialize the ArrayGlyph object with an array and optional parameters.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The array to be visualized. Can be a 2D array for single plots or a 3D array for RGB plots or animations.</p> required <code>exclude_value</code> <code>List or numeric</code> <p>Value(s) used to mask cells out of the domain, by default np.nan. Can be a single value or a list of values to exclude.</p> <code>nan</code> <code>extent</code> <code>List</code> <p>The extent of the array in the format [xmin, ymin, xmax, ymax], by default None. If provided, the array will be plotted with these spatial boundaries.</p> <code>None</code> <code>rgb</code> <code>List[int]</code> <p>The indices of the red, green, and blue bands in the given array, by default None. If provided, the array will be treated as an RGB image. Can be a list of three values [r, g, b], or four values if alpha band is included [r, g, b, a].</p> <code>None</code> <code>surface_reflectance</code> <code>int</code> <p>Surface reflectance value for normalizing satellite data, by default None. Typically 10000 for Sentinel-2 data.</p> <code>None</code> <code>cutoff</code> <code>List</code> <p>Clip the range of pixel values for each band, by default None. Takes only pixel values from 0 to the value of the cutoff and scales them back to between 0 and 1. Should be a list with one value per band.</p> <code>None</code> <code>ax</code> <code>Axes</code> <p>A pre-existing axes to plot on, by default None. If None, a new axes will be created.</p> <code>None</code> <code>fig</code> <code>Figure</code> <p>A pre-existing figure to plot on, by default None. If None, a new figure will be created.</p> <code>None</code> <code>percentile</code> <code>int</code> <p>The percentile value to be used for scaling the array values, by default None. Used to enhance contrast by stretching the histogram.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for customizing the plot. Supported arguments include:     figsize : tuple, optional         Figure size, by default (8, 8).     vmin : float, optional         Minimum value for color scaling, by default min(array).     vmax : float, optional         Maximum value for color scaling, by default max(array).     title : str, optional         Title of the plot, by default 'Array Plot'.     title_size : int, optional         Title font size, by default 15.     cmap : str, optional         Colormap name, by default 'coolwarm_r'.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid keyword argument is provided.</p> <code>ValueError</code> <p>If rgb is provided but the array doesn't have enough dimensions.</p> <p>Examples:</p> <p>Basic initialization with a 2D array: <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from cleopatra.array_glyph import ArrayGlyph\n&gt;&gt;&gt; arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n&gt;&gt;&gt; array_glyph = ArrayGlyph(arr)\n&gt;&gt;&gt; fig, ax = array_glyph.plot()\n</code></pre> Initialization with custom figure size and title: <pre><code>&gt;&gt;&gt; array_glyph = ArrayGlyph(arr, figsize=(10, 8), title=\"Custom Array Plot\")\n&gt;&gt;&gt; fig, ax = array_glyph.plot()\n</code></pre> Initialization with RGB bands from a 3D array: <pre><code>&gt;&gt;&gt; rgb_array = np.random.randint(0, 255, size=(3, 10, 10))\n&gt;&gt;&gt; rgb_glyph = ArrayGlyph(rgb_array, rgb=[0, 1, 2], surface_reflectance=255)\n&gt;&gt;&gt; fig, ax = rgb_glyph.plot()\n</code></pre> Initialization with custom extent: <pre><code>&gt;&gt;&gt; array_glyph = ArrayGlyph(arr, extent=[0, 0, 10, 10])\n&gt;&gt;&gt; fig, ax = array_glyph.plot()\n</code></pre></p> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>def __init__(\n    self,\n    array: np.ndarray,\n    exclude_value: List = np.nan,\n    extent: List = None,\n    rgb: List[int] = None,\n    surface_reflectance: int = None,\n    cutoff: List = None,\n    ax: Axes = None,\n    fig: Figure = None,\n    percentile: int = None,\n    **kwargs,\n):\n    \"\"\"Initialize the ArrayGlyph object with an array and optional parameters.\n\n    Parameters\n    ----------\n    array : np.ndarray\n        The array to be visualized. Can be a 2D array for single plots or a 3D array for RGB plots or animations.\n    exclude_value : List or numeric, optional\n        Value(s) used to mask cells out of the domain, by default np.nan.\n        Can be a single value or a list of values to exclude.\n    extent : List, optional\n        The extent of the array in the format [xmin, ymin, xmax, ymax], by default None.\n        If provided, the array will be plotted with these spatial boundaries.\n    rgb : List[int], optional\n        The indices of the red, green, and blue bands in the given array, by default None.\n        If provided, the array will be treated as an RGB image.\n        Can be a list of three values [r, g, b], or four values if alpha band is included [r, g, b, a].\n    surface_reflectance : int, optional\n        Surface reflectance value for normalizing satellite data, by default None.\n        Typically 10000 for Sentinel-2 data.\n    cutoff : List, optional\n        Clip the range of pixel values for each band, by default None.\n        Takes only pixel values from 0 to the value of the cutoff and scales them back to between 0 and 1.\n        Should be a list with one value per band.\n    ax : matplotlib.axes.Axes, optional\n        A pre-existing axes to plot on, by default None.\n        If None, a new axes will be created.\n    fig : matplotlib.figure.Figure, optional\n        A pre-existing figure to plot on, by default None.\n        If None, a new figure will be created.\n    percentile : int, optional\n        The percentile value to be used for scaling the array values, by default None.\n        Used to enhance contrast by stretching the histogram.\n    **kwargs : dict\n        Additional keyword arguments for customizing the plot.\n        Supported arguments include:\n            figsize : tuple, optional\n                Figure size, by default (8, 8).\n            vmin : float, optional\n                Minimum value for color scaling, by default min(array).\n            vmax : float, optional\n                Maximum value for color scaling, by default max(array).\n            title : str, optional\n                Title of the plot, by default 'Array Plot'.\n            title_size : int, optional\n                Title font size, by default 15.\n            cmap : str, optional\n                Colormap name, by default 'coolwarm_r'.\n\n    Raises\n    ------\n    ValueError\n        If an invalid keyword argument is provided.\n    ValueError\n        If rgb is provided but the array doesn't have enough dimensions.\n\n    Examples\n    --------\n    Basic initialization with a 2D array:\n    ```python\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from cleopatra.array_glyph import ArrayGlyph\n    &gt;&gt;&gt; arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    &gt;&gt;&gt; array_glyph = ArrayGlyph(arr)\n    &gt;&gt;&gt; fig, ax = array_glyph.plot()\n\n    ```\n    Initialization with custom figure size and title:\n    ```python\n    &gt;&gt;&gt; array_glyph = ArrayGlyph(arr, figsize=(10, 8), title=\"Custom Array Plot\")\n    &gt;&gt;&gt; fig, ax = array_glyph.plot()\n\n    ```\n    Initialization with RGB bands from a 3D array:\n    ```python\n    &gt;&gt;&gt; rgb_array = np.random.randint(0, 255, size=(3, 10, 10))\n    &gt;&gt;&gt; rgb_glyph = ArrayGlyph(rgb_array, rgb=[0, 1, 2], surface_reflectance=255)\n    &gt;&gt;&gt; fig, ax = rgb_glyph.plot()\n\n    ```\n    Initialization with custom extent:\n    ```python\n    &gt;&gt;&gt; array_glyph = ArrayGlyph(arr, extent=[0, 0, 10, 10])\n    &gt;&gt;&gt; fig, ax = array_glyph.plot()\n\n    ```\n    \"\"\"\n    self._default_options = DEFAULT_OPTIONS.copy()\n\n    for key, val in kwargs.items():\n        if key not in self.default_options.keys():\n            raise ValueError(\n                f\"The given keyword argument:{key} is not correct, possible parameters are,\"\n                f\" {DEFAULT_OPTIONS}\"\n            )\n        else:\n            self.default_options[key] = val\n    # first replace the no_data_value by nan\n    # convert the array to float32 to be able to replace the no data value with nan\n    if exclude_value is not np.nan:\n        if len(exclude_value) &gt; 1:\n            mask = np.logical_or(\n                np.isclose(array, exclude_value[0], rtol=0.001),\n                np.isclose(array, exclude_value[1], rtol=0.001),\n            )\n        else:\n            mask = np.isclose(array, exclude_value[0], rtol=0.0000001)\n        array = ma.array(array, mask=mask, dtype=array.dtype)\n    else:\n        array = ma.array(array)\n\n    # convert the extent from [xmin, ymin, xmax, ymax] to [xmin, xmax, ymin, ymax] as required by matplotlib.\n    if extent is not None:\n        extent = [extent[0], extent[2], extent[1], extent[3]]\n    self.extent = extent\n\n    if rgb is not None:\n        self.rgb = True\n        # prepare to plot rgb plot only if there are three arrays\n        if array.shape[0] &lt; 3:\n            raise ValueError(\n                f\"To plot RGB plot the given array should have only 3 arrays, given array have \"\n                f\"{array.shape[0]}\"\n            )\n        else:\n            array = self.prepare_array(\n                array,\n                rgb=rgb,\n                surface_reflectance=surface_reflectance,\n                cutoff=cutoff,\n                percentile=percentile,\n            )\n    else:\n        self.rgb = False\n\n    self._exclude_value = exclude_value\n\n    self._vmax = (\n        np.nanmax(array) if kwargs.get(\"vmax\") is None else kwargs.get(\"vmax\")\n    )\n    self._vmin = (\n        np.nanmin(array) if kwargs.get(\"vmin\") is None else kwargs.get(\"vmin\")\n    )\n\n    self.arr = array\n    # get the tick spacing that has 10 ticks only\n    self.ticks_spacing = (self._vmax - self._vmin) / 10\n    shape = array.shape\n    if len(shape) == 3:\n        no_elem = array[0, :, :].count()\n    else:\n        no_elem = array.count()\n\n    self.no_elem = no_elem\n    if fig is None:\n        self.fig, self.ax = self.create_figure_axes()\n    else:\n        self.fig, self.ax = fig, ax\n</code></pre>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.__str__","title":"<code>__str__()</code>","text":"<p>String representation of the Array object.</p> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>def __str__(self):\n    \"\"\"String representation of the Array object.\"\"\"\n    message = f\"\"\"\n                Min: {self.vmin}\n                Max: {self.vmax}\n                Exclude values: {self.exclude_value}\n                RGB: {self.rgb}\n            \"\"\"\n    return message\n</code></pre>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.animate","title":"<code>animate(time, points=None, text_colors=('white', 'black'), interval=200, text_loc=None, point_color='red', point_size=100, pid_color='blue', pid_size=10, **kwargs)</code>","text":"<p>Create an animation from a 3D array.</p> <p>This method creates an animation by iterating through the first dimension of a 3D array. Each slice of the array becomes a frame in the animation, with optional time labels, point annotations, and cell value displays.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>List[Any]</code> <p>A list containing labels for each frame in the animation. These could be timestamps, frame numbers, or any other identifiers. The length of this list should match the first dimension of the array.</p> required <code>points</code> <code>ndarray</code> <p>Points to display on the array, by default None. Should be a 3-column array where: - First column: values to display for each point - Second column: row indices of the points in the array - Third column: column indices of the points in the array</p> <code>None</code> <code>text_colors</code> <code>Tuple[str, str]</code> <p>Two colors to be used for cell value text, by default (\"white\", \"black\"). The first color is used when the cell value is below the background_color_threshold, and the second color is used when the cell value is above the threshold.</p> <code>('white', 'black')</code> <code>interval</code> <code>int</code> <p>Delay between frames in milliseconds, by default 200. Controls the speed of the animation (smaller values = faster animation).</p> <code>200</code> <code>text_loc</code> <code>list[Any, Any]</code> <p>Location of the time label text as [x, y] coordinates, by default None. If None, defaults to [0.1, 0.2].</p> <code>None</code> <code>point_color</code> <code>str</code> <p>Color of the points, by default \"red\". Any valid matplotlib color string.</p> <code>'red'</code> <code>point_size</code> <code>int</code> <p>Size of the points, by default 100. Controls the marker size.</p> <code>100</code> <code>pid_color</code> <code>str</code> <p>Color of the point value annotations, by default \"blue\". Any valid matplotlib color string.</p> <code>'blue'</code> <code>pid_size</code> <code>int</code> <p>Size of the point value annotations, by default 10. Controls the font size of the annotations.</p> <code>10</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for customizing the animation.</p> <code>{}</code> <p>Returns:</p> Type Description <code>FuncAnimation</code> <p>The animation object that can be displayed in a notebook or saved to a file.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid keyword argument is provided.</p> <code>ValueError</code> <p>If the length of the time list doesn't match the first dimension of the array.</p> Notes <p>The animation is created by iterating through the first dimension of the array. For example, if the array has shape (10, 20, 30), the animation will have 10 frames, each showing a 20x30 slice of the array.</p> <p>To display the animation in a Jupyter notebook, you may need to use: <pre><code>from IPython.display import HTML\nHTML(anim_obj.to_jshtml())\n</code></pre></p> <p>To save the animation to a file, use the <code>save_animation</code> method after creating the animation.</p> <p>Examples:</p> <p>Basic animation from a 3D array: <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from cleopatra.array_glyph import ArrayGlyph\n&gt;&gt;&gt; # Create a 3D array with 5 frames, each 10x10\n&gt;&gt;&gt; arr = np.random.randint(1, 10, size=(5, 10, 10))\n&gt;&gt;&gt; # Create labels for each frame\n&gt;&gt;&gt; frame_labels = [\"Frame 1\", \"Frame 2\", \"Frame 3\", \"Frame 4\", \"Frame 5\"]\n&gt;&gt;&gt; # Create the ArrayGlyph object\n&gt;&gt;&gt; animated_array = ArrayGlyph(arr, figsize=(8, 8), title=\"Animated Array\")\n&gt;&gt;&gt; # Create the animation\n&gt;&gt;&gt; anim_obj = animated_array.animate(frame_labels)\n</code></pre> Animation with custom interval (speed): <pre><code>&gt;&gt;&gt; # Slower animation (500ms between frames)\n&gt;&gt;&gt; anim_obj = animated_array.animate(frame_labels, interval=500)\n&gt;&gt;&gt; # Faster animation (100ms between frames)\n&gt;&gt;&gt; anim_obj = animated_array.animate(frame_labels, interval=100)\n</code></pre> Animation with points: <pre><code>&gt;&gt;&gt; # Create points to display on the animation\n&gt;&gt;&gt; points = np.array([[1, 2, 3], [2, 5, 5], [3, 8, 8]])\n&gt;&gt;&gt; anim_obj = animated_array.animate(\n...     frame_labels,\n...     points=points,\n...     point_color=\"black\",\n...     point_size=150,\n...     pid_color=\"white\",\n...     pid_size=12\n... )\n</code></pre> Animation with cell values displayed: <pre><code>&gt;&gt;&gt; anim_obj = animated_array.animate(\n...     frame_labels,\n...     display_cell_value=True,\n...     num_size=10,\n...     text_colors=(\"yellow\", \"blue\")\n... )\n</code></pre> Saving the animation to a file: <pre><code>&gt;&gt;&gt; # Create the animation first\n&gt;&gt;&gt; anim_obj = animated_array.animate(frame_labels)\n&gt;&gt;&gt; # Then save it to a file\n&gt;&gt;&gt; animated_array.save_animation(\"animation.gif\", fps=2)\n</code></pre></p> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>def animate(\n    self,\n    time: List[Any],\n    points: np.ndarray = None,\n    text_colors=(\"white\", \"black\"),\n    interval=200,\n    text_loc: list[Any, Any] = None,\n    point_color=\"red\",\n    point_size=100,\n    pid_color=\"blue\",\n    pid_size=10,\n    **kwargs,\n):\n    \"\"\"Create an animation from a 3D array.\n\n    This method creates an animation by iterating through the first dimension of a 3D array.\n    Each slice of the array becomes a frame in the animation, with optional time labels,\n    point annotations, and cell value displays.\n\n    Parameters\n    ----------\n    time : List[Any]\n        A list containing labels for each frame in the animation.\n        These could be timestamps, frame numbers, or any other identifiers.\n        The length of this list should match the first dimension of the array.\n    points : np.ndarray, optional\n        Points to display on the array, by default None.\n        Should be a 3-column array where:\n        - First column: values to display for each point\n        - Second column: row indices of the points in the array\n        - Third column: column indices of the points in the array\n    text_colors : Tuple[str, str], optional\n        Two colors to be used for cell value text, by default (\"white\", \"black\").\n        The first color is used when the cell value is below the background_color_threshold,\n        and the second color is used when the cell value is above the threshold.\n    interval : int, optional\n        Delay between frames in milliseconds, by default 200.\n        Controls the speed of the animation (smaller values = faster animation).\n    text_loc : list[Any, Any], optional\n        Location of the time label text as [x, y] coordinates, by default None.\n        If None, defaults to [0.1, 0.2].\n    point_color : str, optional\n        Color of the points, by default \"red\".\n        Any valid matplotlib color string.\n    point_size : int, optional\n        Size of the points, by default 100.\n        Controls the marker size.\n    pid_color : str, optional\n        Color of the point value annotations, by default \"blue\".\n        Any valid matplotlib color string.\n    pid_size : int, optional\n        Size of the point value annotations, by default 10.\n        Controls the font size of the annotations.\n    **kwargs : dict\n        Additional keyword arguments for customizing the animation.\n\n        Plot appearance:\n        ---------------\n        title : str, optional\n            Title of the plot, by default 'Array Plot'.\n        title_size : int, optional\n            Title font size, by default 15.\n        cmap : str, optional\n            Colormap name, by default 'coolwarm_r'.\n        vmin : float, optional\n            Minimum value for color scaling, by default min(array).\n        vmax : float, optional\n            Maximum value for color scaling, by default max(array).\n\n        Color bar options:\n        ----------------\n        cbar_orientation : str, optional\n            Orientation of the color bar, by default 'vertical'.\n            Can be 'horizontal' or 'vertical'.\n        cbar_label_rotation : float, optional\n            Rotation angle of the color bar label, by default -90.\n        cbar_label_location : str, optional\n            Location of the color bar label, by default 'bottom'.\n            Options: 'top', 'bottom', 'center', 'baseline', 'center_baseline'.\n        cbar_length : float, optional\n            Ratio to control the height/width of the color bar, by default 0.75.\n        ticks_spacing : int, optional\n            Spacing between ticks on the color bar, by default 2.\n        cbar_label_size : int, optional\n            Font size of the color bar label, by default 12.\n        cbar_label : str, optional\n            Label text for the color bar, by default 'Value'.\n\n        Color scale options:\n        ------------------\n        color_scale : str, optional\n            Type of color scaling to use, by default 'linear'.\n            Options:\n            - 'linear': Linear scale\n            - 'power': Power-law normalization\n            - 'sym-lognorm': Symmetrical logarithmic scale\n            - 'boundary-norm': Discrete intervals based on boundaries\n            - 'midpoint': Scale split at a specified midpoint\n        gamma : float, optional\n            Exponent for 'power' color scale, by default 0.5.\n            Values &lt; 1 emphasize lower values, values &gt; 1 emphasize higher values.\n        line_threshold : float, optional\n            Threshold for 'sym-lognorm' color scale, by default 0.0001.\n        line_scale : float, optional\n            Scale factor for 'sym-lognorm' color scale, by default 0.001.\n        bounds : List, optional\n            Boundaries for 'boundary-norm' color scale, by default None.\n            Defines the discrete intervals for color mapping.\n        midpoint : float, optional\n            Midpoint value for 'midpoint' color scale, by default 0.\n\n        Cell value display options:\n        -------------------------\n        display_cell_value : bool, optional\n            Whether to display the values of cells as text, by default False.\n        num_size : int, optional\n            Font size of the cell value text, by default 8.\n        background_color_threshold : float, optional\n            Threshold for cell value text color, by default None.\n            If cell value &gt; threshold, text is black; otherwise, text is white.\n            If None, uses max(array)/2 as the threshold.\n\n    Returns\n    -------\n    matplotlib.animation.FuncAnimation\n        The animation object that can be displayed in a notebook or saved to a file.\n\n    Raises\n    ------\n    ValueError\n        If an invalid keyword argument is provided.\n    ValueError\n        If the length of the time list doesn't match the first dimension of the array.\n\n    Notes\n    -----\n    The animation is created by iterating through the first dimension of the array.\n    For example, if the array has shape (10, 20, 30), the animation will have 10 frames,\n    each showing a 20x30 slice of the array.\n\n    To display the animation in a Jupyter notebook, you may need to use:\n    ```python\n    from IPython.display import HTML\n    HTML(anim_obj.to_jshtml())\n    ```\n\n    To save the animation to a file, use the `save_animation` method after creating\n    the animation.\n\n    Examples\n    --------\n    Basic animation from a 3D array:\n    ```python\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from cleopatra.array_glyph import ArrayGlyph\n    &gt;&gt;&gt; # Create a 3D array with 5 frames, each 10x10\n    &gt;&gt;&gt; arr = np.random.randint(1, 10, size=(5, 10, 10))\n    &gt;&gt;&gt; # Create labels for each frame\n    &gt;&gt;&gt; frame_labels = [\"Frame 1\", \"Frame 2\", \"Frame 3\", \"Frame 4\", \"Frame 5\"]\n    &gt;&gt;&gt; # Create the ArrayGlyph object\n    &gt;&gt;&gt; animated_array = ArrayGlyph(arr, figsize=(8, 8), title=\"Animated Array\")\n    &gt;&gt;&gt; # Create the animation\n    &gt;&gt;&gt; anim_obj = animated_array.animate(frame_labels)\n\n    ```\n    Animation with custom interval (speed):\n    ```python\n    &gt;&gt;&gt; # Slower animation (500ms between frames)\n    &gt;&gt;&gt; anim_obj = animated_array.animate(frame_labels, interval=500)\n    &gt;&gt;&gt; # Faster animation (100ms between frames)\n    &gt;&gt;&gt; anim_obj = animated_array.animate(frame_labels, interval=100)\n\n    ```\n    Animation with points:\n    ```python\n    &gt;&gt;&gt; # Create points to display on the animation\n    &gt;&gt;&gt; points = np.array([[1, 2, 3], [2, 5, 5], [3, 8, 8]])\n    &gt;&gt;&gt; anim_obj = animated_array.animate(\n    ...     frame_labels,\n    ...     points=points,\n    ...     point_color=\"black\",\n    ...     point_size=150,\n    ...     pid_color=\"white\",\n    ...     pid_size=12\n    ... )\n\n    ```\n    Animation with cell values displayed:\n    ```python\n    &gt;&gt;&gt; anim_obj = animated_array.animate(\n    ...     frame_labels,\n    ...     display_cell_value=True,\n    ...     num_size=10,\n    ...     text_colors=(\"yellow\", \"blue\")\n    ... )\n\n    ```\n    Saving the animation to a file:\n    ```python\n    &gt;&gt;&gt; # Create the animation first\n    &gt;&gt;&gt; anim_obj = animated_array.animate(frame_labels)\n    &gt;&gt;&gt; # Then save it to a file\n    &gt;&gt;&gt; animated_array.save_animation(\"animation.gif\", fps=2)\n\n    ```\n    \"\"\"\n    if text_loc is None:\n        text_loc = [0.1, 0.2]\n\n    for key, val in kwargs.items():\n        if key not in self.default_options.keys():\n            raise ValueError(\n                f\"The given keyword argument:{key} is not correct, possible parameters are,\"\n                f\" {DEFAULT_OPTIONS}\"\n            )\n        else:\n            self.default_options[key] = val\n\n    # if user did not input ticks spacing use the calculated one.\n    if \"ticks_spacing\" in kwargs.keys():\n        self.default_options[\"ticks_spacing\"] = kwargs[\"ticks_spacing\"]\n    else:\n        self.default_options[\"ticks_spacing\"] = self.ticks_spacing\n\n    if \"vmin\" in kwargs.keys():\n        self.default_options[\"vmin\"] = kwargs[\"vmin\"]\n    else:\n        self.default_options[\"vmin\"] = self.vmin\n\n    if \"vmax\" in kwargs.keys():\n        self.default_options[\"vmax\"] = kwargs[\"vmax\"]\n    else:\n        self.default_options[\"vmax\"] = self.vmax\n\n    # if optional_display\n    precision = self.default_options[\"precision\"]\n    array = self.arr\n    fig, ax = self.fig, self.ax\n\n    ticks = self.get_ticks()\n    im, cbar_kw = self._plot_im_get_cbar_kw(ax, array[0, :, :], ticks)\n\n    # Create colorbar\n    cbar = ax.figure.colorbar(\n        im,\n        ax=ax,\n        shrink=self.default_options[\"cbar_length\"],\n        orientation=self.default_options[\"cbar_orientation\"],\n        **cbar_kw,\n    )\n    cbar.ax.set_ylabel(\n        self.default_options[\"cbar_label\"],\n        rotation=self.default_options[\"cbar_label_rotation\"],\n        va=self.default_options[\"cbar_label_location\"],\n        fontsize=self.default_options[\"cbar_label_size\"],\n    )\n    cbar.ax.tick_params(labelsize=10)\n\n    ax.set_title(\n        self.default_options[\"title\"], fontsize=self.default_options[\"title_size\"]\n    )\n    ax.set_xticklabels([])\n    ax.set_yticklabels([])\n\n    ax.set_xticks([])\n    ax.set_yticks([])\n\n    if self.default_options[\"display_cell_value\"]:\n        indices = get_indices2(array[0, :, :], [np.nan])\n        cell_text_value = self._plot_text(\n            ax, array[0, :, :], indices, self.default_options\n        )\n        indices = np.array(indices)\n\n    if points is not None:\n        row = points[:, 1]\n        col = points[:, 2]\n        points_scatter = ax.scatter(col, row, color=point_color, s=point_size)\n        points_id = self._plot_point_values(ax, points, pid_color, pid_size)\n\n    # Normalize the threshold to the image color range.\n    if self.default_options[\"background_color_threshold\"] is not None:\n        background_color_threshold = im.norm(\n            self.default_options[\"background_color_threshold\"]\n        )\n    else:\n        background_color_threshold = im.norm(np.nanmax(array)) / 2.0\n\n    day_text = ax.text(\n        text_loc[0],\n        text_loc[1],\n        \" \",\n        fontsize=self.default_options[\"cbar_label_size\"],\n    )\n\n    def init():\n        \"\"\"initialize the plot with the first array\"\"\"\n        im.set_data(array[0, :, :])\n        day_text.set_text(\"\")\n        output = [im, day_text]\n\n        if points is not None:\n            points_scatter.set_offsets(np.c_[col, row])\n            output.append(points_scatter)\n            update_points = lambda x: points_id[x].set_text(points[x, 0])\n            list(map(update_points, range(len(col))))\n\n            output += points_id\n\n        if self.default_options[\"display_cell_value\"]:\n            vals = array[0, indices[:, 0], indices[:, 1]]\n            update_cell_value = lambda x: cell_text_value[x].set_text(vals[x])\n            list(map(update_cell_value, range(self.no_elem)))\n            output += cell_text_value\n\n        return output\n\n    def animate_a(i):\n        \"\"\"plot for each element in the iterable.\"\"\"\n        im.set_data(array[i, :, :])\n        day_text.set_text(\"Date = \" + str(time[i])[0:10])\n        output = [im, day_text]\n\n        if points is not None:\n            points_scatter.set_offsets(np.c_[col, row])\n            output.append(points_scatter)\n\n            for x in range(len(col)):\n                points_id[x].set_text(points[x, 0])\n\n            output += points_id\n\n        if self.default_options[\"display_cell_value\"]:\n            vals = array[i, indices[:, 0], indices[:, 1]]\n\n            def update_cell_value(x):\n                \"\"\"Update cell value\"\"\"\n                val = round(vals[x], precision)\n                kw = {\n                    \"color\": text_colors[\n                        int(im.norm(vals[x]) &gt; background_color_threshold)\n                    ]\n                }\n                cell_text_value[x].update(kw)\n                cell_text_value[x].set_text(val)\n\n            list(map(update_cell_value, range(self.no_elem)))\n\n            output += cell_text_value\n\n        return output\n\n    plt.tight_layout()\n\n    anim = FuncAnimation(\n        fig,\n        animate_a,\n        init_func=init,\n        frames=np.shape(array)[0],\n        interval=interval,\n        blit=True,\n    )\n    self._anim = anim\n    plt.show()\n    return anim\n</code></pre>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.animate--plot-appearance","title":"Plot appearance:","text":"<p>title : str, optional     Title of the plot, by default 'Array Plot'. title_size : int, optional     Title font size, by default 15. cmap : str, optional     Colormap name, by default 'coolwarm_r'. vmin : float, optional     Minimum value for color scaling, by default min(array). vmax : float, optional     Maximum value for color scaling, by default max(array).</p>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.animate--color-bar-options","title":"Color bar options:","text":"<p>cbar_orientation : str, optional     Orientation of the color bar, by default 'vertical'.     Can be 'horizontal' or 'vertical'. cbar_label_rotation : float, optional     Rotation angle of the color bar label, by default -90. cbar_label_location : str, optional     Location of the color bar label, by default 'bottom'.     Options: 'top', 'bottom', 'center', 'baseline', 'center_baseline'. cbar_length : float, optional     Ratio to control the height/width of the color bar, by default 0.75. ticks_spacing : int, optional     Spacing between ticks on the color bar, by default 2. cbar_label_size : int, optional     Font size of the color bar label, by default 12. cbar_label : str, optional     Label text for the color bar, by default 'Value'.</p>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.animate--color-scale-options","title":"Color scale options:","text":"<p>color_scale : str, optional     Type of color scaling to use, by default 'linear'.     Options:     - 'linear': Linear scale     - 'power': Power-law normalization     - 'sym-lognorm': Symmetrical logarithmic scale     - 'boundary-norm': Discrete intervals based on boundaries     - 'midpoint': Scale split at a specified midpoint gamma : float, optional     Exponent for 'power' color scale, by default 0.5.     Values &lt; 1 emphasize lower values, values &gt; 1 emphasize higher values. line_threshold : float, optional     Threshold for 'sym-lognorm' color scale, by default 0.0001. line_scale : float, optional     Scale factor for 'sym-lognorm' color scale, by default 0.001. bounds : List, optional     Boundaries for 'boundary-norm' color scale, by default None.     Defines the discrete intervals for color mapping. midpoint : float, optional     Midpoint value for 'midpoint' color scale, by default 0.</p>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.animate--cell-value-display-options","title":"Cell value display options:","text":"<p>display_cell_value : bool, optional     Whether to display the values of cells as text, by default False. num_size : int, optional     Font size of the cell value text, by default 8. background_color_threshold : float, optional     Threshold for cell value text color, by default None.     If cell value &gt; threshold, text is black; otherwise, text is white.     If None, uses max(array)/2 as the threshold.</p>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.create_color_bar","title":"<code>create_color_bar(ax, im, cbar_kw)</code>","text":"<p>Create Color bar.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>matplotlib axes.</p> required <code>im</code> <code>AxesImage</code> <p>Image axes.</p> required <code>cbar_kw</code> <code>dict</code> <p>color bar keyword arguments.</p> required <p>Returns:</p> Name Type Description <code>Colorbar</code> <code>Colorbar</code> <p>colorbar object.</p> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>def create_color_bar(self, ax: Axes, im: AxesImage, cbar_kw: dict) -&gt; Colorbar:\n    \"\"\"Create Color bar.\n\n    Parameters\n    ----------\n    ax: Axes\n        matplotlib axes.\n    im: AxesImage\n        Image axes.\n    cbar_kw: dict\n        color bar keyword arguments.\n\n    Returns\n    -------\n    Colorbar:\n        colorbar object.\n    \"\"\"\n    # im or cax is the last image added to the axes\n    # im = ax.images[-1]\n    cbar = ax.figure.colorbar(\n        im,\n        ax=ax,\n        shrink=self.default_options[\"cbar_length\"],\n        orientation=self.default_options[\"cbar_orientation\"],\n        **cbar_kw,\n    )\n    # cbar.ax.set_ylabel(\n    #     self.default_options[\"cbar_label\"],\n    #     rotation=self.default_options[\"cbar_label_rotation\"],\n    #     va=self.default_options[\"cbar_label_location\"],\n    #     fontsize=self.default_options[\"cbar_label_size\"],\n    # )\n    cbar.ax.tick_params(labelsize=10)\n    cbar.set_label(\n        self.default_options[\"cbar_label\"],\n        fontsize=self.default_options[\"cbar_label_size\"],\n        loc=self.default_options[\"cbar_label_location\"],\n    )\n\n    return cbar\n</code></pre>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.create_figure_axes","title":"<code>create_figure_axes()</code>","text":"<p>Create the figure and the axes.</p> <p>Returns:</p> Name Type Description <code>fig</code> <code>Figure</code> <p>the created figure.</p> <code>ax</code> <code>Axes</code> <p>the created axes.</p> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>def create_figure_axes(self) -&gt; Tuple[Figure, Axes]:\n    \"\"\"Create the figure and the axes.\n\n    Returns\n    -------\n    fig: matplotlib.figure.Figure\n        the created figure.\n    ax: matplotlib.axes.Axes\n        the created axes.\n    \"\"\"\n    plt.ioff()  # to prevent the empty figure from being displayed\n    fig, ax = plt.subplots(figsize=self.default_options[\"figsize\"])\n\n    return fig, ax\n</code></pre>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.get_ticks","title":"<code>get_ticks()</code>","text":"<p>get a list of ticks for the color bar</p> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>def get_ticks(self) -&gt; np.ndarray:\n    \"\"\"get a list of ticks for the color bar\"\"\"\n    ticks_spacing = self.default_options[\"ticks_spacing\"]\n    vmax = self.default_options[\"vmax\"]\n    vmin = self.default_options[\"vmin\"]\n    remainder = np.round(math.remainder(vmax, ticks_spacing), 3)\n    # np.mod(vmax, ticks_spacing) gives float point error, so we use the round function.\n    if remainder == 0:\n        ticks = np.arange(vmin, vmax + ticks_spacing, ticks_spacing)\n    else:\n        try:\n            ticks = np.arange(vmin, vmax + ticks_spacing, ticks_spacing)\n        except ValueError:\n            raise ValueError(\n                \"The number of ticks exceeded the max allowed size, possible errors\"\n                f\" is the value of the NodataValue you entered-{self.exclude_value}\"\n            )\n        ticks = np.append(\n            ticks,\n            [int(vmax / ticks_spacing) * ticks_spacing + ticks_spacing],\n        )\n    return ticks\n</code></pre>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.plot","title":"<code>plot(points=None, point_color='red', point_size=100, pid_color='blue', pid_size=10, **kwargs)</code>","text":"<p>Plot the array with customizable visualization options.</p> <p>This method creates a visualization of the array with various customization options including color scales, color bars, cell value display, and point annotations. It supports both regular arrays and RGB arrays.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>ndarray</code> <p>Points to display on the array, by default None. Should be a 3-column array where: - First column: values to display for each point - Second column: row indices of the points in the array - Third column: column indices of the points in the array</p> <code>None</code> <code>point_color</code> <code>str</code> <p>Color of the points, by default \"red\". Any valid matplotlib color string.</p> <code>'red'</code> <code>point_size</code> <code>Union[int, float]</code> <p>Size of the points, by default 100. Controls the marker size.</p> <code>100</code> <code>pid_color</code> <code>str</code> <p>Color of the point value annotations, by default \"blue\". Any valid matplotlib color string.</p> <code>'blue'</code> <code>pid_size</code> <code>Union[int, float]</code> <p>Size of the point value annotations, by default 10. Controls the font size of the annotations.</p> <code>10</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for customizing the plot.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Tuple[Figure, Axes]</code> <p>A tuple containing: - fig: The matplotlib Figure object - ax: The matplotlib Axes object</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid keyword argument is provided.</p> <p>Examples:</p> <p>Basic array plot: <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from cleopatra.array_glyph import ArrayGlyph\n&gt;&gt;&gt; arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n&gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Customized Plot\", title_size=18)\n&gt;&gt;&gt; fig, ax = array.plot()\n</code></pre> Color bar customization: <pre><code>&gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Customized color bar\", title_size=18)\n&gt;&gt;&gt; fig, ax = array.plot(\n...     cbar_orientation=\"horizontal\",\n...     cbar_label_rotation=-90,\n...     cbar_label_location=\"center\",\n...     cbar_length=0.7,\n...     cbar_label_size=12,\n...     cbar_label=\"Discharge m3/s\",\n...     ticks_spacing=5,\n...     color_scale=\"linear\",\n...     cmap=\"coolwarm_r\",\n... )\n</code></pre> Display cell values: <pre><code>&gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Display array values\", title_size=18)\n&gt;&gt;&gt; fig, ax = array.plot(\n...     display_cell_value=True,\n...     num_size=12\n... )\n</code></pre> Plot points at specific locations: <pre><code>&gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Display Points\", title_size=14)\n&gt;&gt;&gt; points = np.array([[1, 0, 0], [2, 1, 1], [3, 2, 2]])\n&gt;&gt;&gt; fig, ax = array.plot(\n...     points=points,\n...     point_color=\"black\",\n...     point_size=100,\n...     pid_color=\"orange\",\n...     pid_size=30,\n... )\n</code></pre> Power scale with different gamma values: <pre><code>&gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Power scale\", title_size=18)\n&gt;&gt;&gt; fig, ax = array.plot(\n...     cbar_label=\"Discharge m3/s\",\n...     color_scale=\"power\",\n...     gamma=0.5,  # Default value\n...     cmap=\"coolwarm_r\",\n... )\n\n&gt;&gt;&gt; # Higher gamma (0.8) emphasizes higher values less\n&gt;&gt;&gt; fig, ax = array.plot(\n...     color_scale=\"power\",\n...     gamma=0.8,\n...     cmap=\"coolwarm_r\",\n... )\n\n&gt;&gt;&gt; # Lower gamma (0.1) emphasizes higher values more\n&gt;&gt;&gt; fig, ax = array.plot(\n...     color_scale=\"power\",\n...     gamma=0.1,\n...     cmap=\"coolwarm_r\",\n... )\n</code></pre> Logarithmic scale: <pre><code>&gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Logarithmic scale\", title_size=18)\n&gt;&gt;&gt; fig, ax = array.plot(\n...     cbar_label=\"Discharge m3/s\",\n...     color_scale=\"sym-lognorm\",\n...     cmap=\"coolwarm_r\",\n... )\n\n&gt;&gt;&gt; # Custom logarithmic scale parameters\n&gt;&gt;&gt; fig, ax = array.plot(\n...     color_scale=\"sym-lognorm\",\n...     line_threshold=0.015,\n...     line_scale=0.1,\n...     cmap=\"coolwarm_r\",\n... )\n</code></pre> Boundary scale with custom boundaries: <pre><code>&gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Boundary scale\", title_size=18)\n&gt;&gt;&gt; fig, ax = array.plot(\n...     color_scale=\"boundary-norm\",\n...     cmap=\"coolwarm_r\",\n... )\n\n&gt;&gt;&gt; # Custom boundaries\n&gt;&gt;&gt; bounds = [0, 5, 10]\n&gt;&gt;&gt; fig, ax = array.plot(\n...     color_scale=\"boundary-norm\",\n...     bounds=bounds,\n...     cmap=\"coolwarm_r\",\n... )\n</code></pre> Midpoint scale: <pre><code>&gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Midpoint scale\", title_size=18)\n&gt;&gt;&gt; fig, ax = array.plot(\n...     color_scale=\"midpoint\",\n...     midpoint=2,\n...     cmap=\"coolwarm_r\",\n... )\n</code></pre></p> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>def plot(\n    self,\n    points: np.ndarray = None,\n    point_color: str = \"red\",\n    point_size: Union[int, float] = 100,\n    pid_color=\"blue\",\n    pid_size: Union[int, float] = 10,\n    **kwargs,\n) -&gt; Tuple[Figure, Axes]:\n    \"\"\"Plot the array with customizable visualization options.\n\n    This method creates a visualization of the array with various customization options\n    including color scales, color bars, cell value display, and point annotations.\n    It supports both regular arrays and RGB arrays.\n\n    Parameters\n    ----------\n    points : np.ndarray, optional\n        Points to display on the array, by default None.\n        Should be a 3-column array where:\n        - First column: values to display for each point\n        - Second column: row indices of the points in the array\n        - Third column: column indices of the points in the array\n    point_color : str, optional\n        Color of the points, by default \"red\".\n        Any valid matplotlib color string.\n    point_size : Union[int, float], optional\n        Size of the points, by default 100.\n        Controls the marker size.\n    pid_color : str, optional\n        Color of the point value annotations, by default \"blue\".\n        Any valid matplotlib color string.\n    pid_size : Union[int, float], optional\n        Size of the point value annotations, by default 10.\n        Controls the font size of the annotations.\n    **kwargs : dict\n        Additional keyword arguments for customizing the plot.\n\n        Plot appearance:\n        ---------------\n        title : str, optional\n            Title of the plot, by default 'Array Plot'.\n        title_size : int, optional\n            Title font size, by default 15.\n        cmap : str, optional\n            Colormap name, by default 'coolwarm_r'.\n        vmin : float, optional\n            Minimum value for color scaling, by default min(array).\n        vmax : float, optional\n            Maximum value for color scaling, by default max(array).\n\n        Color bar options:\n        ----------------\n        cbar_orientation : str, optional\n            Orientation of the color bar, by default 'vertical'.\n            Can be 'horizontal' or 'vertical'.\n        cbar_label_rotation : float, optional\n            Rotation angle of the color bar label, by default -90.\n        cbar_label_location : str, optional\n            Location of the color bar label, by default 'bottom'.\n            Options: 'top', 'bottom', 'center', 'baseline', 'center_baseline'.\n        cbar_length : float, optional\n            Ratio to control the height/width of the color bar, by default 0.75.\n        ticks_spacing : int, optional\n            Spacing between ticks on the color bar, by default 2.\n        cbar_label_size : int, optional\n            Font size of the color bar label, by default 12.\n        cbar_label : str, optional\n            Label text for the color bar, by default 'Value'.\n\n        Color scale options:\n        ------------------\n        color_scale : str, optional\n            Type of color scaling to use, by default 'linear'.\n            Options:\n            - 'linear': Linear scale\n            - 'power': Power-law normalization\n            - 'sym-lognorm': Symmetrical logarithmic scale\n            - 'boundary-norm': Discrete intervals based on boundaries\n            - 'midpoint': Scale split at a specified midpoint\n        gamma : float, optional\n            Exponent for 'power' color scale, by default 0.5.\n            Values &lt; 1 emphasize lower values, values &gt; 1 emphasize higher values.\n        line_threshold : float, optional\n            Threshold for 'sym-lognorm' color scale, by default 0.0001.\n        line_scale : float, optional\n            Scale factor for 'sym-lognorm' color scale, by default 0.001.\n        bounds : List, optional\n            Boundaries for 'boundary-norm' color scale, by default None.\n            Defines the discrete intervals for color mapping.\n        midpoint : float, optional\n            Midpoint value for 'midpoint' color scale, by default 0.\n\n        Cell value display options:\n        -------------------------\n        display_cell_value : bool, optional\n            Whether to display the values of cells as text, by default False.\n        num_size : int, optional\n            Font size of the cell value text, by default 8.\n        background_color_threshold : float, optional\n            Threshold for cell value text color, by default None.\n            If cell value &gt; threshold, text is black; otherwise, text is white.\n            If None, uses max(array)/2 as the threshold.\n\n    Returns\n    -------\n    Tuple[matplotlib.figure.Figure, matplotlib.axes.Axes]\n        A tuple containing:\n        - fig: The matplotlib Figure object\n        - ax: The matplotlib Axes object\n\n    Raises\n    ------\n    ValueError\n        If an invalid keyword argument is provided.\n\n    Examples\n    --------\n    Basic array plot:\n    ```python\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from cleopatra.array_glyph import ArrayGlyph\n    &gt;&gt;&gt; arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Customized Plot\", title_size=18)\n    &gt;&gt;&gt; fig, ax = array.plot()\n\n    ```\n    Color bar customization:\n    ```python\n    &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Customized color bar\", title_size=18)\n    &gt;&gt;&gt; fig, ax = array.plot(\n    ...     cbar_orientation=\"horizontal\",\n    ...     cbar_label_rotation=-90,\n    ...     cbar_label_location=\"center\",\n    ...     cbar_length=0.7,\n    ...     cbar_label_size=12,\n    ...     cbar_label=\"Discharge m3/s\",\n    ...     ticks_spacing=5,\n    ...     color_scale=\"linear\",\n    ...     cmap=\"coolwarm_r\",\n    ... )\n\n    ```\n    Display cell values:\n    ```python\n    &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Display array values\", title_size=18)\n    &gt;&gt;&gt; fig, ax = array.plot(\n    ...     display_cell_value=True,\n    ...     num_size=12\n    ... )\n\n    ```\n    Plot points at specific locations:\n    ```python\n    &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Display Points\", title_size=14)\n    &gt;&gt;&gt; points = np.array([[1, 0, 0], [2, 1, 1], [3, 2, 2]])\n    &gt;&gt;&gt; fig, ax = array.plot(\n    ...     points=points,\n    ...     point_color=\"black\",\n    ...     point_size=100,\n    ...     pid_color=\"orange\",\n    ...     pid_size=30,\n    ... )\n\n    ```\n    Power scale with different gamma values:\n    ```python\n    &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Power scale\", title_size=18)\n    &gt;&gt;&gt; fig, ax = array.plot(\n    ...     cbar_label=\"Discharge m3/s\",\n    ...     color_scale=\"power\",\n    ...     gamma=0.5,  # Default value\n    ...     cmap=\"coolwarm_r\",\n    ... )\n\n    &gt;&gt;&gt; # Higher gamma (0.8) emphasizes higher values less\n    &gt;&gt;&gt; fig, ax = array.plot(\n    ...     color_scale=\"power\",\n    ...     gamma=0.8,\n    ...     cmap=\"coolwarm_r\",\n    ... )\n\n    &gt;&gt;&gt; # Lower gamma (0.1) emphasizes higher values more\n    &gt;&gt;&gt; fig, ax = array.plot(\n    ...     color_scale=\"power\",\n    ...     gamma=0.1,\n    ...     cmap=\"coolwarm_r\",\n    ... )\n\n    ```\n    Logarithmic scale:\n    ```python\n    &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Logarithmic scale\", title_size=18)\n    &gt;&gt;&gt; fig, ax = array.plot(\n    ...     cbar_label=\"Discharge m3/s\",\n    ...     color_scale=\"sym-lognorm\",\n    ...     cmap=\"coolwarm_r\",\n    ... )\n\n    &gt;&gt;&gt; # Custom logarithmic scale parameters\n    &gt;&gt;&gt; fig, ax = array.plot(\n    ...     color_scale=\"sym-lognorm\",\n    ...     line_threshold=0.015,\n    ...     line_scale=0.1,\n    ...     cmap=\"coolwarm_r\",\n    ... )\n\n    ```\n    Boundary scale with custom boundaries:\n    ```python\n    &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Boundary scale\", title_size=18)\n    &gt;&gt;&gt; fig, ax = array.plot(\n    ...     color_scale=\"boundary-norm\",\n    ...     cmap=\"coolwarm_r\",\n    ... )\n\n    &gt;&gt;&gt; # Custom boundaries\n    &gt;&gt;&gt; bounds = [0, 5, 10]\n    &gt;&gt;&gt; fig, ax = array.plot(\n    ...     color_scale=\"boundary-norm\",\n    ...     bounds=bounds,\n    ...     cmap=\"coolwarm_r\",\n    ... )\n\n    ```\n    Midpoint scale:\n    ```python\n    &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Midpoint scale\", title_size=18)\n    &gt;&gt;&gt; fig, ax = array.plot(\n    ...     color_scale=\"midpoint\",\n    ...     midpoint=2,\n    ...     cmap=\"coolwarm_r\",\n    ... )\n\n    ```\n    \"\"\"\n    for key, val in kwargs.items():\n        if key not in self.default_options.keys():\n            raise ValueError(\n                f\"The given keyword argument:{key} is not correct, possible parameters are,\"\n                f\" {DEFAULT_OPTIONS}\"\n            )\n        else:\n            self.default_options[key] = val\n\n    arr = self.arr\n    fig, ax = self.fig, self.ax\n\n    if self.rgb:\n        ax.imshow(arr, extent=self.extent)\n    else:\n        # if user did not input ticks spacing use the calculated one.\n        if \"ticks_spacing\" in kwargs.keys():\n            self.default_options[\"ticks_spacing\"] = kwargs[\"ticks_spacing\"]\n        else:\n            self.default_options[\"ticks_spacing\"] = self.ticks_spacing\n\n        if \"vmin\" in kwargs.keys():\n            self.default_options[\"vmin\"] = kwargs[\"vmin\"]\n        else:\n            self.default_options[\"vmin\"] = self.vmin\n\n        if \"vmax\" in kwargs.keys():\n            self.default_options[\"vmax\"] = kwargs[\"vmax\"]\n        else:\n            self.default_options[\"vmax\"] = self.vmax\n\n        # creating the ticks/bounds\n        ticks = self.get_ticks()\n        im, cbar_kw = self._plot_im_get_cbar_kw(ax, arr, ticks)\n\n        # Create colorbar\n        self.create_color_bar(ax, im, cbar_kw)\n\n    ax.set_title(\n        self.default_options[\"title\"], fontsize=self.default_options[\"title_size\"]\n    )\n\n    if self.extent is None:\n        ax.set_xticklabels([])\n        ax.set_yticklabels([])\n        ax.set_xticks([])\n        ax.set_yticks([])\n\n    optional_display = {}\n    if self.default_options[\"display_cell_value\"]:\n        indices = get_indices2(arr, [np.nan])\n        optional_display[\"cell_text_value\"] = self._plot_text(\n            ax, arr, indices, self.default_options\n        )\n\n    if points is not None:\n        row = points[:, 1]\n        col = points[:, 2]\n        optional_display[\"points_scatter\"] = ax.scatter(\n            col, row, color=point_color, s=point_size\n        )\n        optional_display[\"points_id\"] = self._plot_point_values(\n            ax, points, pid_color, pid_size\n        )\n\n    # # Normalize the threshold to the image color range.\n    # if self.default_options[\"background_color_threshold\"] is not None:\n    #     im.norm(self.default_options[\"background_color_threshold\"])\n    # else:\n    #     im.norm(self.vmax) / 2.0\n    plt.show()\n    return fig, ax\n</code></pre>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.plot--plot-appearance","title":"Plot appearance:","text":"<p>title : str, optional     Title of the plot, by default 'Array Plot'. title_size : int, optional     Title font size, by default 15. cmap : str, optional     Colormap name, by default 'coolwarm_r'. vmin : float, optional     Minimum value for color scaling, by default min(array). vmax : float, optional     Maximum value for color scaling, by default max(array).</p>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.plot--color-bar-options","title":"Color bar options:","text":"<p>cbar_orientation : str, optional     Orientation of the color bar, by default 'vertical'.     Can be 'horizontal' or 'vertical'. cbar_label_rotation : float, optional     Rotation angle of the color bar label, by default -90. cbar_label_location : str, optional     Location of the color bar label, by default 'bottom'.     Options: 'top', 'bottom', 'center', 'baseline', 'center_baseline'. cbar_length : float, optional     Ratio to control the height/width of the color bar, by default 0.75. ticks_spacing : int, optional     Spacing between ticks on the color bar, by default 2. cbar_label_size : int, optional     Font size of the color bar label, by default 12. cbar_label : str, optional     Label text for the color bar, by default 'Value'.</p>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.plot--color-scale-options","title":"Color scale options:","text":"<p>color_scale : str, optional     Type of color scaling to use, by default 'linear'.     Options:     - 'linear': Linear scale     - 'power': Power-law normalization     - 'sym-lognorm': Symmetrical logarithmic scale     - 'boundary-norm': Discrete intervals based on boundaries     - 'midpoint': Scale split at a specified midpoint gamma : float, optional     Exponent for 'power' color scale, by default 0.5.     Values &lt; 1 emphasize lower values, values &gt; 1 emphasize higher values. line_threshold : float, optional     Threshold for 'sym-lognorm' color scale, by default 0.0001. line_scale : float, optional     Scale factor for 'sym-lognorm' color scale, by default 0.001. bounds : List, optional     Boundaries for 'boundary-norm' color scale, by default None.     Defines the discrete intervals for color mapping. midpoint : float, optional     Midpoint value for 'midpoint' color scale, by default 0.</p>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.plot--cell-value-display-options","title":"Cell value display options:","text":"<p>display_cell_value : bool, optional     Whether to display the values of cells as text, by default False. num_size : int, optional     Font size of the cell value text, by default 8. background_color_threshold : float, optional     Threshold for cell value text color, by default None.     If cell value &gt; threshold, text is black; otherwise, text is white.     If None, uses max(array)/2 as the threshold.</p>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.prepare_array","title":"<code>prepare_array(array, rgb=None, surface_reflectance=None, cutoff=None, percentile=None)</code>","text":"<p>Prepare an array for RGB visualization.</p> <p>This method processes a multi-band array to create an RGB image suitable for visualization. It can normalize the data using either percentile-based scaling or surface reflectance values.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array containing multiple bands. For RGB visualization, this should be a 3D array where the first dimension represents the bands.</p> required <code>rgb</code> <code>List[int]</code> <p>The indices of the red, green, and blue bands in the given array, by default None. If None, assumes the order is [3, 2, 1] (common for Sentinel-2 data).</p> <code>None</code> <code>surface_reflectance</code> <code>int</code> <p>Surface reflectance value for normalizing satellite data, by default None. Typically 10000 for Sentinel-2 data or 255 for 8-bit imagery. Used to scale values to the range [0, 1].</p> <code>None</code> <code>cutoff</code> <code>List</code> <p>Clip the range of pixel values for each band, by default None. Takes only pixel values from 0 to the value of the cutoff and scales them back to between 0 and 1. Should be a list with one value per band.</p> <code>None</code> <code>percentile</code> <code>int</code> <p>The percentile value to be used for scaling the array values, by default None. Used to enhance contrast by stretching the histogram. If provided, this takes precedence over surface_reflectance.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The prepared array with shape (height, width, 3) suitable for RGB visualization. Values are normalized to the range [0, 1].</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the array shape is incompatible with the provided RGB indices.</p> <p>Examples:</p> <p>Prepare an array using percentile-based scaling: <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from cleopatra.array_glyph import ArrayGlyph\n&gt;&gt;&gt; # Create a 3-band array (e.g., satellite image)\n&gt;&gt;&gt; bands = np.random.randint(0, 10000, size=(3, 100, 100))\n&gt;&gt;&gt; glyph = ArrayGlyph(np.zeros((1, 1)))  # Dummy initialization\n&gt;&gt;&gt; rgb_array = glyph.prepare_array(bands, rgb=[0, 1, 2], percentile=2)\n&gt;&gt;&gt; rgb_array.shape\n(100, 100, 3)\n&gt;&gt;&gt; np.all((0 &lt;= rgb_array) &amp; (rgb_array &lt;= 1))\nTrue\n</code></pre> Prepare an array using surface reflectance normalization: <pre><code>&gt;&gt;&gt; rgb_array = glyph.prepare_array(bands, rgb=[0, 1, 2], surface_reflectance=10000)\n&gt;&gt;&gt; rgb_array.shape\n(100, 100, 3)\n&gt;&gt;&gt; np.all((0 &lt;= rgb_array) &amp; (rgb_array &lt;= 1))\nTrue\n</code></pre> Prepare an array with cutoff values: <pre><code>&gt;&gt;&gt; rgb_array = glyph.prepare_array(\n...     bands, rgb=[0, 1, 2], surface_reflectance=10000, cutoff=[5000, 5000, 5000]\n... )\n&gt;&gt;&gt; rgb_array.shape\n(100, 100, 3)\n&gt;&gt;&gt; np.all((0 &lt;= rgb_array) &amp; (rgb_array &lt;= 1))\nTrue\n</code></pre></p> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>def prepare_array(\n    self,\n    array: np.ndarray,\n    rgb: List[int] = None,\n    surface_reflectance: int = None,\n    cutoff: List = None,\n    percentile: int = None,\n) -&gt; np.ndarray:\n    \"\"\"Prepare an array for RGB visualization.\n\n    This method processes a multi-band array to create an RGB image suitable for visualization.\n    It can normalize the data using either percentile-based scaling or surface reflectance values.\n\n    Parameters\n    ----------\n    array : np.ndarray\n        The input array containing multiple bands. For RGB visualization,\n        this should be a 3D array where the first dimension represents the bands.\n    rgb : List[int], optional\n        The indices of the red, green, and blue bands in the given array, by default None.\n        If None, assumes the order is [3, 2, 1] (common for Sentinel-2 data).\n    surface_reflectance : int, optional\n        Surface reflectance value for normalizing satellite data, by default None.\n        Typically 10000 for Sentinel-2 data or 255 for 8-bit imagery.\n        Used to scale values to the range [0, 1].\n    cutoff : List, optional\n        Clip the range of pixel values for each band, by default None.\n        Takes only pixel values from 0 to the value of the cutoff and scales them back to between 0 and 1.\n        Should be a list with one value per band.\n    percentile : int, optional\n        The percentile value to be used for scaling the array values, by default None.\n        Used to enhance contrast by stretching the histogram.\n        If provided, this takes precedence over surface_reflectance.\n\n    Returns\n    -------\n    np.ndarray\n        The prepared array with shape (height, width, 3) suitable for RGB visualization.\n        Values are normalized to the range [0, 1].\n\n    Raises\n    ------\n    ValueError\n        If the array shape is incompatible with the provided RGB indices.\n\n    Examples\n    --------\n    Prepare an array using percentile-based scaling:\n    ```python\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from cleopatra.array_glyph import ArrayGlyph\n    &gt;&gt;&gt; # Create a 3-band array (e.g., satellite image)\n    &gt;&gt;&gt; bands = np.random.randint(0, 10000, size=(3, 100, 100))\n    &gt;&gt;&gt; glyph = ArrayGlyph(np.zeros((1, 1)))  # Dummy initialization\n    &gt;&gt;&gt; rgb_array = glyph.prepare_array(bands, rgb=[0, 1, 2], percentile=2)\n    &gt;&gt;&gt; rgb_array.shape\n    (100, 100, 3)\n    &gt;&gt;&gt; np.all((0 &lt;= rgb_array) &amp; (rgb_array &lt;= 1))\n    True\n\n    ```\n    Prepare an array using surface reflectance normalization:\n    ```python\n    &gt;&gt;&gt; rgb_array = glyph.prepare_array(bands, rgb=[0, 1, 2], surface_reflectance=10000)\n    &gt;&gt;&gt; rgb_array.shape\n    (100, 100, 3)\n    &gt;&gt;&gt; np.all((0 &lt;= rgb_array) &amp; (rgb_array &lt;= 1))\n    True\n\n    ```\n    Prepare an array with cutoff values:\n    ```python\n    &gt;&gt;&gt; rgb_array = glyph.prepare_array(\n    ...     bands, rgb=[0, 1, 2], surface_reflectance=10000, cutoff=[5000, 5000, 5000]\n    ... )\n    &gt;&gt;&gt; rgb_array.shape\n    (100, 100, 3)\n    &gt;&gt;&gt; np.all((0 &lt;= rgb_array) &amp; (rgb_array &lt;= 1))\n    True\n\n    ```\n    \"\"\"\n    # take the rgb arrays and reorder them to have the red-green-blue, if the order is not given, assume the\n    # order as sentinel data. [3, 2, 1]\n    array = array[rgb].transpose(1, 2, 0)\n\n    if percentile is not None:\n        array = self.scale_percentile(array, percentile=percentile)\n    elif surface_reflectance is not None:\n        array = self._prepare_sentinel_rgb(\n            array,\n            rgb=rgb,\n            surface_reflectance=surface_reflectance,\n            cutoff=cutoff,\n        )\n    return array\n</code></pre>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.save_animation","title":"<code>save_animation(path, fps=2)</code>","text":"<p>Save the animation to a file.</p> <p>This method saves the animation created by the <code>animate</code> method to a file. The format of the output file is determined by the file extension in the path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The file path where the animation will be saved. The file extension determines the output format. Supported formats: gif, mov, avi, mp4.</p> required <code>fps</code> <code>int</code> <p>Frames per second for the saved animation, by default 2. Higher values create faster animations, lower values create slower animations.</p> <code>2</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file extension is not one of the supported formats.</p> <code>FileNotFoundError</code> <p>If FFmpeg is not installed (required for mov, avi, and mp4 formats).</p> Notes <ul> <li>For GIF format, the PillowWriter is used.</li> <li>For MOV, AVI, and MP4 formats, FFMpegWriter is used, which requires FFmpeg to be installed.</li> <li>You can download FFmpeg from https://ffmpeg.org/</li> </ul> <p>Examples:</p> <p>Save an animation as a GIF file: <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from cleopatra.array_glyph import ArrayGlyph\n&gt;&gt;&gt; # Create a 3D array with 5 frames, each 10x10\n&gt;&gt;&gt; arr = np.random.randint(1, 10, size=(5, 10, 10))\n&gt;&gt;&gt; frame_labels = [\"Frame 1\", \"Frame 2\", \"Frame 3\", \"Frame 4\", \"Frame 5\"]\n&gt;&gt;&gt; animated_array = ArrayGlyph(arr)\n&gt;&gt;&gt; anim_obj = animated_array.animate(frame_labels)\n&gt;&gt;&gt; animated_array.save_animation(\"animation.gif\")\n</code></pre> Save with a higher frame rate for a faster animation: <pre><code>&gt;&gt;&gt; animated_array.save_animation(\"animation.gif\", fps=5)\n</code></pre> Save in MP4 format (requires FFmpeg): <pre><code>&gt;&gt;&gt; animated_array.save_animation(\"animation.mp4\", fps=10)\n</code></pre></p> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>def save_animation(self, path: str, fps: int = 2):\n    \"\"\"Save the animation to a file.\n\n    This method saves the animation created by the `animate` method to a file.\n    The format of the output file is determined by the file extension in the path.\n\n    Parameters\n    ----------\n    path : str\n        The file path where the animation will be saved.\n        The file extension determines the output format.\n        Supported formats: gif, mov, avi, mp4.\n    fps : int, optional\n        Frames per second for the saved animation, by default 2.\n        Higher values create faster animations, lower values create slower animations.\n\n    Raises\n    ------\n    ValueError\n        If the file extension is not one of the supported formats.\n    FileNotFoundError\n        If FFmpeg is not installed (required for mov, avi, and mp4 formats).\n\n    Notes\n    -----\n    - For GIF format, the PillowWriter is used.\n    - For MOV, AVI, and MP4 formats, FFMpegWriter is used, which requires FFmpeg to be installed.\n    - You can download FFmpeg from https://ffmpeg.org/\n\n    Examples\n    --------\n    Save an animation as a GIF file:\n    ```python\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from cleopatra.array_glyph import ArrayGlyph\n    &gt;&gt;&gt; # Create a 3D array with 5 frames, each 10x10\n    &gt;&gt;&gt; arr = np.random.randint(1, 10, size=(5, 10, 10))\n    &gt;&gt;&gt; frame_labels = [\"Frame 1\", \"Frame 2\", \"Frame 3\", \"Frame 4\", \"Frame 5\"]\n    &gt;&gt;&gt; animated_array = ArrayGlyph(arr)\n    &gt;&gt;&gt; anim_obj = animated_array.animate(frame_labels)\n    &gt;&gt;&gt; animated_array.save_animation(\"animation.gif\")\n\n    ```\n    Save with a higher frame rate for a faster animation:\n    ```python\n    &gt;&gt;&gt; animated_array.save_animation(\"animation.gif\", fps=5)\n\n    ```\n    Save in MP4 format (requires FFmpeg):\n    ```python\n    &gt;&gt;&gt; animated_array.save_animation(\"animation.mp4\", fps=10)\n\n    ```\n    \"\"\"\n    video_format = path.split(\".\")[-1]\n    if video_format not in SUPPORTED_VIDEO_FORMAT:\n        raise ValueError(\n            f\"The given extension {video_format} implies a format that is not supported, \"\n            f\"only {SUPPORTED_VIDEO_FORMAT} are supported\"\n        )\n\n    if video_format == \"gif\":\n        writer_gif = animation.PillowWriter(fps=fps)\n        self.anim.save(path, writer=writer_gif)\n    else:\n        try:\n            if video_format == \"avi\" or video_format == \"mov\":\n                writer_video = animation.FFMpegWriter(fps=fps, bitrate=1800)\n                self.anim.save(path, writer=writer_video)\n            elif video_format == \"mp4\":\n                writer_mp4 = animation.FFMpegWriter(fps=fps, bitrate=1800)\n                self.anim.save(path, writer=writer_mp4)\n        except FileNotFoundError:\n            print(\n                \"Please visit https://ffmpeg.org/ and download a version of ffmpeg compatible with your operating\"\n                \"system, for more details please check the method definition\"\n            )\n</code></pre>"},{"location":"api/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.scale_percentile","title":"<code>scale_percentile(arr, percentile=1)</code>  <code>staticmethod</code>","text":"<p>Scale an array using percentile-based contrast stretching.</p> <p>This method enhances the contrast of an image by stretching the histogram based on percentile values. It calculates the lower and upper percentile values for each band and normalizes the data to the range [0, 1].</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>ndarray</code> <p>The array to be scaled, with shape (height, width, bands). Typically an RGB image with 3 bands.</p> required <code>percentile</code> <code>int</code> <p>The percentile value to be used for scaling, by default 1. This value determines how much of the histogram tails to exclude. Higher values result in more contrast stretching. Typical values range from 1 to 5.</p> <code>1</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The scaled array, normalized between 0 and 1, with the same shape as input. Data type is float32.</p> Notes <p>The method works by: 1. Computing the lower percentile value for each band 2. Computing the upper percentile value (100 - percentile) for each band 3. Normalizing each band using these percentile values 4. Clipping values to the range [0, 1]</p> <p>This is particularly useful for visualizing satellite imagery with high dynamic range.</p> <p>Examples:</p> <p>Scale a single-band array: <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from cleopatra.array_glyph import ArrayGlyph\n&gt;&gt;&gt; # Create a test array with values between 0 and 10000\n&gt;&gt;&gt; test_array = np.random.randint(0, 10000, size=(100, 100, 1))\n&gt;&gt;&gt; scaled = ArrayGlyph.scale_percentile(test_array, percentile=2)\n&gt;&gt;&gt; scaled.shape\n(100, 100, 1)\n&gt;&gt;&gt; np.all((0 &lt;= scaled) &amp; (scaled &lt;= 1))\nnp.True_\n</code></pre> Scale an RGB array: <pre><code>&gt;&gt;&gt; rgb_array = np.random.randint(0, 10000, size=(100, 100, 3))\n&gt;&gt;&gt; scaled = ArrayGlyph.scale_percentile(rgb_array, percentile=2)\n&gt;&gt;&gt; scaled.shape\n(100, 100, 3)\n&gt;&gt;&gt; np.all((0 &lt;= scaled) &amp; (scaled &lt;= 1))\nnp.True_\n</code></pre> Using different percentile values affects contrast: <pre><code>&gt;&gt;&gt; low_contrast = ArrayGlyph.scale_percentile(rgb_array, percentile=1)\n&gt;&gt;&gt; high_contrast = ArrayGlyph.scale_percentile(rgb_array, percentile=5)\n&gt;&gt;&gt; # Higher percentile typically results in higher contrast\n</code></pre></p> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>@staticmethod\ndef scale_percentile(arr: np.ndarray, percentile: int = 1) -&gt; np.ndarray:\n    \"\"\"Scale an array using percentile-based contrast stretching.\n\n    This method enhances the contrast of an image by stretching the histogram\n    based on percentile values. It calculates the lower and upper percentile values\n    for each band and normalizes the data to the range [0, 1].\n\n    Parameters\n    ----------\n    arr : np.ndarray\n        The array to be scaled, with shape (height, width, bands).\n        Typically an RGB image with 3 bands.\n    percentile : int, optional\n        The percentile value to be used for scaling, by default 1.\n        This value determines how much of the histogram tails to exclude.\n        Higher values result in more contrast stretching.\n        Typical values range from 1 to 5.\n\n    Returns\n    -------\n    np.ndarray\n        The scaled array, normalized between 0 and 1, with the same shape as input.\n        Data type is float32.\n\n    Notes\n    -----\n    The method works by:\n    1. Computing the lower percentile value for each band\n    2. Computing the upper percentile value (100 - percentile) for each band\n    3. Normalizing each band using these percentile values\n    4. Clipping values to the range [0, 1]\n\n    This is particularly useful for visualizing satellite imagery with high dynamic range.\n\n    Examples\n    --------\n    Scale a single-band array:\n    ```python\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from cleopatra.array_glyph import ArrayGlyph\n    &gt;&gt;&gt; # Create a test array with values between 0 and 10000\n    &gt;&gt;&gt; test_array = np.random.randint(0, 10000, size=(100, 100, 1))\n    &gt;&gt;&gt; scaled = ArrayGlyph.scale_percentile(test_array, percentile=2)\n    &gt;&gt;&gt; scaled.shape\n    (100, 100, 1)\n    &gt;&gt;&gt; np.all((0 &lt;= scaled) &amp; (scaled &lt;= 1))\n    np.True_\n\n    ```\n    Scale an RGB array:\n    ```python\n    &gt;&gt;&gt; rgb_array = np.random.randint(0, 10000, size=(100, 100, 3))\n    &gt;&gt;&gt; scaled = ArrayGlyph.scale_percentile(rgb_array, percentile=2)\n    &gt;&gt;&gt; scaled.shape\n    (100, 100, 3)\n    &gt;&gt;&gt; np.all((0 &lt;= scaled) &amp; (scaled &lt;= 1))\n    np.True_\n\n    ```\n    Using different percentile values affects contrast:\n    ```python\n    &gt;&gt;&gt; low_contrast = ArrayGlyph.scale_percentile(rgb_array, percentile=1)\n    &gt;&gt;&gt; high_contrast = ArrayGlyph.scale_percentile(rgb_array, percentile=5)\n    &gt;&gt;&gt; # Higher percentile typically results in higher contrast\n\n    ```\n    \"\"\"\n    rows, columns, bands = arr.shape\n    # flatten image.\n    arr = np.reshape(arr, [rows * columns, bands]).astype(np.float32)\n    # lower percentile values (one value for each band).\n    lower_percent = np.percentile(arr, percentile, axis=0)\n    # 98 percentile values.\n    upper_percent = np.percentile(arr, 100 - percentile, axis=0) - lower_percent\n    # normalize the 3 bands using the percentile values for each band.\n    arr = (arr - lower_percent[None, :]) / upper_percent[None, :]\n    arr = np.reshape(arr, [rows, columns, bands])\n    # discard outliers.\n    arr = arr.clip(0, 1)\n\n    return arr\n</code></pre>"},{"location":"api/array-glyph-class/#examples","title":"Examples","text":""},{"location":"api/array-glyph-class/#basic-array-plot","title":"Basic Array Plot","text":"<pre><code>import numpy as np\nfrom cleopatra.array_glyph import ArrayGlyph\n\n# Create a sample array\narray = np.random.rand(10, 10)\n\n# Create an ArrayGlyph object\narray_glyph = ArrayGlyph(array)\n\n# Plot the array\nfig, ax, im, cbar = array_glyph.plot()\n</code></pre>"},{"location":"api/array-glyph-class/#display-cell-values","title":"Display Cell Values","text":"<pre><code># Plot the array with cell values displayed\nfig, ax, im, cbar = array_glyph.plot(display_cell_values=True)\n</code></pre>"},{"location":"api/array-glyph-class/#display-points","title":"Display Points","text":"<pre><code># Create some points to display on the array\npoints = np.array([[2, 3, 1], [5, 7, 2], [8, 1, 3]])\n\n# Plot the array with points\nfig, ax, im, cbar = array_glyph.plot(points=points)\n</code></pre>"},{"location":"api/array-glyph-class/#animation","title":"Animation","text":"<pre><code>import numpy as np\nfrom cleopatra.array_glyph import ArrayGlyph\n\n# Create a time series of arrays\ntime_series = [np.random.rand(10, 10) for _ in range(5)]\ntime_labels = [\"t1\", \"t2\", \"t3\", \"t4\", \"t5\"]\n\n# Create an ArrayGlyph object with the first array\narray_glyph = ArrayGlyph(time_series[0])\n\n# Animate the array over time\nanim = array_glyph.animate(time=time_labels, points=points)\n\n# Save the animation\narray_glyph.save_animation(\"animation.gif\", fps=2)\n</code></pre>"},{"location":"api/colors-class/","title":"Colors Class","text":"<p>The <code>Colors</code> class provides functionality for working with colors, including converting between different color formats (hex, RGB), validating color values, and getting the type of color.</p>"},{"location":"api/colors-class/#class-documentation","title":"Class Documentation","text":""},{"location":"api/colors-class/#cleopatra.colors.Colors","title":"<code>cleopatra.colors.Colors</code>","text":"<p>A class for handling and converting between different color formats.</p> <p>The Colors class provides functionality for working with different color formats including hexadecimal colors, RGB colors (normalized between 0 and 1), and RGB colors (with values between 0 and 255). It supports validation, conversion, and manipulation of colors.</p> <p>Attributes:</p> Name Type Description <code>color_value</code> <code>Union[List[str], List[Tuple[float, float, float]]]</code> <p>The color values stored in the class, can be hex strings or RGB tuples.</p> <p>Methods:</p> Name Description <code>get_type</code> <p>Determine the type of each color (hex, rgb, rgb-normalized).</p> <code>to_hex</code> <p>Convert all colors to hexadecimal format.</p> <code>to_rgb</code> <p>Convert all colors to RGB format.</p> <code>is_valid_hex</code> <p>Check if each color is a valid hex color.</p> <code>is_valid_rgb</code> <p>Check if each color is a valid RGB color.</p> <p>Examples:</p> <p>Create a Colors object with a hex color: <pre><code>&gt;&gt;&gt; from cleopatra.colors import Colors\n&gt;&gt;&gt; hex_color = Colors(\"#ff0000\")\n&gt;&gt;&gt; hex_color.color_value\n['#ff0000']\n&gt;&gt;&gt; hex_color.get_type()\n['hex']\n</code></pre></p> <p>Create a Colors object with an RGB color (values between 0 and 1): <pre><code>&gt;&gt;&gt; rgb_norm = Colors((0.5, 0.2, 0.8))\n&gt;&gt;&gt; rgb_norm.color_value\n[(0.5, 0.2, 0.8)]\n&gt;&gt;&gt; rgb_norm.get_type()\n['rgb-normalized']\n</code></pre></p> <p>Create a Colors object with an RGB color (values between 0 and 255): <pre><code>&gt;&gt;&gt; rgb_255 = Colors((128, 51, 204))\n&gt;&gt;&gt; rgb_255.color_value\n[(128, 51, 204)]\n&gt;&gt;&gt; rgb_255.get_type()\n['rgb']\n</code></pre></p> <p>Convert between color formats: <pre><code>&gt;&gt;&gt; hex_color.to_rgb()  # Convert hex to RGB (normalized)\n[(1.0, 0.0, 0.0)]\n&gt;&gt;&gt; rgb_norm.to_hex()  # Convert RGB to hex\n['#8033cc']\n</code></pre></p> Source code in <code>cleopatra/colors.py</code> <pre><code>class Colors:\n    \"\"\"A class for handling and converting between different color formats.\n\n    The Colors class provides functionality for working with different color formats\n    including hexadecimal colors, RGB colors (normalized between 0 and 1), and\n    RGB colors (with values between 0 and 255). It supports validation, conversion,\n    and manipulation of colors.\n\n    Attributes\n    ----------\n    color_value : Union[List[str], List[Tuple[float, float, float]]]\n        The color values stored in the class, can be hex strings or RGB tuples.\n\n    Methods\n    -------\n    get_type()\n        Determine the type of each color (hex, rgb, rgb-normalized).\n    to_hex()\n        Convert all colors to hexadecimal format.\n    to_rgb(normalized=True)\n        Convert all colors to RGB format.\n    is_valid_hex()\n        Check if each color is a valid hex color.\n    is_valid_rgb()\n        Check if each color is a valid RGB color.\n\n    Examples\n    --------\n    Create a Colors object with a hex color:\n    ```python\n    &gt;&gt;&gt; from cleopatra.colors import Colors\n    &gt;&gt;&gt; hex_color = Colors(\"#ff0000\")\n    &gt;&gt;&gt; hex_color.color_value\n    ['#ff0000']\n    &gt;&gt;&gt; hex_color.get_type()\n    ['hex']\n\n    ```\n\n    Create a Colors object with an RGB color (values between 0 and 1):\n    ```python\n    &gt;&gt;&gt; rgb_norm = Colors((0.5, 0.2, 0.8))\n    &gt;&gt;&gt; rgb_norm.color_value\n    [(0.5, 0.2, 0.8)]\n    &gt;&gt;&gt; rgb_norm.get_type()\n    ['rgb-normalized']\n\n    ```\n\n    Create a Colors object with an RGB color (values between 0 and 255):\n    ```python\n    &gt;&gt;&gt; rgb_255 = Colors((128, 51, 204))\n    &gt;&gt;&gt; rgb_255.color_value\n    [(128, 51, 204)]\n    &gt;&gt;&gt; rgb_255.get_type()\n    ['rgb']\n\n    ```\n\n    Convert between color formats:\n    ```python\n    &gt;&gt;&gt; hex_color.to_rgb()  # Convert hex to RGB (normalized)\n    [(1.0, 0.0, 0.0)]\n    &gt;&gt;&gt; rgb_norm.to_hex()  # Convert RGB to hex\n    ['#8033cc']\n\n    ```\n    \"\"\"\n\n    def __init__(\n        self,\n        color_value: Union[\n            List[str], str, Tuple[float, float, float], List[Tuple[float, float, float]]\n        ],\n    ):\n        \"\"\"Initialize a Colors object with the given color value(s).\n\n        Parameters\n        ----------\n        color_value : Union[List[str], str, Tuple[float, float, float], List[Tuple[float, float, float]]]\n            The color value(s) to initialize the object with. Can be:\n            - A single hex color string (e.g., \"#ff0000\" or \"ff0000\")\n            - A single RGB tuple with values between 0-1 (e.g., (1.0, 0.0, 0.0))\n            - A single RGB tuple with values between 0-255 (e.g., (255, 0, 0))\n            - A list of hex color strings\n            - A list of RGB tuples\n\n        Raises\n        ------\n        ValueError\n            If the color_value is not a string, tuple, or list of strings/tuples.\n\n        Notes\n        -----\n        - Hex colors can be provided with or without the leading \"#\"\n        - RGB tuples with float values between 0-1 are treated as normalized RGB\n        - RGB tuples with integer values between 0-255 are treated as standard RGB\n        - The class automatically detects the type of color format provided\n\n        Examples\n        --------\n        Initialize with a hex color:\n        ```python\n        &gt;&gt;&gt; from cleopatra.colors import Colors\n        &gt;&gt;&gt; # With hash symbol\n        &gt;&gt;&gt; color1 = Colors(\"#ff0000\")\n        &gt;&gt;&gt; color1.color_value\n        ['#ff0000']\n        &gt;&gt;&gt; # Without hash symbol\n        &gt;&gt;&gt; color2 = Colors(\"ff0000\")\n        &gt;&gt;&gt; color2.color_value\n        ['ff0000']\n\n        ```\n\n        Initialize with an RGB color (normalized, values between 0 and 1):\n        ```python\n        &gt;&gt;&gt; rgb_norm = Colors((1.0, 0.0, 0.0))\n        &gt;&gt;&gt; rgb_norm.color_value\n        [(1.0, 0.0, 0.0)]\n        &gt;&gt;&gt; rgb_norm.get_type()\n        ['rgb-normalized']\n\n        ```\n\n        Initialize with an RGB color (values between 0 and 255):\n        ```python\n        &gt;&gt;&gt; rgb_255 = Colors((255, 0, 0))\n        &gt;&gt;&gt; rgb_255.color_value\n        [(255, 0, 0)]\n        &gt;&gt;&gt; rgb_255.get_type()\n        ['rgb']\n\n        ```\n\n        Initialize with a list of colors:\n        ```python\n        &gt;&gt;&gt; mixed_colors = Colors([\"#ff0000\", (0, 255, 0), (0.0, 0.0, 1.0)])\n        &gt;&gt;&gt; mixed_colors.color_value\n        ['#ff0000', (0, 255, 0), (0.0, 0.0, 1.0)]\n        &gt;&gt;&gt; mixed_colors.get_type()\n        ['hex', 'rgb', 'rgb-normalized']\n\n        ```\n        \"\"\"\n        # convert the hex color to a list if it is a string\n        if isinstance(color_value, str) or isinstance(color_value, tuple):\n            color_value = [color_value]\n        elif not isinstance(color_value, list):\n            raise ValueError(\n                \"The color_value must be a list of hex colors, list of tuples (RGB color), a single hex \"\n                \"or single RGB tuple color.\"\n            )\n\n        self._color_value = color_value\n\n    def get_type(self) -&gt; List[str]:\n        \"\"\"Determine the type of each color value.\n\n        This method analyzes each color value stored in the object and determines\n        its type: hex, rgb (values 0-255), or rgb-normalized (values 0-1).\n\n        Returns\n        -------\n        List[str]\n            A list of strings indicating the type of each color value.\n            Possible values are:\n            - 'hex': Hexadecimal color string\n            - 'rgb': RGB tuple with values between 0-255\n            - 'rgb-normalized': RGB tuple with values between 0-1\n\n        Notes\n        -----\n        The method uses the following criteria to determine color types:\n        - If the value is a string and is a valid hex color, it's classified as 'hex'\n        - If the value is a tuple of 3 floats between 0-1, it's classified as 'rgb-normalized'\n        - If the value is a tuple of 3 integers between 0-255, it's classified as 'rgb'\n\n        Examples\n        --------\n        Determine the type of a hex color:\n        ```python\n        &gt;&gt;&gt; from cleopatra.colors import Colors\n        &gt;&gt;&gt; hex_color = Colors(\"#23a9dd\")\n        &gt;&gt;&gt; hex_color.get_type()\n        ['hex']\n\n        ```\n\n        Determine the type of an RGB color with normalized values (0-1):\n        ```python\n        &gt;&gt;&gt; rgb_norm = Colors((0.5, 0.2, 0.8))\n        &gt;&gt;&gt; rgb_norm.get_type()\n        ['rgb-normalized']\n\n        ```\n\n        Determine the type of an RGB color with values between 0-255:\n        ```python\n        &gt;&gt;&gt; rgb_255 = Colors((128, 51, 204))\n        &gt;&gt;&gt; rgb_255.get_type()\n        ['rgb']\n\n        ```\n\n        Determine types of mixed color formats:\n        ```python\n        &gt;&gt;&gt; mixed = Colors([\"#ff0000\", (0, 255, 0), (0.0, 0.0, 1.0)])\n        &gt;&gt;&gt; mixed.get_type()\n        ['hex', 'rgb', 'rgb-normalized']\n\n        ```\n        \"\"\"\n        color_type = []\n        for color_i in self.color_value:\n            if self.is_valid_rgb_norm(color_i):\n                color_type.append(\"rgb-normalized\")\n            elif self.is_valid_rgb_255(color_i):\n                color_type.append(\"rgb\")\n            elif self.is_valid_hex_i(color_i):\n                color_type.append(\"hex\")\n\n        return color_type\n\n    @property\n    def color_value(self) -&gt; Union[List[str], List[Tuple[float, float, float]]]:\n        \"\"\"Get the color values stored in the object.\n\n        This property returns the color values that were provided when initializing\n        the Colors object or set afterwards. The values can be hex color strings,\n        RGB tuples with values between 0-255, or normalized RGB tuples with values\n        between 0-1.\n\n        Returns\n        -------\n        Union[List[str], List[Tuple[float, float, float]]]\n            A list containing the color values. Each element can be:\n            - A hex color string (e.g., \"#ff0000\" or \"ff0000\")\n            - An RGB tuple with values between 0-255 (e.g., (255, 0, 0))\n            - A normalized RGB tuple with values between 0-1 (e.g., (1.0, 0.0, 0.0))\n\n        Examples\n        --------\n        Get color values from a Colors object with hex colors:\n        ```python\n        &gt;&gt;&gt; from cleopatra.colors import Colors\n        &gt;&gt;&gt; hex_colors = Colors([\"#ff0000\", \"#00ff00\", \"#0000ff\"])\n        &gt;&gt;&gt; hex_colors.color_value\n        ['#ff0000', '#00ff00', '#0000ff']\n\n        ```\n\n        Get color values from a Colors object with RGB colors:\n        ```python\n        &gt;&gt;&gt; rgb_colors = Colors([(255, 0, 0), (0, 255, 0), (0, 0, 255)])\n        &gt;&gt;&gt; rgb_colors.color_value\n        [(255, 0, 0), (0, 255, 0), (0, 0, 255)]\n\n        ```\n        Get color values from a Colors object with mixed color formats:\n        ```python\n        &gt;&gt;&gt; mixed = Colors([\"#ff0000\", (0, 255, 0), (0.0, 0.0, 1.0)])\n        &gt;&gt;&gt; mixed.color_value\n        ['#ff0000', (0, 255, 0), (0.0, 0.0, 1.0)]\n\n        ```\n        \"\"\"\n        return self._color_value\n\n    def to_hex(self) -&gt; List[str]:\n        \"\"\"Convert all color values to hexadecimal format.\n\n        This method converts all color values stored in the object to hexadecimal format.\n        RGB tuples (both normalized and 0-255 range) are converted to their hex equivalents.\n        Hex colors remain unchanged.\n\n        Returns\n        -------\n        List[str]\n            A list of hexadecimal color strings. Each string is in the format '#RRGGBB'.\n\n        Notes\n        -----\n        - RGB tuples with values between 0-255 are first normalized to 0-1 range before conversion\n        - RGB tuples with values already between 0-1 are directly converted\n        - Existing hex colors are returned as-is\n        - All returned hex colors include the leading '#' character\n\n        Examples\n        --------\n        Convert RGB colors to hex:\n        ```python\n        &gt;&gt;&gt; from cleopatra.colors import Colors\n        &gt;&gt;&gt; # RGB colors (0-255 range)\n        &gt;&gt;&gt; rgb_255 = Colors([(255, 0, 0), (0, 255, 0), (0, 0, 255)])\n        &gt;&gt;&gt; rgb_255.to_hex()\n        ['#ff0000', '#00ff00', '#0000ff']\n\n        ```\n        &gt;&gt;&gt; # RGB colors (normalized 0-1 range)\n        &gt;&gt;&gt; rgb_norm = Colors([(1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)])\n        &gt;&gt;&gt; rgb_norm.to_hex()\n        ['#ff0000', '#00ff00', '#0000ff']\n\n        ```\n        Convert a mix of color formats to hex:\n        ```python\n        &gt;&gt;&gt; mixed = Colors([(128, 51, 204), \"#23a9dd\", (0.5, 0.2, 0.8)])\n        &gt;&gt;&gt; mixed.to_hex()\n        ['#8033cc', '#23a9dd', '#8033cc']\n\n        ```\n        Hex colors are returned as-is:\n        ```python\n        &gt;&gt;&gt; hex_colors = Colors([\"#ff0000\", \"#00ff00\", \"#0000ff\"])\n        &gt;&gt;&gt; hex_colors.to_hex()\n        ['#ff0000', '#00ff00', '#0000ff']\n\n        ```\n        \"\"\"\n        converted_color = []\n        color_type = self.get_type()\n        for ind, color_i in enumerate(self.color_value):\n            if color_type[ind] == \"hex\":\n                converted_color.append(color_i)\n            elif color_type[ind] == \"rgb\":\n                # Normalize the RGB values to be between 0 and 1\n                rgb_color_normalized = tuple(value / 255 for value in color_i)\n                converted_color.append(mcolors.to_hex(rgb_color_normalized))\n            else:\n                converted_color.append(mcolors.to_hex(color_i))\n        return converted_color\n\n    def is_valid_hex(self) -&gt; List[bool]:\n        \"\"\"Check if each color value is a valid hexadecimal color.\n\n        This method checks each color value stored in the object to determine\n        if it is a valid hexadecimal color string.\n\n        Returns\n        -------\n        List[bool]\n            A list of boolean values, one for each color value in the object.\n            True indicates the color is a valid hex color, False otherwise.\n\n        Notes\n        -----\n        - The method uses matplotlib's is_color_like function to validate hex colors\n        - Both formats with and without the leading '#' are supported\n        - RGB tuples will return False as they are not hex colors\n\n        Examples\n        --------\n        Check if hex colors are valid:\n        ```python\n        &gt;&gt;&gt; from cleopatra.colors import Colors\n        &gt;&gt;&gt; hex_colors = Colors([\"#ff0000\", \"#00ff00\", \"#0000ff\"])\n        &gt;&gt;&gt; hex_colors.is_valid_hex()\n        [True, True, True]\n\n        ```\n        Check if RGB colors are valid hex colors (they're not):\n        ```python\n        &gt;&gt;&gt; rgb_colors = Colors([(255, 0, 0), (0, 255, 0), (0, 0, 255)])\n        &gt;&gt;&gt; rgb_colors.is_valid_hex()\n        [False, False, False]\n\n        ```\n        Check a mix of color formats:\n        ```python\n        &gt;&gt;&gt; mixed = Colors([\"#ff0000\", (0, 255, 0), \"not-a-color\"])\n        &gt;&gt;&gt; mixed.is_valid_hex()\n        [True, False, False]\n\n        ```\n        \"\"\"\n        return [self.is_valid_hex_i(col) for col in self.color_value]\n\n    @staticmethod\n    def is_valid_hex_i(hex_color: str) -&gt; bool:\n        \"\"\"Check if a single color value is a valid hexadecimal color.\n\n        This static method checks if the provided color value is a valid\n        hexadecimal color string.\n\n        Parameters\n        ----------\n        hex_color : str\n            A color string to validate as a hexadecimal color.\n            Can be in the format \"#RRGGBB\" or \"RRGGBB\".\n\n        Returns\n        -------\n        bool\n            True if the color is a valid hexadecimal color, False otherwise.\n\n        Notes\n        -----\n        - The method uses matplotlib's is_color_like function to validate hex colors\n        - Both formats with and without the leading '#' are supported\n        - Non-string values will return False\n\n        Examples\n        --------\n        Check valid hex colors:\n        ```python\n        &gt;&gt;&gt; from cleopatra.colors import Colors\n        &gt;&gt;&gt; Colors.is_valid_hex_i(\"#ff0000\")\n        True\n        &gt;&gt;&gt; Colors.is_valid_hex_i(\"00ff00\")\n        False\n        &gt;&gt;&gt; Colors.is_valid_hex_i(\"#0000FF\")\n        True\n\n        ```\n\n        Check invalid hex colors:\n        ```python\n        &gt;&gt;&gt; Colors.is_valid_hex_i(\"not-a-color\")\n        False\n        &gt;&gt;&gt; Colors.is_valid_hex_i(\"#12345\")  # Too short\n        False\n        &gt;&gt;&gt; Colors.is_valid_hex_i((255, 0, 0))  # doctest: +ELLIPSIS\n        False\n\n        ```\n        \"\"\"\n        return True if mcolors.is_color_like(hex_color) else False\n\n    def is_valid_rgb(self) -&gt; List[bool]:\n        \"\"\"Check if each color value is a valid RGB color.\n\n        This method checks each color value stored in the object to determine\n        if it is a valid RGB color tuple (either with values between 0-255 or\n        normalized values between 0-1).\n\n        Returns\n        -------\n        List[bool]\n            A list of boolean values, one for each color value in the object.\n            True indicates the color is a valid RGB tuple, False otherwise.\n\n        Notes\n        -----\n        - The method checks for both RGB formats: values between 0-255 and normalized values between 0-1\n        - A valid RGB tuple must have exactly 3 values (R, G, B)\n        - Hex color strings will return False as they are not RGB tuples\n\n        Examples\n        --------\n        Check if RGB colors are valid:\n        ```python\n        &gt;&gt;&gt; from cleopatra.colors import Colors\n        &gt;&gt;&gt; # RGB colors (0-255 range)\n        &gt;&gt;&gt; rgb_255 = Colors([(255, 0, 0), (0, 255, 0), (0, 0, 255)])\n        &gt;&gt;&gt; rgb_255.is_valid_rgb()\n        [True, True, True]\n\n        &gt;&gt;&gt; # RGB colors (normalized 0-1 range)\n        &gt;&gt;&gt; rgb_norm = Colors([(1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)])\n        &gt;&gt;&gt; rgb_norm.is_valid_rgb()\n        [True, True, True]\n\n        ```\n        Check if hex colors are valid RGB colors (they're not):\n        ```python\n        &gt;&gt;&gt; hex_colors = Colors([\"#ff0000\", \"#00ff00\", \"#0000ff\"])\n        &gt;&gt;&gt; hex_colors.is_valid_rgb()\n        [False, False, False]\n\n        ```\n        Check a mix of color formats:\n        ```python\n        &gt;&gt;&gt; mixed = Colors([(255, 0, 0), \"#00ff00\", (0.0, 0.0, 1.0)])\n        &gt;&gt;&gt; mixed.is_valid_rgb()\n        [True, False, True]\n\n        ```\n        \"\"\"\n        return [\n            self.is_valid_rgb_norm(col) or self.is_valid_rgb_255(col)\n            for col in self.color_value\n        ]\n\n    @staticmethod\n    def is_valid_rgb_255(rgb_tuple: Any) -&gt; bool:\n        \"\"\"Check if a single color value is a valid RGB tuple with values between 0-255.\n\n        This static method checks if the provided value is a valid RGB tuple with\n        integer values between 0 and 255.\n\n        Parameters\n        ----------\n        rgb_tuple : Any\n            The value to check. Should be a tuple of 3 integers between 0 and 255\n            to be considered valid.\n\n        Returns\n        -------\n        bool\n            True if the value is a valid RGB tuple with values between 0-255,\n            False otherwise.\n\n        Examples\n        --------\n        Check valid RGB tuples (0-255 range):\n        ```python\n        &gt;&gt;&gt; from cleopatra.colors import Colors\n        &gt;&gt;&gt; Colors.is_valid_rgb_255((255, 0, 0))\n        True\n        &gt;&gt;&gt; Colors.is_valid_rgb_255((128, 64, 32))\n        True\n        &gt;&gt;&gt; Colors.is_valid_rgb_255((0, 0, 0))\n        True\n\n        ```\n        Check invalid RGB tuples:\n        ```python\n        &gt;&gt;&gt; Colors.is_valid_rgb_255((1.0, 0.0, 0.0))  # Floats, not integers\n        False\n        &gt;&gt;&gt; Colors.is_valid_rgb_255((256, 0, 0))  # Value &gt; 255\n        False\n        &gt;&gt;&gt; Colors.is_valid_rgb_255((0, 0))  # Not 3 values\n        False\n        &gt;&gt;&gt; Colors.is_valid_rgb_255(\"#ff0000\")  # Not a tuple\n        False\n\n        ```\n        \"\"\"\n        if isinstance(rgb_tuple, tuple) and len(rgb_tuple) == 3:\n            if all(isinstance(value, int) for value in rgb_tuple):\n                return all(0 &lt;= value &lt;= 255 for value in rgb_tuple)\n        return False\n\n    @staticmethod\n    def is_valid_rgb_norm(rgb_tuple: Any) -&gt; bool:\n        \"\"\"Check if a single color value is a valid normalized RGB tuple with values between 0-1.\n\n        This static method checks if the provided value is a valid RGB tuple with\n        float values between 0.0 and 1.0.\n\n        Parameters\n        ----------\n        rgb_tuple : Any\n            The value to check. Should be a tuple of 3 floats between 0.0 and 1.0\n            to be considered valid.\n\n        Returns\n        -------\n        bool\n            True if the value is a valid normalized RGB tuple with values between 0.0-1.0,\n            False otherwise.\n\n        Examples\n        --------\n        Check valid normalized RGB tuples:\n        ```python\n        &gt;&gt;&gt; from cleopatra.colors import Colors\n        &gt;&gt;&gt; Colors.is_valid_rgb_norm((1.0, 0.0, 0.0))\n        True\n        &gt;&gt;&gt; Colors.is_valid_rgb_norm((0.5, 0.5, 0.5))\n        True\n        &gt;&gt;&gt; Colors.is_valid_rgb_norm((0.0, 0.0, 0.0))\n        True\n\n        ```\n        Check invalid normalized RGB tuples:\n        ```python\n        &gt;&gt;&gt; Colors.is_valid_rgb_norm((255, 0, 0))  # Integers, not floats\n        False\n        &gt;&gt;&gt; Colors.is_valid_rgb_norm((1.2, 0.0, 0.0))  # Value &gt; 1.0\n        False\n        &gt;&gt;&gt; Colors.is_valid_rgb_norm((0.5, 0.5))  # Not 3 values\n        False\n        &gt;&gt;&gt; Colors.is_valid_rgb_norm(\"#ff0000\")  # Not a tuple\n        False\n\n        ```\n        \"\"\"\n        if isinstance(rgb_tuple, tuple) and len(rgb_tuple) == 3:\n            if all(isinstance(value, float) for value in rgb_tuple):\n                return all(0.0 &lt;= value &lt;= 1.0 for value in rgb_tuple)\n        return False\n\n    def to_rgb(\n        self, normalized: bool = True\n    ) -&gt; List[Tuple[Union[int, float], Union[int, float], Union[int, float]]]:\n        \"\"\"Convert all color values to RGB format.\n\n        This method converts all color values stored in the object to RGB format.\n        Hex colors are converted to their RGB equivalents. RGB colors remain unchanged\n        but may be normalized or denormalized based on the 'normalized' parameter.\n\n        Parameters\n        ----------\n        normalized : bool, optional\n            Whether to return normalized RGB values (between 0 and 1) or standard RGB values\n            (between 0 and 255), by default True.\n            - If True, returns RGB values scaled between 0 and 1\n            - If False, returns RGB values scaled between 0 and 255\n\n        Returns\n        -------\n        List[Tuple[Union[int, float], Union[int, float], Union[int, float]]]\n            A list of RGB tuples. Each tuple contains three values (R, G, B).\n            - If normalized=True, values are floats between 0.0 and 1.0\n            - If normalized=False, values are integers between 0 and 255\n\n        Examples\n        --------\n        Convert hex colors to normalized RGB (0-1 range):\n        ```python\n        &gt;&gt;&gt; from cleopatra.colors import Colors\n        &gt;&gt;&gt; hex_colors = Colors([\"#ff0000\", \"#00ff00\", \"#0000ff\"])\n        &gt;&gt;&gt; hex_colors.to_rgb(normalized=True)\n        [(1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)]\n\n        Convert hex colors to standard RGB (0-255 range):\n        ```python\n        &gt;&gt;&gt; hex_colors.to_rgb(normalized=False)\n        [(255, 0, 0), (0, 255, 0), (0, 0, 255)]\n\n        ```\n        Convert RGB colors and maintain their format:\n        ```python\n        &gt;&gt;&gt; rgb_255 = Colors([(255, 0, 0), (0, 255, 0)])\n        &gt;&gt;&gt; rgb_255.to_rgb(normalized=False)  # Keep as 0-255 range\n        [(255, 0, 0), (0, 255, 0)]\n        &gt;&gt;&gt; rgb_255.to_rgb(normalized=True)  # Convert to 0-1 range\n        [(1.0, 0.0, 0.0), (0.0, 1.0, 0.0)]\n\n        &gt;&gt;&gt; rgb_norm = Colors([(1.0, 0.0, 0.0), (0.0, 1.0, 0.0)])\n        &gt;&gt;&gt; rgb_norm.to_rgb(normalized=True)  # Keep as 0-1 range\n        [(1.0, 0.0, 0.0), (0.0, 1.0, 0.0)]\n        &gt;&gt;&gt; rgb_norm.to_rgb(normalized=False)  # Convert to 0-255 range\n        [(255, 0, 0), (0, 255, 0)]\n\n        ```\n        Convert mixed color formats:\n        ```python\n        &gt;&gt;&gt; mixed = Colors([\"#ff0000\", (0, 255, 0), (0.0, 0.0, 1.0)])\n        &gt;&gt;&gt; mixed.to_rgb(normalized=True)\n        [(1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)]\n\n        ```\n        \"\"\"\n        color_type = self.get_type()\n        rgb = []\n        if normalized:\n            for ind, color_i in enumerate(self.color_value):\n                # if the color is in RGB format (0-255), normalize the values to be between 0 and 1\n                if color_type[ind] == \"rgb\":\n                    rgb_color_normalized = tuple(value / 255 for value in color_i)\n                    rgb.append(rgb_color_normalized)\n                else:\n                    # any other format, just convert it to RGB\n                    rgb.append(mcolors.to_rgb(color_i))\n        else:\n            for ind, color_i in enumerate(self.color_value):\n                # if the color is in RGB format (0-255), normalize the values to be between 0 and 1\n                if color_type[ind] == \"rgb\":\n                    rgb.append(color_i)\n                else:\n                    # any other format, just convert it to RGB\n                    rgb.append(tuple([int(c * 255) for c in mcolors.to_rgb(color_i)]))\n\n        return rgb\n</code></pre>"},{"location":"api/colors-class/#cleopatra.colors.Colors.color_value","title":"<code>color_value</code>  <code>property</code>","text":"<p>Get the color values stored in the object.</p> <p>This property returns the color values that were provided when initializing the Colors object or set afterwards. The values can be hex color strings, RGB tuples with values between 0-255, or normalized RGB tuples with values between 0-1.</p> <p>Returns:</p> Type Description <code>Union[List[str], List[Tuple[float, float, float]]]</code> <p>A list containing the color values. Each element can be: - A hex color string (e.g., \"#ff0000\" or \"ff0000\") - An RGB tuple with values between 0-255 (e.g., (255, 0, 0)) - A normalized RGB tuple with values between 0-1 (e.g., (1.0, 0.0, 0.0))</p> <p>Examples:</p> <p>Get color values from a Colors object with hex colors: <pre><code>&gt;&gt;&gt; from cleopatra.colors import Colors\n&gt;&gt;&gt; hex_colors = Colors([\"#ff0000\", \"#00ff00\", \"#0000ff\"])\n&gt;&gt;&gt; hex_colors.color_value\n['#ff0000', '#00ff00', '#0000ff']\n</code></pre></p> <p>Get color values from a Colors object with RGB colors: <pre><code>&gt;&gt;&gt; rgb_colors = Colors([(255, 0, 0), (0, 255, 0), (0, 0, 255)])\n&gt;&gt;&gt; rgb_colors.color_value\n[(255, 0, 0), (0, 255, 0), (0, 0, 255)]\n</code></pre> Get color values from a Colors object with mixed color formats: <pre><code>&gt;&gt;&gt; mixed = Colors([\"#ff0000\", (0, 255, 0), (0.0, 0.0, 1.0)])\n&gt;&gt;&gt; mixed.color_value\n['#ff0000', (0, 255, 0), (0.0, 0.0, 1.0)]\n</code></pre></p>"},{"location":"api/colors-class/#cleopatra.colors.Colors.__init__","title":"<code>__init__(color_value)</code>","text":"<p>Initialize a Colors object with the given color value(s).</p> <p>Parameters:</p> Name Type Description Default <code>color_value</code> <code>Union[List[str], str, Tuple[float, float, float], List[Tuple[float, float, float]]]</code> <p>The color value(s) to initialize the object with. Can be: - A single hex color string (e.g., \"#ff0000\" or \"ff0000\") - A single RGB tuple with values between 0-1 (e.g., (1.0, 0.0, 0.0)) - A single RGB tuple with values between 0-255 (e.g., (255, 0, 0)) - A list of hex color strings - A list of RGB tuples</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the color_value is not a string, tuple, or list of strings/tuples.</p> Notes <ul> <li>Hex colors can be provided with or without the leading \"#\"</li> <li>RGB tuples with float values between 0-1 are treated as normalized RGB</li> <li>RGB tuples with integer values between 0-255 are treated as standard RGB</li> <li>The class automatically detects the type of color format provided</li> </ul> <p>Examples:</p> <p>Initialize with a hex color: <pre><code>&gt;&gt;&gt; from cleopatra.colors import Colors\n&gt;&gt;&gt; # With hash symbol\n&gt;&gt;&gt; color1 = Colors(\"#ff0000\")\n&gt;&gt;&gt; color1.color_value\n['#ff0000']\n&gt;&gt;&gt; # Without hash symbol\n&gt;&gt;&gt; color2 = Colors(\"ff0000\")\n&gt;&gt;&gt; color2.color_value\n['ff0000']\n</code></pre></p> <p>Initialize with an RGB color (normalized, values between 0 and 1): <pre><code>&gt;&gt;&gt; rgb_norm = Colors((1.0, 0.0, 0.0))\n&gt;&gt;&gt; rgb_norm.color_value\n[(1.0, 0.0, 0.0)]\n&gt;&gt;&gt; rgb_norm.get_type()\n['rgb-normalized']\n</code></pre></p> <p>Initialize with an RGB color (values between 0 and 255): <pre><code>&gt;&gt;&gt; rgb_255 = Colors((255, 0, 0))\n&gt;&gt;&gt; rgb_255.color_value\n[(255, 0, 0)]\n&gt;&gt;&gt; rgb_255.get_type()\n['rgb']\n</code></pre></p> <p>Initialize with a list of colors: <pre><code>&gt;&gt;&gt; mixed_colors = Colors([\"#ff0000\", (0, 255, 0), (0.0, 0.0, 1.0)])\n&gt;&gt;&gt; mixed_colors.color_value\n['#ff0000', (0, 255, 0), (0.0, 0.0, 1.0)]\n&gt;&gt;&gt; mixed_colors.get_type()\n['hex', 'rgb', 'rgb-normalized']\n</code></pre></p> Source code in <code>cleopatra/colors.py</code> <pre><code>def __init__(\n    self,\n    color_value: Union[\n        List[str], str, Tuple[float, float, float], List[Tuple[float, float, float]]\n    ],\n):\n    \"\"\"Initialize a Colors object with the given color value(s).\n\n    Parameters\n    ----------\n    color_value : Union[List[str], str, Tuple[float, float, float], List[Tuple[float, float, float]]]\n        The color value(s) to initialize the object with. Can be:\n        - A single hex color string (e.g., \"#ff0000\" or \"ff0000\")\n        - A single RGB tuple with values between 0-1 (e.g., (1.0, 0.0, 0.0))\n        - A single RGB tuple with values between 0-255 (e.g., (255, 0, 0))\n        - A list of hex color strings\n        - A list of RGB tuples\n\n    Raises\n    ------\n    ValueError\n        If the color_value is not a string, tuple, or list of strings/tuples.\n\n    Notes\n    -----\n    - Hex colors can be provided with or without the leading \"#\"\n    - RGB tuples with float values between 0-1 are treated as normalized RGB\n    - RGB tuples with integer values between 0-255 are treated as standard RGB\n    - The class automatically detects the type of color format provided\n\n    Examples\n    --------\n    Initialize with a hex color:\n    ```python\n    &gt;&gt;&gt; from cleopatra.colors import Colors\n    &gt;&gt;&gt; # With hash symbol\n    &gt;&gt;&gt; color1 = Colors(\"#ff0000\")\n    &gt;&gt;&gt; color1.color_value\n    ['#ff0000']\n    &gt;&gt;&gt; # Without hash symbol\n    &gt;&gt;&gt; color2 = Colors(\"ff0000\")\n    &gt;&gt;&gt; color2.color_value\n    ['ff0000']\n\n    ```\n\n    Initialize with an RGB color (normalized, values between 0 and 1):\n    ```python\n    &gt;&gt;&gt; rgb_norm = Colors((1.0, 0.0, 0.0))\n    &gt;&gt;&gt; rgb_norm.color_value\n    [(1.0, 0.0, 0.0)]\n    &gt;&gt;&gt; rgb_norm.get_type()\n    ['rgb-normalized']\n\n    ```\n\n    Initialize with an RGB color (values between 0 and 255):\n    ```python\n    &gt;&gt;&gt; rgb_255 = Colors((255, 0, 0))\n    &gt;&gt;&gt; rgb_255.color_value\n    [(255, 0, 0)]\n    &gt;&gt;&gt; rgb_255.get_type()\n    ['rgb']\n\n    ```\n\n    Initialize with a list of colors:\n    ```python\n    &gt;&gt;&gt; mixed_colors = Colors([\"#ff0000\", (0, 255, 0), (0.0, 0.0, 1.0)])\n    &gt;&gt;&gt; mixed_colors.color_value\n    ['#ff0000', (0, 255, 0), (0.0, 0.0, 1.0)]\n    &gt;&gt;&gt; mixed_colors.get_type()\n    ['hex', 'rgb', 'rgb-normalized']\n\n    ```\n    \"\"\"\n    # convert the hex color to a list if it is a string\n    if isinstance(color_value, str) or isinstance(color_value, tuple):\n        color_value = [color_value]\n    elif not isinstance(color_value, list):\n        raise ValueError(\n            \"The color_value must be a list of hex colors, list of tuples (RGB color), a single hex \"\n            \"or single RGB tuple color.\"\n        )\n\n    self._color_value = color_value\n</code></pre>"},{"location":"api/colors-class/#cleopatra.colors.Colors.get_type","title":"<code>get_type()</code>","text":"<p>Determine the type of each color value.</p> <p>This method analyzes each color value stored in the object and determines its type: hex, rgb (values 0-255), or rgb-normalized (values 0-1).</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of strings indicating the type of each color value. Possible values are: - 'hex': Hexadecimal color string - 'rgb': RGB tuple with values between 0-255 - 'rgb-normalized': RGB tuple with values between 0-1</p> Notes <p>The method uses the following criteria to determine color types: - If the value is a string and is a valid hex color, it's classified as 'hex' - If the value is a tuple of 3 floats between 0-1, it's classified as 'rgb-normalized' - If the value is a tuple of 3 integers between 0-255, it's classified as 'rgb'</p> <p>Examples:</p> <p>Determine the type of a hex color: <pre><code>&gt;&gt;&gt; from cleopatra.colors import Colors\n&gt;&gt;&gt; hex_color = Colors(\"#23a9dd\")\n&gt;&gt;&gt; hex_color.get_type()\n['hex']\n</code></pre></p> <p>Determine the type of an RGB color with normalized values (0-1): <pre><code>&gt;&gt;&gt; rgb_norm = Colors((0.5, 0.2, 0.8))\n&gt;&gt;&gt; rgb_norm.get_type()\n['rgb-normalized']\n</code></pre></p> <p>Determine the type of an RGB color with values between 0-255: <pre><code>&gt;&gt;&gt; rgb_255 = Colors((128, 51, 204))\n&gt;&gt;&gt; rgb_255.get_type()\n['rgb']\n</code></pre></p> <p>Determine types of mixed color formats: <pre><code>&gt;&gt;&gt; mixed = Colors([\"#ff0000\", (0, 255, 0), (0.0, 0.0, 1.0)])\n&gt;&gt;&gt; mixed.get_type()\n['hex', 'rgb', 'rgb-normalized']\n</code></pre></p> Source code in <code>cleopatra/colors.py</code> <pre><code>def get_type(self) -&gt; List[str]:\n    \"\"\"Determine the type of each color value.\n\n    This method analyzes each color value stored in the object and determines\n    its type: hex, rgb (values 0-255), or rgb-normalized (values 0-1).\n\n    Returns\n    -------\n    List[str]\n        A list of strings indicating the type of each color value.\n        Possible values are:\n        - 'hex': Hexadecimal color string\n        - 'rgb': RGB tuple with values between 0-255\n        - 'rgb-normalized': RGB tuple with values between 0-1\n\n    Notes\n    -----\n    The method uses the following criteria to determine color types:\n    - If the value is a string and is a valid hex color, it's classified as 'hex'\n    - If the value is a tuple of 3 floats between 0-1, it's classified as 'rgb-normalized'\n    - If the value is a tuple of 3 integers between 0-255, it's classified as 'rgb'\n\n    Examples\n    --------\n    Determine the type of a hex color:\n    ```python\n    &gt;&gt;&gt; from cleopatra.colors import Colors\n    &gt;&gt;&gt; hex_color = Colors(\"#23a9dd\")\n    &gt;&gt;&gt; hex_color.get_type()\n    ['hex']\n\n    ```\n\n    Determine the type of an RGB color with normalized values (0-1):\n    ```python\n    &gt;&gt;&gt; rgb_norm = Colors((0.5, 0.2, 0.8))\n    &gt;&gt;&gt; rgb_norm.get_type()\n    ['rgb-normalized']\n\n    ```\n\n    Determine the type of an RGB color with values between 0-255:\n    ```python\n    &gt;&gt;&gt; rgb_255 = Colors((128, 51, 204))\n    &gt;&gt;&gt; rgb_255.get_type()\n    ['rgb']\n\n    ```\n\n    Determine types of mixed color formats:\n    ```python\n    &gt;&gt;&gt; mixed = Colors([\"#ff0000\", (0, 255, 0), (0.0, 0.0, 1.0)])\n    &gt;&gt;&gt; mixed.get_type()\n    ['hex', 'rgb', 'rgb-normalized']\n\n    ```\n    \"\"\"\n    color_type = []\n    for color_i in self.color_value:\n        if self.is_valid_rgb_norm(color_i):\n            color_type.append(\"rgb-normalized\")\n        elif self.is_valid_rgb_255(color_i):\n            color_type.append(\"rgb\")\n        elif self.is_valid_hex_i(color_i):\n            color_type.append(\"hex\")\n\n    return color_type\n</code></pre>"},{"location":"api/colors-class/#cleopatra.colors.Colors.is_valid_hex","title":"<code>is_valid_hex()</code>","text":"<p>Check if each color value is a valid hexadecimal color.</p> <p>This method checks each color value stored in the object to determine if it is a valid hexadecimal color string.</p> <p>Returns:</p> Type Description <code>List[bool]</code> <p>A list of boolean values, one for each color value in the object. True indicates the color is a valid hex color, False otherwise.</p> Notes <ul> <li>The method uses matplotlib's is_color_like function to validate hex colors</li> <li>Both formats with and without the leading '#' are supported</li> <li>RGB tuples will return False as they are not hex colors</li> </ul> <p>Examples:</p> <p>Check if hex colors are valid: <pre><code>&gt;&gt;&gt; from cleopatra.colors import Colors\n&gt;&gt;&gt; hex_colors = Colors([\"#ff0000\", \"#00ff00\", \"#0000ff\"])\n&gt;&gt;&gt; hex_colors.is_valid_hex()\n[True, True, True]\n</code></pre> Check if RGB colors are valid hex colors (they're not): <pre><code>&gt;&gt;&gt; rgb_colors = Colors([(255, 0, 0), (0, 255, 0), (0, 0, 255)])\n&gt;&gt;&gt; rgb_colors.is_valid_hex()\n[False, False, False]\n</code></pre> Check a mix of color formats: <pre><code>&gt;&gt;&gt; mixed = Colors([\"#ff0000\", (0, 255, 0), \"not-a-color\"])\n&gt;&gt;&gt; mixed.is_valid_hex()\n[True, False, False]\n</code></pre></p> Source code in <code>cleopatra/colors.py</code> <pre><code>def is_valid_hex(self) -&gt; List[bool]:\n    \"\"\"Check if each color value is a valid hexadecimal color.\n\n    This method checks each color value stored in the object to determine\n    if it is a valid hexadecimal color string.\n\n    Returns\n    -------\n    List[bool]\n        A list of boolean values, one for each color value in the object.\n        True indicates the color is a valid hex color, False otherwise.\n\n    Notes\n    -----\n    - The method uses matplotlib's is_color_like function to validate hex colors\n    - Both formats with and without the leading '#' are supported\n    - RGB tuples will return False as they are not hex colors\n\n    Examples\n    --------\n    Check if hex colors are valid:\n    ```python\n    &gt;&gt;&gt; from cleopatra.colors import Colors\n    &gt;&gt;&gt; hex_colors = Colors([\"#ff0000\", \"#00ff00\", \"#0000ff\"])\n    &gt;&gt;&gt; hex_colors.is_valid_hex()\n    [True, True, True]\n\n    ```\n    Check if RGB colors are valid hex colors (they're not):\n    ```python\n    &gt;&gt;&gt; rgb_colors = Colors([(255, 0, 0), (0, 255, 0), (0, 0, 255)])\n    &gt;&gt;&gt; rgb_colors.is_valid_hex()\n    [False, False, False]\n\n    ```\n    Check a mix of color formats:\n    ```python\n    &gt;&gt;&gt; mixed = Colors([\"#ff0000\", (0, 255, 0), \"not-a-color\"])\n    &gt;&gt;&gt; mixed.is_valid_hex()\n    [True, False, False]\n\n    ```\n    \"\"\"\n    return [self.is_valid_hex_i(col) for col in self.color_value]\n</code></pre>"},{"location":"api/colors-class/#cleopatra.colors.Colors.is_valid_hex_i","title":"<code>is_valid_hex_i(hex_color)</code>  <code>staticmethod</code>","text":"<p>Check if a single color value is a valid hexadecimal color.</p> <p>This static method checks if the provided color value is a valid hexadecimal color string.</p> <p>Parameters:</p> Name Type Description Default <code>hex_color</code> <code>str</code> <p>A color string to validate as a hexadecimal color. Can be in the format \"#RRGGBB\" or \"RRGGBB\".</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the color is a valid hexadecimal color, False otherwise.</p> Notes <ul> <li>The method uses matplotlib's is_color_like function to validate hex colors</li> <li>Both formats with and without the leading '#' are supported</li> <li>Non-string values will return False</li> </ul> <p>Examples:</p> <p>Check valid hex colors: <pre><code>&gt;&gt;&gt; from cleopatra.colors import Colors\n&gt;&gt;&gt; Colors.is_valid_hex_i(\"#ff0000\")\nTrue\n&gt;&gt;&gt; Colors.is_valid_hex_i(\"00ff00\")\nFalse\n&gt;&gt;&gt; Colors.is_valid_hex_i(\"#0000FF\")\nTrue\n</code></pre></p> <p>Check invalid hex colors: <pre><code>&gt;&gt;&gt; Colors.is_valid_hex_i(\"not-a-color\")\nFalse\n&gt;&gt;&gt; Colors.is_valid_hex_i(\"#12345\")  # Too short\nFalse\n&gt;&gt;&gt; Colors.is_valid_hex_i((255, 0, 0))  # doctest: +ELLIPSIS\nFalse\n</code></pre></p> Source code in <code>cleopatra/colors.py</code> <pre><code>@staticmethod\ndef is_valid_hex_i(hex_color: str) -&gt; bool:\n    \"\"\"Check if a single color value is a valid hexadecimal color.\n\n    This static method checks if the provided color value is a valid\n    hexadecimal color string.\n\n    Parameters\n    ----------\n    hex_color : str\n        A color string to validate as a hexadecimal color.\n        Can be in the format \"#RRGGBB\" or \"RRGGBB\".\n\n    Returns\n    -------\n    bool\n        True if the color is a valid hexadecimal color, False otherwise.\n\n    Notes\n    -----\n    - The method uses matplotlib's is_color_like function to validate hex colors\n    - Both formats with and without the leading '#' are supported\n    - Non-string values will return False\n\n    Examples\n    --------\n    Check valid hex colors:\n    ```python\n    &gt;&gt;&gt; from cleopatra.colors import Colors\n    &gt;&gt;&gt; Colors.is_valid_hex_i(\"#ff0000\")\n    True\n    &gt;&gt;&gt; Colors.is_valid_hex_i(\"00ff00\")\n    False\n    &gt;&gt;&gt; Colors.is_valid_hex_i(\"#0000FF\")\n    True\n\n    ```\n\n    Check invalid hex colors:\n    ```python\n    &gt;&gt;&gt; Colors.is_valid_hex_i(\"not-a-color\")\n    False\n    &gt;&gt;&gt; Colors.is_valid_hex_i(\"#12345\")  # Too short\n    False\n    &gt;&gt;&gt; Colors.is_valid_hex_i((255, 0, 0))  # doctest: +ELLIPSIS\n    False\n\n    ```\n    \"\"\"\n    return True if mcolors.is_color_like(hex_color) else False\n</code></pre>"},{"location":"api/colors-class/#cleopatra.colors.Colors.is_valid_rgb","title":"<code>is_valid_rgb()</code>","text":"<p>Check if each color value is a valid RGB color.</p> <p>This method checks each color value stored in the object to determine if it is a valid RGB color tuple (either with values between 0-255 or normalized values between 0-1).</p> <p>Returns:</p> Type Description <code>List[bool]</code> <p>A list of boolean values, one for each color value in the object. True indicates the color is a valid RGB tuple, False otherwise.</p> Notes <ul> <li>The method checks for both RGB formats: values between 0-255 and normalized values between 0-1</li> <li>A valid RGB tuple must have exactly 3 values (R, G, B)</li> <li>Hex color strings will return False as they are not RGB tuples</li> </ul> <p>Examples:</p> <p>Check if RGB colors are valid: <pre><code>&gt;&gt;&gt; from cleopatra.colors import Colors\n&gt;&gt;&gt; # RGB colors (0-255 range)\n&gt;&gt;&gt; rgb_255 = Colors([(255, 0, 0), (0, 255, 0), (0, 0, 255)])\n&gt;&gt;&gt; rgb_255.is_valid_rgb()\n[True, True, True]\n\n&gt;&gt;&gt; # RGB colors (normalized 0-1 range)\n&gt;&gt;&gt; rgb_norm = Colors([(1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)])\n&gt;&gt;&gt; rgb_norm.is_valid_rgb()\n[True, True, True]\n</code></pre> Check if hex colors are valid RGB colors (they're not): <pre><code>&gt;&gt;&gt; hex_colors = Colors([\"#ff0000\", \"#00ff00\", \"#0000ff\"])\n&gt;&gt;&gt; hex_colors.is_valid_rgb()\n[False, False, False]\n</code></pre> Check a mix of color formats: <pre><code>&gt;&gt;&gt; mixed = Colors([(255, 0, 0), \"#00ff00\", (0.0, 0.0, 1.0)])\n&gt;&gt;&gt; mixed.is_valid_rgb()\n[True, False, True]\n</code></pre></p> Source code in <code>cleopatra/colors.py</code> <pre><code>def is_valid_rgb(self) -&gt; List[bool]:\n    \"\"\"Check if each color value is a valid RGB color.\n\n    This method checks each color value stored in the object to determine\n    if it is a valid RGB color tuple (either with values between 0-255 or\n    normalized values between 0-1).\n\n    Returns\n    -------\n    List[bool]\n        A list of boolean values, one for each color value in the object.\n        True indicates the color is a valid RGB tuple, False otherwise.\n\n    Notes\n    -----\n    - The method checks for both RGB formats: values between 0-255 and normalized values between 0-1\n    - A valid RGB tuple must have exactly 3 values (R, G, B)\n    - Hex color strings will return False as they are not RGB tuples\n\n    Examples\n    --------\n    Check if RGB colors are valid:\n    ```python\n    &gt;&gt;&gt; from cleopatra.colors import Colors\n    &gt;&gt;&gt; # RGB colors (0-255 range)\n    &gt;&gt;&gt; rgb_255 = Colors([(255, 0, 0), (0, 255, 0), (0, 0, 255)])\n    &gt;&gt;&gt; rgb_255.is_valid_rgb()\n    [True, True, True]\n\n    &gt;&gt;&gt; # RGB colors (normalized 0-1 range)\n    &gt;&gt;&gt; rgb_norm = Colors([(1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)])\n    &gt;&gt;&gt; rgb_norm.is_valid_rgb()\n    [True, True, True]\n\n    ```\n    Check if hex colors are valid RGB colors (they're not):\n    ```python\n    &gt;&gt;&gt; hex_colors = Colors([\"#ff0000\", \"#00ff00\", \"#0000ff\"])\n    &gt;&gt;&gt; hex_colors.is_valid_rgb()\n    [False, False, False]\n\n    ```\n    Check a mix of color formats:\n    ```python\n    &gt;&gt;&gt; mixed = Colors([(255, 0, 0), \"#00ff00\", (0.0, 0.0, 1.0)])\n    &gt;&gt;&gt; mixed.is_valid_rgb()\n    [True, False, True]\n\n    ```\n    \"\"\"\n    return [\n        self.is_valid_rgb_norm(col) or self.is_valid_rgb_255(col)\n        for col in self.color_value\n    ]\n</code></pre>"},{"location":"api/colors-class/#cleopatra.colors.Colors.is_valid_rgb_255","title":"<code>is_valid_rgb_255(rgb_tuple)</code>  <code>staticmethod</code>","text":"<p>Check if a single color value is a valid RGB tuple with values between 0-255.</p> <p>This static method checks if the provided value is a valid RGB tuple with integer values between 0 and 255.</p> <p>Parameters:</p> Name Type Description Default <code>rgb_tuple</code> <code>Any</code> <p>The value to check. Should be a tuple of 3 integers between 0 and 255 to be considered valid.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the value is a valid RGB tuple with values between 0-255, False otherwise.</p> <p>Examples:</p> <p>Check valid RGB tuples (0-255 range): <pre><code>&gt;&gt;&gt; from cleopatra.colors import Colors\n&gt;&gt;&gt; Colors.is_valid_rgb_255((255, 0, 0))\nTrue\n&gt;&gt;&gt; Colors.is_valid_rgb_255((128, 64, 32))\nTrue\n&gt;&gt;&gt; Colors.is_valid_rgb_255((0, 0, 0))\nTrue\n</code></pre> Check invalid RGB tuples: <pre><code>&gt;&gt;&gt; Colors.is_valid_rgb_255((1.0, 0.0, 0.0))  # Floats, not integers\nFalse\n&gt;&gt;&gt; Colors.is_valid_rgb_255((256, 0, 0))  # Value &gt; 255\nFalse\n&gt;&gt;&gt; Colors.is_valid_rgb_255((0, 0))  # Not 3 values\nFalse\n&gt;&gt;&gt; Colors.is_valid_rgb_255(\"#ff0000\")  # Not a tuple\nFalse\n</code></pre></p> Source code in <code>cleopatra/colors.py</code> <pre><code>@staticmethod\ndef is_valid_rgb_255(rgb_tuple: Any) -&gt; bool:\n    \"\"\"Check if a single color value is a valid RGB tuple with values between 0-255.\n\n    This static method checks if the provided value is a valid RGB tuple with\n    integer values between 0 and 255.\n\n    Parameters\n    ----------\n    rgb_tuple : Any\n        The value to check. Should be a tuple of 3 integers between 0 and 255\n        to be considered valid.\n\n    Returns\n    -------\n    bool\n        True if the value is a valid RGB tuple with values between 0-255,\n        False otherwise.\n\n    Examples\n    --------\n    Check valid RGB tuples (0-255 range):\n    ```python\n    &gt;&gt;&gt; from cleopatra.colors import Colors\n    &gt;&gt;&gt; Colors.is_valid_rgb_255((255, 0, 0))\n    True\n    &gt;&gt;&gt; Colors.is_valid_rgb_255((128, 64, 32))\n    True\n    &gt;&gt;&gt; Colors.is_valid_rgb_255((0, 0, 0))\n    True\n\n    ```\n    Check invalid RGB tuples:\n    ```python\n    &gt;&gt;&gt; Colors.is_valid_rgb_255((1.0, 0.0, 0.0))  # Floats, not integers\n    False\n    &gt;&gt;&gt; Colors.is_valid_rgb_255((256, 0, 0))  # Value &gt; 255\n    False\n    &gt;&gt;&gt; Colors.is_valid_rgb_255((0, 0))  # Not 3 values\n    False\n    &gt;&gt;&gt; Colors.is_valid_rgb_255(\"#ff0000\")  # Not a tuple\n    False\n\n    ```\n    \"\"\"\n    if isinstance(rgb_tuple, tuple) and len(rgb_tuple) == 3:\n        if all(isinstance(value, int) for value in rgb_tuple):\n            return all(0 &lt;= value &lt;= 255 for value in rgb_tuple)\n    return False\n</code></pre>"},{"location":"api/colors-class/#cleopatra.colors.Colors.is_valid_rgb_norm","title":"<code>is_valid_rgb_norm(rgb_tuple)</code>  <code>staticmethod</code>","text":"<p>Check if a single color value is a valid normalized RGB tuple with values between 0-1.</p> <p>This static method checks if the provided value is a valid RGB tuple with float values between 0.0 and 1.0.</p> <p>Parameters:</p> Name Type Description Default <code>rgb_tuple</code> <code>Any</code> <p>The value to check. Should be a tuple of 3 floats between 0.0 and 1.0 to be considered valid.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the value is a valid normalized RGB tuple with values between 0.0-1.0, False otherwise.</p> <p>Examples:</p> <p>Check valid normalized RGB tuples: <pre><code>&gt;&gt;&gt; from cleopatra.colors import Colors\n&gt;&gt;&gt; Colors.is_valid_rgb_norm((1.0, 0.0, 0.0))\nTrue\n&gt;&gt;&gt; Colors.is_valid_rgb_norm((0.5, 0.5, 0.5))\nTrue\n&gt;&gt;&gt; Colors.is_valid_rgb_norm((0.0, 0.0, 0.0))\nTrue\n</code></pre> Check invalid normalized RGB tuples: <pre><code>&gt;&gt;&gt; Colors.is_valid_rgb_norm((255, 0, 0))  # Integers, not floats\nFalse\n&gt;&gt;&gt; Colors.is_valid_rgb_norm((1.2, 0.0, 0.0))  # Value &gt; 1.0\nFalse\n&gt;&gt;&gt; Colors.is_valid_rgb_norm((0.5, 0.5))  # Not 3 values\nFalse\n&gt;&gt;&gt; Colors.is_valid_rgb_norm(\"#ff0000\")  # Not a tuple\nFalse\n</code></pre></p> Source code in <code>cleopatra/colors.py</code> <pre><code>@staticmethod\ndef is_valid_rgb_norm(rgb_tuple: Any) -&gt; bool:\n    \"\"\"Check if a single color value is a valid normalized RGB tuple with values between 0-1.\n\n    This static method checks if the provided value is a valid RGB tuple with\n    float values between 0.0 and 1.0.\n\n    Parameters\n    ----------\n    rgb_tuple : Any\n        The value to check. Should be a tuple of 3 floats between 0.0 and 1.0\n        to be considered valid.\n\n    Returns\n    -------\n    bool\n        True if the value is a valid normalized RGB tuple with values between 0.0-1.0,\n        False otherwise.\n\n    Examples\n    --------\n    Check valid normalized RGB tuples:\n    ```python\n    &gt;&gt;&gt; from cleopatra.colors import Colors\n    &gt;&gt;&gt; Colors.is_valid_rgb_norm((1.0, 0.0, 0.0))\n    True\n    &gt;&gt;&gt; Colors.is_valid_rgb_norm((0.5, 0.5, 0.5))\n    True\n    &gt;&gt;&gt; Colors.is_valid_rgb_norm((0.0, 0.0, 0.0))\n    True\n\n    ```\n    Check invalid normalized RGB tuples:\n    ```python\n    &gt;&gt;&gt; Colors.is_valid_rgb_norm((255, 0, 0))  # Integers, not floats\n    False\n    &gt;&gt;&gt; Colors.is_valid_rgb_norm((1.2, 0.0, 0.0))  # Value &gt; 1.0\n    False\n    &gt;&gt;&gt; Colors.is_valid_rgb_norm((0.5, 0.5))  # Not 3 values\n    False\n    &gt;&gt;&gt; Colors.is_valid_rgb_norm(\"#ff0000\")  # Not a tuple\n    False\n\n    ```\n    \"\"\"\n    if isinstance(rgb_tuple, tuple) and len(rgb_tuple) == 3:\n        if all(isinstance(value, float) for value in rgb_tuple):\n            return all(0.0 &lt;= value &lt;= 1.0 for value in rgb_tuple)\n    return False\n</code></pre>"},{"location":"api/colors-class/#cleopatra.colors.Colors.to_hex","title":"<code>to_hex()</code>","text":"<p>Convert all color values to hexadecimal format.</p> <p>This method converts all color values stored in the object to hexadecimal format. RGB tuples (both normalized and 0-255 range) are converted to their hex equivalents. Hex colors remain unchanged.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of hexadecimal color strings. Each string is in the format '#RRGGBB'.</p> Notes <ul> <li>RGB tuples with values between 0-255 are first normalized to 0-1 range before conversion</li> <li>RGB tuples with values already between 0-1 are directly converted</li> <li>Existing hex colors are returned as-is</li> <li>All returned hex colors include the leading '#' character</li> </ul> <p>Examples:</p> <p>Convert RGB colors to hex: <pre><code>&gt;&gt;&gt; from cleopatra.colors import Colors\n&gt;&gt;&gt; # RGB colors (0-255 range)\n&gt;&gt;&gt; rgb_255 = Colors([(255, 0, 0), (0, 255, 0), (0, 0, 255)])\n&gt;&gt;&gt; rgb_255.to_hex()\n['#ff0000', '#00ff00', '#0000ff']\n</code></pre></p> <pre><code>&gt;&gt;&gt; # RGB colors (normalized 0-1 range)\n&gt;&gt;&gt; rgb_norm = Colors([(1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)])\n&gt;&gt;&gt; rgb_norm.to_hex()\n['#ff0000', '#00ff00', '#0000ff']\n</code></pre> <p><code>Convert a mix of color formats to hex:</code>python</p> <pre><code>&gt;&gt;&gt; mixed = Colors([(128, 51, 204), \"#23a9dd\", (0.5, 0.2, 0.8)])\n&gt;&gt;&gt; mixed.to_hex()\n['#8033cc', '#23a9dd', '#8033cc']\n</code></pre> <p><code>Hex colors are returned as-is:</code>python</p> <pre><code>&gt;&gt;&gt; hex_colors = Colors([\"#ff0000\", \"#00ff00\", \"#0000ff\"])\n&gt;&gt;&gt; hex_colors.to_hex()\n['#ff0000', '#00ff00', '#0000ff']\n</code></pre> <p>```</p> Source code in <code>cleopatra/colors.py</code> <pre><code>def to_hex(self) -&gt; List[str]:\n    \"\"\"Convert all color values to hexadecimal format.\n\n    This method converts all color values stored in the object to hexadecimal format.\n    RGB tuples (both normalized and 0-255 range) are converted to their hex equivalents.\n    Hex colors remain unchanged.\n\n    Returns\n    -------\n    List[str]\n        A list of hexadecimal color strings. Each string is in the format '#RRGGBB'.\n\n    Notes\n    -----\n    - RGB tuples with values between 0-255 are first normalized to 0-1 range before conversion\n    - RGB tuples with values already between 0-1 are directly converted\n    - Existing hex colors are returned as-is\n    - All returned hex colors include the leading '#' character\n\n    Examples\n    --------\n    Convert RGB colors to hex:\n    ```python\n    &gt;&gt;&gt; from cleopatra.colors import Colors\n    &gt;&gt;&gt; # RGB colors (0-255 range)\n    &gt;&gt;&gt; rgb_255 = Colors([(255, 0, 0), (0, 255, 0), (0, 0, 255)])\n    &gt;&gt;&gt; rgb_255.to_hex()\n    ['#ff0000', '#00ff00', '#0000ff']\n\n    ```\n    &gt;&gt;&gt; # RGB colors (normalized 0-1 range)\n    &gt;&gt;&gt; rgb_norm = Colors([(1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)])\n    &gt;&gt;&gt; rgb_norm.to_hex()\n    ['#ff0000', '#00ff00', '#0000ff']\n\n    ```\n    Convert a mix of color formats to hex:\n    ```python\n    &gt;&gt;&gt; mixed = Colors([(128, 51, 204), \"#23a9dd\", (0.5, 0.2, 0.8)])\n    &gt;&gt;&gt; mixed.to_hex()\n    ['#8033cc', '#23a9dd', '#8033cc']\n\n    ```\n    Hex colors are returned as-is:\n    ```python\n    &gt;&gt;&gt; hex_colors = Colors([\"#ff0000\", \"#00ff00\", \"#0000ff\"])\n    &gt;&gt;&gt; hex_colors.to_hex()\n    ['#ff0000', '#00ff00', '#0000ff']\n\n    ```\n    \"\"\"\n    converted_color = []\n    color_type = self.get_type()\n    for ind, color_i in enumerate(self.color_value):\n        if color_type[ind] == \"hex\":\n            converted_color.append(color_i)\n        elif color_type[ind] == \"rgb\":\n            # Normalize the RGB values to be between 0 and 1\n            rgb_color_normalized = tuple(value / 255 for value in color_i)\n            converted_color.append(mcolors.to_hex(rgb_color_normalized))\n        else:\n            converted_color.append(mcolors.to_hex(color_i))\n    return converted_color\n</code></pre>"},{"location":"api/colors-class/#cleopatra.colors.Colors.to_rgb","title":"<code>to_rgb(normalized=True)</code>","text":"<p>Convert all color values to RGB format.</p> <p>This method converts all color values stored in the object to RGB format. Hex colors are converted to their RGB equivalents. RGB colors remain unchanged but may be normalized or denormalized based on the 'normalized' parameter.</p> <p>Parameters:</p> Name Type Description Default <code>normalized</code> <code>bool</code> <p>Whether to return normalized RGB values (between 0 and 1) or standard RGB values (between 0 and 255), by default True. - If True, returns RGB values scaled between 0 and 1 - If False, returns RGB values scaled between 0 and 255</p> <code>True</code> <p>Returns:</p> Type Description <code>List[Tuple[Union[int, float], Union[int, float], Union[int, float]]]</code> <p>A list of RGB tuples. Each tuple contains three values (R, G, B). - If normalized=True, values are floats between 0.0 and 1.0 - If normalized=False, values are integers between 0 and 255</p> <p>Examples:</p> <p>Convert hex colors to normalized RGB (0-1 range): ```python</p> <p>from cleopatra.colors import Colors hex_colors = Colors([\"#ff0000\", \"#00ff00\", \"#0000ff\"]) hex_colors.to_rgb(normalized=True) [(1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)]</p> <p>Convert hex colors to standard RGB (0-255 range): ```python</p> <pre><code>&gt;&gt;&gt; hex_colors.to_rgb(normalized=False)\n[(255, 0, 0), (0, 255, 0), (0, 0, 255)]\n</code></pre> <p><code>Convert RGB colors and maintain their format:</code>python</p> <pre><code>&gt;&gt;&gt; rgb_255 = Colors([(255, 0, 0), (0, 255, 0)])\n&gt;&gt;&gt; rgb_255.to_rgb(normalized=False)  # Keep as 0-255 range\n[(255, 0, 0), (0, 255, 0)]\n&gt;&gt;&gt; rgb_255.to_rgb(normalized=True)  # Convert to 0-1 range\n[(1.0, 0.0, 0.0), (0.0, 1.0, 0.0)]\n</code></pre> <pre><code>&gt;&gt;&gt; rgb_norm = Colors([(1.0, 0.0, 0.0), (0.0, 1.0, 0.0)])\n&gt;&gt;&gt; rgb_norm.to_rgb(normalized=True)  # Keep as 0-1 range\n[(1.0, 0.0, 0.0), (0.0, 1.0, 0.0)]\n&gt;&gt;&gt; rgb_norm.to_rgb(normalized=False)  # Convert to 0-255 range\n[(255, 0, 0), (0, 255, 0)]\n</code></pre> <p><code>Convert mixed color formats:</code>python</p> <pre><code>&gt;&gt;&gt; mixed = Colors([\"#ff0000\", (0, 255, 0), (0.0, 0.0, 1.0)])\n&gt;&gt;&gt; mixed.to_rgb(normalized=True)\n[(1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)]\n</code></pre> <p>```</p> Source code in <code>cleopatra/colors.py</code> <pre><code>def to_rgb(\n    self, normalized: bool = True\n) -&gt; List[Tuple[Union[int, float], Union[int, float], Union[int, float]]]:\n    \"\"\"Convert all color values to RGB format.\n\n    This method converts all color values stored in the object to RGB format.\n    Hex colors are converted to their RGB equivalents. RGB colors remain unchanged\n    but may be normalized or denormalized based on the 'normalized' parameter.\n\n    Parameters\n    ----------\n    normalized : bool, optional\n        Whether to return normalized RGB values (between 0 and 1) or standard RGB values\n        (between 0 and 255), by default True.\n        - If True, returns RGB values scaled between 0 and 1\n        - If False, returns RGB values scaled between 0 and 255\n\n    Returns\n    -------\n    List[Tuple[Union[int, float], Union[int, float], Union[int, float]]]\n        A list of RGB tuples. Each tuple contains three values (R, G, B).\n        - If normalized=True, values are floats between 0.0 and 1.0\n        - If normalized=False, values are integers between 0 and 255\n\n    Examples\n    --------\n    Convert hex colors to normalized RGB (0-1 range):\n    ```python\n    &gt;&gt;&gt; from cleopatra.colors import Colors\n    &gt;&gt;&gt; hex_colors = Colors([\"#ff0000\", \"#00ff00\", \"#0000ff\"])\n    &gt;&gt;&gt; hex_colors.to_rgb(normalized=True)\n    [(1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)]\n\n    Convert hex colors to standard RGB (0-255 range):\n    ```python\n    &gt;&gt;&gt; hex_colors.to_rgb(normalized=False)\n    [(255, 0, 0), (0, 255, 0), (0, 0, 255)]\n\n    ```\n    Convert RGB colors and maintain their format:\n    ```python\n    &gt;&gt;&gt; rgb_255 = Colors([(255, 0, 0), (0, 255, 0)])\n    &gt;&gt;&gt; rgb_255.to_rgb(normalized=False)  # Keep as 0-255 range\n    [(255, 0, 0), (0, 255, 0)]\n    &gt;&gt;&gt; rgb_255.to_rgb(normalized=True)  # Convert to 0-1 range\n    [(1.0, 0.0, 0.0), (0.0, 1.0, 0.0)]\n\n    &gt;&gt;&gt; rgb_norm = Colors([(1.0, 0.0, 0.0), (0.0, 1.0, 0.0)])\n    &gt;&gt;&gt; rgb_norm.to_rgb(normalized=True)  # Keep as 0-1 range\n    [(1.0, 0.0, 0.0), (0.0, 1.0, 0.0)]\n    &gt;&gt;&gt; rgb_norm.to_rgb(normalized=False)  # Convert to 0-255 range\n    [(255, 0, 0), (0, 255, 0)]\n\n    ```\n    Convert mixed color formats:\n    ```python\n    &gt;&gt;&gt; mixed = Colors([\"#ff0000\", (0, 255, 0), (0.0, 0.0, 1.0)])\n    &gt;&gt;&gt; mixed.to_rgb(normalized=True)\n    [(1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)]\n\n    ```\n    \"\"\"\n    color_type = self.get_type()\n    rgb = []\n    if normalized:\n        for ind, color_i in enumerate(self.color_value):\n            # if the color is in RGB format (0-255), normalize the values to be between 0 and 1\n            if color_type[ind] == \"rgb\":\n                rgb_color_normalized = tuple(value / 255 for value in color_i)\n                rgb.append(rgb_color_normalized)\n            else:\n                # any other format, just convert it to RGB\n                rgb.append(mcolors.to_rgb(color_i))\n    else:\n        for ind, color_i in enumerate(self.color_value):\n            # if the color is in RGB format (0-255), normalize the values to be between 0 and 1\n            if color_type[ind] == \"rgb\":\n                rgb.append(color_i)\n            else:\n                # any other format, just convert it to RGB\n                rgb.append(tuple([int(c * 255) for c in mcolors.to_rgb(color_i)]))\n\n    return rgb\n</code></pre>"},{"location":"api/colors-class/#examples","title":"Examples","text":""},{"location":"api/colors-class/#creating-color-objects","title":"Creating Color Objects","text":"<pre><code>from cleopatra.colors import Colors\n\n# Create a Colors object with a hex color\nhex_color = Colors(\"#FF5733\")\n\n# Create a Colors object with an RGB color (normalized)\nrgb_color = Colors((1.0, 0.34, 0.2))\n\n# Create a Colors object with an RGB color (0-255)\nrgb_255_color = Colors((255, 87, 51))\n\n# Create a Colors object with a named color\nnamed_color = Colors(\"red\")\n\n# Create a Colors object with a list of colors\ncolor_list = Colors([\"red\", \"green\", \"blue\"])\n</code></pre>"},{"location":"api/colors-class/#converting-between-color-formats","title":"Converting Between Color Formats","text":"<pre><code># Convert to hex\nhex_value = rgb_color.to_hex()\nprint(hex_value)  # \"#FF5733\"\n\n# Convert to RGB (normalized)\nrgb_value = hex_color.to_rgb(normalized=True)\nprint(rgb_value)  # (1.0, 0.34, 0.2)\n\n# Convert to RGB (0-255)\nrgb_255_value = hex_color.to_rgb(normalized=False)\nprint(rgb_255_value)  # (255, 87, 51)\n</code></pre>"},{"location":"api/colors-class/#validating-color-values","title":"Validating Color Values","text":"<pre><code># Check if a hex color is valid\nis_valid = hex_color.is_valid_hex()\nprint(is_valid)  # True\n\n# Check if an RGB color is valid\nis_valid = rgb_color.is_valid_rgb()\nprint(is_valid)  # True\n</code></pre>"},{"location":"api/statistics-class/","title":"Statistic Class","text":"<p>The <code>Statistic</code> module provides a class for creating statistical plots, specifically histograms. The class, <code>Statistic</code>, is designed to handle both 1D (single-dimensional) and 2D (multi-dimensional) data.</p>"},{"location":"api/statistics-class/#class-documentation","title":"Class Documentation","text":""},{"location":"api/statistics-class/#cleopatra.statistics.Statistic","title":"<code>cleopatra.statistics.Statistic</code>","text":"<p>A class for creating statistical plots, specifically histograms.</p> <p>This class provides functionality for creating histogram plots from 1D or 2D numerical data. It supports customization of various aspects of the plots, including bin count, colors, transparency, and axis labels.</p> <p>Attributes:</p> Name Type Description <code>values</code> <code>ndarray</code> <p>The numerical values to be plotted as histograms.</p> <code>default_options</code> <code>dict</code> <p>The default options for creating histograms, including: - bins: Number of histogram bins - color: Colors for the histogram bars - alpha: Transparency of the bars - rwidth: Width of the bars - grid_alpha: Transparency of the grid - xlabel, ylabel: Axis labels - xlabel_font_size, ylabel_font_size: Font sizes for axis labels - xtick_font_size, ytick_font_size: Font sizes for axis ticks</p> <p>Methods:</p> Name Description <code>histogram</code> <p>Creates a histogram from the given values with customizable options.</p> Notes <p>The class can handle both 1D data (single histogram) and 2D data (multiple histograms overlaid on the same plot). For 2D data, the number of colors provided should match the number of data series (columns in the array).</p> <p>Examples:</p> <p>Create a histogram from 1D data: <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from cleopatra.statistics import Statistic\n&gt;&gt;&gt; np.random.seed(1)\n&gt;&gt;&gt; x = 4 + np.random.normal(0, 1.5, 200)\n&gt;&gt;&gt; stat_plot = Statistic(x)\n&gt;&gt;&gt; fig, ax, hist = stat_plot.histogram()\n</code></pre> Create a histogram from 2D data with custom colors: <pre><code>&gt;&gt;&gt; np.random.seed(1)\n&gt;&gt;&gt; x = 4 + np.random.normal(0, 1.5, (200, 3))\n&gt;&gt;&gt; stat_plot = Statistic(x, color=[\"red\", \"green\", \"blue\"], alpha=0.4, rwidth=0.8)\n&gt;&gt;&gt; fig, ax, hist = stat_plot.histogram()\n</code></pre></p> Source code in <code>cleopatra/statistics.py</code> <pre><code>class Statistic:\n    \"\"\"A class for creating statistical plots, specifically histograms.\n\n    This class provides functionality for creating histogram plots from 1D or 2D numerical data.\n    It supports customization of various aspects of the plots, including bin count, colors,\n    transparency, and axis labels.\n\n    Attributes\n    ----------\n    values : numpy.ndarray\n        The numerical values to be plotted as histograms.\n    default_options : dict\n        The default options for creating histograms, including:\n        - bins: Number of histogram bins\n        - color: Colors for the histogram bars\n        - alpha: Transparency of the bars\n        - rwidth: Width of the bars\n        - grid_alpha: Transparency of the grid\n        - xlabel, ylabel: Axis labels\n        - xlabel_font_size, ylabel_font_size: Font sizes for axis labels\n        - xtick_font_size, ytick_font_size: Font sizes for axis ticks\n\n    Methods\n    -------\n    histogram(**kwargs)\n        Creates a histogram from the given values with customizable options.\n\n    Notes\n    -----\n    The class can handle both 1D data (single histogram) and 2D data (multiple histograms\n    overlaid on the same plot). For 2D data, the number of colors provided should match\n    the number of data series (columns in the array).\n\n    Examples\n    --------\n    Create a histogram from 1D data:\n    ```python\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from cleopatra.statistics import Statistic\n    &gt;&gt;&gt; np.random.seed(1)\n    &gt;&gt;&gt; x = 4 + np.random.normal(0, 1.5, 200)\n    &gt;&gt;&gt; stat_plot = Statistic(x)\n    &gt;&gt;&gt; fig, ax, hist = stat_plot.histogram()\n\n    ```\n    Create a histogram from 2D data with custom colors:\n    ```python\n    &gt;&gt;&gt; np.random.seed(1)\n    &gt;&gt;&gt; x = 4 + np.random.normal(0, 1.5, (200, 3))\n    &gt;&gt;&gt; stat_plot = Statistic(x, color=[\"red\", \"green\", \"blue\"], alpha=0.4, rwidth=0.8)\n    &gt;&gt;&gt; fig, ax, hist = stat_plot.histogram()\n\n    ```\n    \"\"\"\n\n    def __init__(\n        self,\n        values: Union[List, np.ndarray],\n        **kwargs,\n    ):\n        \"\"\"Initialize the Statistic object with values and optional customization parameters.\n\n        Parameters\n        ----------\n        values : Union[List, np.ndarray]\n            The numerical values to be plotted as histograms. Can be:\n            - 1D array/list for a single histogram\n            - 2D array/list for multiple histograms (one per column)\n        **kwargs : dict, optional\n            Additional keyword arguments to customize the histogram appearance.\n            Supported arguments include:\n            - figsize : tuple, optional\n                Figure size as (width, height) in inches, by default (5, 5).\n            - bins : int, optional\n                Number of histogram bins, by default 15.\n            - color : List[str], optional\n                Colors for the histogram bars, by default [\"#0504aa\"].\n                For 2D data, the number of colors should match the number of columns.\n            - alpha : float, optional\n                Transparency of the histogram bars, by default 0.7.\n                Values range from 0 (transparent) to 1 (opaque).\n            - rwidth : float, optional\n                Relative width of the bars, by default 0.85.\n                Values range from 0 to 1.\n            - grid_alpha : float, optional\n                Transparency of the grid lines, by default 0.75.\n            - xlabel, ylabel : str, optional\n                Labels for the x and y axes.\n            - xlabel_font_size, ylabel_font_size : int, optional\n                Font sizes for the axis labels.\n            - xtick_font_size, ytick_font_size : int, optional\n                Font sizes for the axis tick labels.\n\n        Examples\n        --------\n        Initialize with default options:\n        ```python\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from cleopatra.statistics import Statistic\n        &gt;&gt;&gt; np.random.seed(1)\n        &gt;&gt;&gt; x = np.random.normal(0, 1, 100)\n        &gt;&gt;&gt; stat = Statistic(x)\n\n        ```\n        Initialize with custom options:\n        ```python\n        &gt;&gt;&gt; stat_custom = Statistic(\n        ...     x,\n        ...     figsize=(8, 6),\n        ...     bins=20,\n        ...     color=[\"#FF5733\"],\n        ...     alpha=0.5,\n        ...     rwidth=0.9,\n        ...     xlabel=\"Values\",\n        ...     ylabel=\"Frequency\",\n        ...     xlabel_font_size=14,\n        ...     ylabel_font_size=14\n        ... )\n\n        ```\n        Initialize with 2D data:\n        ```python\n        &gt;&gt;&gt; data_2d = np.random.normal(0, 1, (100, 3))\n        &gt;&gt;&gt; stat_2d = Statistic(\n        ...     data_2d,\n        ...     color=[\"red\", \"green\", \"blue\"],\n        ...     alpha=0.4\n        ... )\n\n        ```\n        \"\"\"\n        self._values = values\n        options_dict = DEFAULT_OPTIONS.copy()\n        options_dict.update(kwargs)\n        self._default_options = options_dict\n\n    @property\n    def values(self):\n        \"\"\"Get the numerical values to be plotted.\n\n        Returns\n        -------\n        numpy.ndarray or list\n            The numerical values stored in the object, which can be:\n            - 1D array/list for a single histogram\n            - 2D array/list for multiple histograms (one per column)\n\n        Examples\n        --------\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from cleopatra.statistics import Statistic\n        &gt;&gt;&gt; np.random.seed(1)\n        &gt;&gt;&gt; x = np.random.normal(0, 1, 100)\n        &gt;&gt;&gt; stat = Statistic(x)\n        &gt;&gt;&gt; values = stat.values\n        &gt;&gt;&gt; values.shape\n        (100,)\n        \"\"\"\n        return self._values\n\n    @values.setter\n    def values(self, values):\n        \"\"\"Set the numerical values to be plotted.\n\n        Parameters\n        ----------\n        values : numpy.ndarray or list\n            The new numerical values to be plotted as histograms. Can be:\n            - 1D array/list for a single histogram\n            - 2D array/list for multiple histograms (one per column)\n\n        Examples\n        --------\n        ```python\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from cleopatra.statistics import Statistic\n        &gt;&gt;&gt; np.random.seed(1)\n        &gt;&gt;&gt; x1 = np.random.normal(0, 1, 100)\n        &gt;&gt;&gt; stat = Statistic(x1)\n        &gt;&gt;&gt; # Update with new values\n        &gt;&gt;&gt; x2 = np.random.normal(5, 2, 100)\n        &gt;&gt;&gt; stat.values = x2\n\n        ```\n        \"\"\"\n        self._values = values\n\n    @property\n    def default_options(self) -&gt; Dict:\n        \"\"\"Get the default options for histogram plotting.\n\n        This property returns the dictionary of default options used for creating\n        histogram plots. These options can be modified by passing keyword arguments\n        to the class constructor or to the histogram method.\n\n        Returns\n        -------\n        Dict\n            A dictionary containing the default options for histogram plotting, including:\n            - figsize : tuple\n                Figure size as (width, height) in inches.\n            - bins : int\n                Number of histogram bins.\n            - color : List[str]\n                Colors for the histogram bars.\n            - alpha : float\n                Transparency of the histogram bars.\n            - rwidth : float\n                Relative width of the bars.\n            - grid_alpha : float\n                Transparency of the grid lines.\n            - xlabel, ylabel : str\n                Labels for the x and y axes.\n            - xlabel_font_size, ylabel_font_size : int\n                Font sizes for the axis labels.\n            - xtick_font_size, ytick_font_size : int\n                Font sizes for the axis tick labels.\n\n        Examples\n        --------\n        ```python\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from cleopatra.statistics import Statistic\n        &gt;&gt;&gt; np.random.seed(1)\n        &gt;&gt;&gt; x = np.random.normal(0, 1, 100)\n        &gt;&gt;&gt; stat = Statistic(x)\n        &gt;&gt;&gt; options = stat.default_options\n        &gt;&gt;&gt; print(options['bins'])\n        15\n        &gt;&gt;&gt; print(options['alpha'])\n        0.7\n\n        ```\n        \"\"\"\n        return self._default_options\n\n    def histogram(self, **kwargs) -&gt; [Figure, Axes, Dict]:\n        \"\"\"Create a histogram from the stored numerical values.\n\n        This method generates a histogram visualization of the numerical values stored\n        in the object. It can handle both 1D data (single histogram) and 2D data\n        (multiple histograms overlaid on the same plot).\n\n        Parameters\n        ----------\n        **kwargs : dict, optional\n            Additional keyword arguments to customize the histogram appearance.\n            These will override any options set during initialization.\n            Supported arguments include:\n            - figsize : tuple, optional\n                Figure size as (width, height) in inches, by default (5, 5).\n            - bins : int, optional\n                Number of histogram bins, by default 15.\n            - color : List[str], optional\n                Colors for the histogram bars, by default [\"#0504aa\"].\n                For 2D data, the number of colors should match the number of columns.\n            - alpha : float, optional\n                Transparency of the histogram bars, by default 0.7.\n                Values range from 0 (transparent) to 1 (opaque).\n            - rwidth : float, optional\n                Relative width of the bars, by default 0.85.\n                Values range from 0 to 1.\n            - grid_alpha : float, optional\n                Transparency of the grid lines, by default 0.75.\n            - xlabel, ylabel : str, optional\n                Labels for the x and y axes.\n            - xlabel_font_size, ylabel_font_size : int, optional\n                Font sizes for the axis labels.\n            - xtick_font_size, ytick_font_size : int, optional\n                Font sizes for the axis tick labels.\n\n        Returns\n        -------\n        Figure\n            The matplotlib Figure object containing the histogram.\n        Axes\n            The matplotlib Axes object on which the histogram is drawn.\n        Dict\n            A dictionary containing the histogram data with keys:\n            - 'n': List of arrays containing the histogram bin counts\n            - 'bins': List of arrays containing the bin edges\n            - 'patches': List of BarContainer objects representing the histogram bars\n\n        Raises\n        ------\n        ValueError\n            If an invalid keyword argument is provided.\n        ValueError\n            If the number of colors provided doesn't match the number of data series\n            (columns) in 2D data.\n\n        Notes\n        -----\n        For 2D data, multiple histograms will be overlaid on the same plot with\n        different colors. The transparency (alpha) can be adjusted to make overlapping\n        regions visible.\n\n        Examples\n        --------\n        Create a histogram from 1D data:\n        ```python\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from cleopatra.statistics import Statistic\n        &gt;&gt;&gt; np.random.seed(1)\n        &gt;&gt;&gt; x = 4 + np.random.normal(0, 1.5, 200)\n        &gt;&gt;&gt; stat_plot = Statistic(x)\n        &gt;&gt;&gt; fig, ax, hist = stat_plot.histogram()\n\n        ```\n        Create a histogram with custom bin count and labels:\n        ```python\n        &gt;&gt;&gt; fig, ax, hist = stat_plot.histogram(\n        ...     bins=20,\n        ...     xlabel=\"Values\",\n        ...     ylabel=\"Frequency\",\n        ...     xlabel_font_size=14,\n        ...     ylabel_font_size=14\n        ... )\n\n        ```\n        Create a histogram from 2D data with custom colors:\n        ```python\n        &gt;&gt;&gt; np.random.seed(1)\n        &gt;&gt;&gt; x = 4 + np.random.normal(0, 1.5, (200, 3))\n        &gt;&gt;&gt; stat_plot = Statistic(x)\n        &gt;&gt;&gt; fig, ax, hist = stat_plot.histogram(\n        ...     color=[\"red\", \"green\", \"blue\"],\n        ...     alpha=0.4,\n        ...     rwidth=0.8\n        ... )\n\n        ```\n        Access the histogram data:\n        ```python\n        &gt;&gt;&gt; # Get the bin counts for the first data series\n        &gt;&gt;&gt; bin_counts = hist['n'][0]\n        &gt;&gt;&gt; # Get the bin edges for the first data series\n        &gt;&gt;&gt; bin_edges = hist['bins'][0]\n\n        ```\n        \"\"\"\n        for key, val in kwargs.items():\n            if key not in self.default_options.keys():\n                raise ValueError(\n                    f\"The given keyword argument:{key} is not correct, possible parameters are,\"\n                    f\" {self.default_options}\"\n                )\n            else:\n                self.default_options[key] = val\n\n        fig, ax = plt.subplots(figsize=self.default_options[\"figsize\"])\n\n        n = []\n        bins = []\n        patches = []\n        bins_val = self.default_options[\"bins\"]\n        color = self.default_options[\"color\"]\n        alpha = self.default_options[\"alpha\"]\n        rwidth = self.default_options[\"rwidth\"]\n        if self.values.ndim == 2:\n            num_samples = self.values.shape[1]\n            if len(color) != num_samples:\n                raise ValueError(\n                    f\"The number of colors:{len(color)} should be equal to the number of samples:{num_samples}\"\n                )\n        else:\n            num_samples = 1\n\n        for i in range(num_samples):\n            if self.values.ndim == 1:\n                vals = self.values\n            else:\n                vals = self.values[:, i]\n\n            n_i, bins_i, patches_i = ax.hist(\n                x=vals,\n                bins=bins_val,\n                color=color[i],\n                alpha=alpha,\n                rwidth=rwidth,\n            )\n            n.append(n_i)\n            bins.append(bins_i)\n            patches.append(patches_i)\n\n        plt.grid(axis=\"y\", alpha=self.default_options[\"grid_alpha\"])\n        plt.xlabel(\n            self.default_options[\"xlabel\"],\n            fontsize=self.default_options[\"xlabel_font_size\"],\n        )\n        plt.ylabel(\n            self.default_options[\"ylabel\"],\n            fontsize=self.default_options[\"ylabel_font_size\"],\n        )\n        plt.xticks(fontsize=self.default_options[\"xtick_font_size\"])\n        plt.yticks(fontsize=self.default_options[\"ytick_font_size\"])\n        hist = {\"n\": n, \"bins\": bins, \"patches\": patches}\n        plt.show()\n        return fig, ax, hist\n</code></pre>"},{"location":"api/statistics-class/#cleopatra.statistics.Statistic.default_options","title":"<code>default_options</code>  <code>property</code>","text":"<p>Get the default options for histogram plotting.</p> <p>This property returns the dictionary of default options used for creating histogram plots. These options can be modified by passing keyword arguments to the class constructor or to the histogram method.</p> <p>Returns:</p> Type Description <code>Dict</code> <p>A dictionary containing the default options for histogram plotting, including: - figsize : tuple     Figure size as (width, height) in inches. - bins : int     Number of histogram bins. - color : List[str]     Colors for the histogram bars. - alpha : float     Transparency of the histogram bars. - rwidth : float     Relative width of the bars. - grid_alpha : float     Transparency of the grid lines. - xlabel, ylabel : str     Labels for the x and y axes. - xlabel_font_size, ylabel_font_size : int     Font sizes for the axis labels. - xtick_font_size, ytick_font_size : int     Font sizes for the axis tick labels.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from cleopatra.statistics import Statistic\n&gt;&gt;&gt; np.random.seed(1)\n&gt;&gt;&gt; x = np.random.normal(0, 1, 100)\n&gt;&gt;&gt; stat = Statistic(x)\n&gt;&gt;&gt; options = stat.default_options\n&gt;&gt;&gt; print(options['bins'])\n15\n&gt;&gt;&gt; print(options['alpha'])\n0.7\n</code></pre>"},{"location":"api/statistics-class/#cleopatra.statistics.Statistic.values","title":"<code>values</code>  <code>property</code> <code>writable</code>","text":"<p>Get the numerical values to be plotted.</p> <p>Returns:</p> Type Description <code>ndarray or list</code> <p>The numerical values stored in the object, which can be: - 1D array/list for a single histogram - 2D array/list for multiple histograms (one per column)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from cleopatra.statistics import Statistic\n&gt;&gt;&gt; np.random.seed(1)\n&gt;&gt;&gt; x = np.random.normal(0, 1, 100)\n&gt;&gt;&gt; stat = Statistic(x)\n&gt;&gt;&gt; values = stat.values\n&gt;&gt;&gt; values.shape\n(100,)\n</code></pre>"},{"location":"api/statistics-class/#cleopatra.statistics.Statistic.__init__","title":"<code>__init__(values, **kwargs)</code>","text":"<p>Initialize the Statistic object with values and optional customization parameters.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Union[List, ndarray]</code> <p>The numerical values to be plotted as histograms. Can be: - 1D array/list for a single histogram - 2D array/list for multiple histograms (one per column)</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to customize the histogram appearance. Supported arguments include: - figsize : tuple, optional     Figure size as (width, height) in inches, by default (5, 5). - bins : int, optional     Number of histogram bins, by default 15. - color : List[str], optional     Colors for the histogram bars, by default [\"#0504aa\"].     For 2D data, the number of colors should match the number of columns. - alpha : float, optional     Transparency of the histogram bars, by default 0.7.     Values range from 0 (transparent) to 1 (opaque). - rwidth : float, optional     Relative width of the bars, by default 0.85.     Values range from 0 to 1. - grid_alpha : float, optional     Transparency of the grid lines, by default 0.75. - xlabel, ylabel : str, optional     Labels for the x and y axes. - xlabel_font_size, ylabel_font_size : int, optional     Font sizes for the axis labels. - xtick_font_size, ytick_font_size : int, optional     Font sizes for the axis tick labels.</p> <code>{}</code> <p>Examples:</p> <p>Initialize with default options: <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from cleopatra.statistics import Statistic\n&gt;&gt;&gt; np.random.seed(1)\n&gt;&gt;&gt; x = np.random.normal(0, 1, 100)\n&gt;&gt;&gt; stat = Statistic(x)\n</code></pre> Initialize with custom options: <pre><code>&gt;&gt;&gt; stat_custom = Statistic(\n...     x,\n...     figsize=(8, 6),\n...     bins=20,\n...     color=[\"#FF5733\"],\n...     alpha=0.5,\n...     rwidth=0.9,\n...     xlabel=\"Values\",\n...     ylabel=\"Frequency\",\n...     xlabel_font_size=14,\n...     ylabel_font_size=14\n... )\n</code></pre> Initialize with 2D data: <pre><code>&gt;&gt;&gt; data_2d = np.random.normal(0, 1, (100, 3))\n&gt;&gt;&gt; stat_2d = Statistic(\n...     data_2d,\n...     color=[\"red\", \"green\", \"blue\"],\n...     alpha=0.4\n... )\n</code></pre></p> Source code in <code>cleopatra/statistics.py</code> <pre><code>def __init__(\n    self,\n    values: Union[List, np.ndarray],\n    **kwargs,\n):\n    \"\"\"Initialize the Statistic object with values and optional customization parameters.\n\n    Parameters\n    ----------\n    values : Union[List, np.ndarray]\n        The numerical values to be plotted as histograms. Can be:\n        - 1D array/list for a single histogram\n        - 2D array/list for multiple histograms (one per column)\n    **kwargs : dict, optional\n        Additional keyword arguments to customize the histogram appearance.\n        Supported arguments include:\n        - figsize : tuple, optional\n            Figure size as (width, height) in inches, by default (5, 5).\n        - bins : int, optional\n            Number of histogram bins, by default 15.\n        - color : List[str], optional\n            Colors for the histogram bars, by default [\"#0504aa\"].\n            For 2D data, the number of colors should match the number of columns.\n        - alpha : float, optional\n            Transparency of the histogram bars, by default 0.7.\n            Values range from 0 (transparent) to 1 (opaque).\n        - rwidth : float, optional\n            Relative width of the bars, by default 0.85.\n            Values range from 0 to 1.\n        - grid_alpha : float, optional\n            Transparency of the grid lines, by default 0.75.\n        - xlabel, ylabel : str, optional\n            Labels for the x and y axes.\n        - xlabel_font_size, ylabel_font_size : int, optional\n            Font sizes for the axis labels.\n        - xtick_font_size, ytick_font_size : int, optional\n            Font sizes for the axis tick labels.\n\n    Examples\n    --------\n    Initialize with default options:\n    ```python\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from cleopatra.statistics import Statistic\n    &gt;&gt;&gt; np.random.seed(1)\n    &gt;&gt;&gt; x = np.random.normal(0, 1, 100)\n    &gt;&gt;&gt; stat = Statistic(x)\n\n    ```\n    Initialize with custom options:\n    ```python\n    &gt;&gt;&gt; stat_custom = Statistic(\n    ...     x,\n    ...     figsize=(8, 6),\n    ...     bins=20,\n    ...     color=[\"#FF5733\"],\n    ...     alpha=0.5,\n    ...     rwidth=0.9,\n    ...     xlabel=\"Values\",\n    ...     ylabel=\"Frequency\",\n    ...     xlabel_font_size=14,\n    ...     ylabel_font_size=14\n    ... )\n\n    ```\n    Initialize with 2D data:\n    ```python\n    &gt;&gt;&gt; data_2d = np.random.normal(0, 1, (100, 3))\n    &gt;&gt;&gt; stat_2d = Statistic(\n    ...     data_2d,\n    ...     color=[\"red\", \"green\", \"blue\"],\n    ...     alpha=0.4\n    ... )\n\n    ```\n    \"\"\"\n    self._values = values\n    options_dict = DEFAULT_OPTIONS.copy()\n    options_dict.update(kwargs)\n    self._default_options = options_dict\n</code></pre>"},{"location":"api/statistics-class/#cleopatra.statistics.Statistic.histogram","title":"<code>histogram(**kwargs)</code>","text":"<p>Create a histogram from the stored numerical values.</p> <p>This method generates a histogram visualization of the numerical values stored in the object. It can handle both 1D data (single histogram) and 2D data (multiple histograms overlaid on the same plot).</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to customize the histogram appearance. These will override any options set during initialization. Supported arguments include: - figsize : tuple, optional     Figure size as (width, height) in inches, by default (5, 5). - bins : int, optional     Number of histogram bins, by default 15. - color : List[str], optional     Colors for the histogram bars, by default [\"#0504aa\"].     For 2D data, the number of colors should match the number of columns. - alpha : float, optional     Transparency of the histogram bars, by default 0.7.     Values range from 0 (transparent) to 1 (opaque). - rwidth : float, optional     Relative width of the bars, by default 0.85.     Values range from 0 to 1. - grid_alpha : float, optional     Transparency of the grid lines, by default 0.75. - xlabel, ylabel : str, optional     Labels for the x and y axes. - xlabel_font_size, ylabel_font_size : int, optional     Font sizes for the axis labels. - xtick_font_size, ytick_font_size : int, optional     Font sizes for the axis tick labels.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Figure</code> <p>The matplotlib Figure object containing the histogram.</p> <code>Axes</code> <p>The matplotlib Axes object on which the histogram is drawn.</p> <code>Dict</code> <p>A dictionary containing the histogram data with keys: - 'n': List of arrays containing the histogram bin counts - 'bins': List of arrays containing the bin edges - 'patches': List of BarContainer objects representing the histogram bars</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid keyword argument is provided.</p> <code>ValueError</code> <p>If the number of colors provided doesn't match the number of data series (columns) in 2D data.</p> Notes <p>For 2D data, multiple histograms will be overlaid on the same plot with different colors. The transparency (alpha) can be adjusted to make overlapping regions visible.</p> <p>Examples:</p> <p>Create a histogram from 1D data: <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from cleopatra.statistics import Statistic\n&gt;&gt;&gt; np.random.seed(1)\n&gt;&gt;&gt; x = 4 + np.random.normal(0, 1.5, 200)\n&gt;&gt;&gt; stat_plot = Statistic(x)\n&gt;&gt;&gt; fig, ax, hist = stat_plot.histogram()\n</code></pre> Create a histogram with custom bin count and labels: <pre><code>&gt;&gt;&gt; fig, ax, hist = stat_plot.histogram(\n...     bins=20,\n...     xlabel=\"Values\",\n...     ylabel=\"Frequency\",\n...     xlabel_font_size=14,\n...     ylabel_font_size=14\n... )\n</code></pre> Create a histogram from 2D data with custom colors: <pre><code>&gt;&gt;&gt; np.random.seed(1)\n&gt;&gt;&gt; x = 4 + np.random.normal(0, 1.5, (200, 3))\n&gt;&gt;&gt; stat_plot = Statistic(x)\n&gt;&gt;&gt; fig, ax, hist = stat_plot.histogram(\n...     color=[\"red\", \"green\", \"blue\"],\n...     alpha=0.4,\n...     rwidth=0.8\n... )\n</code></pre> Access the histogram data: <pre><code>&gt;&gt;&gt; # Get the bin counts for the first data series\n&gt;&gt;&gt; bin_counts = hist['n'][0]\n&gt;&gt;&gt; # Get the bin edges for the first data series\n&gt;&gt;&gt; bin_edges = hist['bins'][0]\n</code></pre></p> Source code in <code>cleopatra/statistics.py</code> <pre><code>def histogram(self, **kwargs) -&gt; [Figure, Axes, Dict]:\n    \"\"\"Create a histogram from the stored numerical values.\n\n    This method generates a histogram visualization of the numerical values stored\n    in the object. It can handle both 1D data (single histogram) and 2D data\n    (multiple histograms overlaid on the same plot).\n\n    Parameters\n    ----------\n    **kwargs : dict, optional\n        Additional keyword arguments to customize the histogram appearance.\n        These will override any options set during initialization.\n        Supported arguments include:\n        - figsize : tuple, optional\n            Figure size as (width, height) in inches, by default (5, 5).\n        - bins : int, optional\n            Number of histogram bins, by default 15.\n        - color : List[str], optional\n            Colors for the histogram bars, by default [\"#0504aa\"].\n            For 2D data, the number of colors should match the number of columns.\n        - alpha : float, optional\n            Transparency of the histogram bars, by default 0.7.\n            Values range from 0 (transparent) to 1 (opaque).\n        - rwidth : float, optional\n            Relative width of the bars, by default 0.85.\n            Values range from 0 to 1.\n        - grid_alpha : float, optional\n            Transparency of the grid lines, by default 0.75.\n        - xlabel, ylabel : str, optional\n            Labels for the x and y axes.\n        - xlabel_font_size, ylabel_font_size : int, optional\n            Font sizes for the axis labels.\n        - xtick_font_size, ytick_font_size : int, optional\n            Font sizes for the axis tick labels.\n\n    Returns\n    -------\n    Figure\n        The matplotlib Figure object containing the histogram.\n    Axes\n        The matplotlib Axes object on which the histogram is drawn.\n    Dict\n        A dictionary containing the histogram data with keys:\n        - 'n': List of arrays containing the histogram bin counts\n        - 'bins': List of arrays containing the bin edges\n        - 'patches': List of BarContainer objects representing the histogram bars\n\n    Raises\n    ------\n    ValueError\n        If an invalid keyword argument is provided.\n    ValueError\n        If the number of colors provided doesn't match the number of data series\n        (columns) in 2D data.\n\n    Notes\n    -----\n    For 2D data, multiple histograms will be overlaid on the same plot with\n    different colors. The transparency (alpha) can be adjusted to make overlapping\n    regions visible.\n\n    Examples\n    --------\n    Create a histogram from 1D data:\n    ```python\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from cleopatra.statistics import Statistic\n    &gt;&gt;&gt; np.random.seed(1)\n    &gt;&gt;&gt; x = 4 + np.random.normal(0, 1.5, 200)\n    &gt;&gt;&gt; stat_plot = Statistic(x)\n    &gt;&gt;&gt; fig, ax, hist = stat_plot.histogram()\n\n    ```\n    Create a histogram with custom bin count and labels:\n    ```python\n    &gt;&gt;&gt; fig, ax, hist = stat_plot.histogram(\n    ...     bins=20,\n    ...     xlabel=\"Values\",\n    ...     ylabel=\"Frequency\",\n    ...     xlabel_font_size=14,\n    ...     ylabel_font_size=14\n    ... )\n\n    ```\n    Create a histogram from 2D data with custom colors:\n    ```python\n    &gt;&gt;&gt; np.random.seed(1)\n    &gt;&gt;&gt; x = 4 + np.random.normal(0, 1.5, (200, 3))\n    &gt;&gt;&gt; stat_plot = Statistic(x)\n    &gt;&gt;&gt; fig, ax, hist = stat_plot.histogram(\n    ...     color=[\"red\", \"green\", \"blue\"],\n    ...     alpha=0.4,\n    ...     rwidth=0.8\n    ... )\n\n    ```\n    Access the histogram data:\n    ```python\n    &gt;&gt;&gt; # Get the bin counts for the first data series\n    &gt;&gt;&gt; bin_counts = hist['n'][0]\n    &gt;&gt;&gt; # Get the bin edges for the first data series\n    &gt;&gt;&gt; bin_edges = hist['bins'][0]\n\n    ```\n    \"\"\"\n    for key, val in kwargs.items():\n        if key not in self.default_options.keys():\n            raise ValueError(\n                f\"The given keyword argument:{key} is not correct, possible parameters are,\"\n                f\" {self.default_options}\"\n            )\n        else:\n            self.default_options[key] = val\n\n    fig, ax = plt.subplots(figsize=self.default_options[\"figsize\"])\n\n    n = []\n    bins = []\n    patches = []\n    bins_val = self.default_options[\"bins\"]\n    color = self.default_options[\"color\"]\n    alpha = self.default_options[\"alpha\"]\n    rwidth = self.default_options[\"rwidth\"]\n    if self.values.ndim == 2:\n        num_samples = self.values.shape[1]\n        if len(color) != num_samples:\n            raise ValueError(\n                f\"The number of colors:{len(color)} should be equal to the number of samples:{num_samples}\"\n            )\n    else:\n        num_samples = 1\n\n    for i in range(num_samples):\n        if self.values.ndim == 1:\n            vals = self.values\n        else:\n            vals = self.values[:, i]\n\n        n_i, bins_i, patches_i = ax.hist(\n            x=vals,\n            bins=bins_val,\n            color=color[i],\n            alpha=alpha,\n            rwidth=rwidth,\n        )\n        n.append(n_i)\n        bins.append(bins_i)\n        patches.append(patches_i)\n\n    plt.grid(axis=\"y\", alpha=self.default_options[\"grid_alpha\"])\n    plt.xlabel(\n        self.default_options[\"xlabel\"],\n        fontsize=self.default_options[\"xlabel_font_size\"],\n    )\n    plt.ylabel(\n        self.default_options[\"ylabel\"],\n        fontsize=self.default_options[\"ylabel_font_size\"],\n    )\n    plt.xticks(fontsize=self.default_options[\"xtick_font_size\"])\n    plt.yticks(fontsize=self.default_options[\"ytick_font_size\"])\n    hist = {\"n\": n, \"bins\": bins, \"patches\": patches}\n    plt.show()\n    return fig, ax, hist\n</code></pre>"},{"location":"api/statistics-class/#examples","title":"Examples","text":""},{"location":"api/statistics-class/#1d-data-example","title":"1D Data Example","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom cleopatra.statistics import Statistic\n\n# Create some random 1D data\nnp.random.seed(1)\ndata_1d = 4 + np.random.normal(0, 1.5, 200)\n\n# Create a Statistic object with the 1D data\nstat_plot_1d = Statistic(data_1d)\n\n# Generate a histogram plot for the 1D data\nfig_1d, ax_1d, hist_1d = stat_plot_1d.histogram()\n</code></pre>"},{"location":"api/statistics-class/#2d-data-example","title":"2D Data Example","text":"<pre><code># Create some random 2D data\ndata_2d = 4 + np.random.normal(0, 1.5, (200, 3))\n\n# Create a Statistic object with the 2D data\nstat_plot_2d = Statistic(data_2d, color=[\"red\", \"green\", \"blue\"], alpha=0.4, rwidth=0.8)\n\n# Generate a histogram plot for the 2D data\nfig_2d, ax_2d, hist_2d = stat_plot_2d.histogram()\n</code></pre>"},{"location":"api/styles-class/","title":"Styles Module","text":"<p>The <code>styles</code> module provides classes and functions for styling plots, including line styles, marker styles, scaling functions, and color normalization.</p>"},{"location":"api/styles-class/#styles-class","title":"Styles Class","text":""},{"location":"api/styles-class/#cleopatra.styles.Styles","title":"<code>cleopatra.styles.Styles</code>","text":"<p>A class providing line and marker styles for matplotlib plots.</p> <p>This class contains collections of predefined line styles and marker styles that can be used to customize matplotlib plots. It provides static methods to retrieve these styles by name or index.</p> <p>Attributes:</p> Name Type Description <code>line_styles</code> <code>OrderedDict</code> <p>A dictionary of line style definitions, mapping style names to matplotlib line style tuples. Each tuple defines the line style pattern.</p> <code>marker_style_list</code> <code>list</code> <p>A list of marker style strings that combine line styles with markers.</p> <p>Methods:</p> Name Description <code>get_line_style</code> <p>Get a line style tuple by name or index.</p> <code>get_marker_style</code> <p>Get a marker style string by index.</p> Notes <p>Line styles define the pattern of the line (solid, dashed, dotted, etc.), while marker styles define both the line pattern and the marker shape (circle, square, triangle, etc.) used at data points.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from cleopatra.styles import Styles\n&gt;&gt;&gt; # Get a line style by name\n&gt;&gt;&gt; solid_line = Styles.get_line_style(\"solid\")\n&gt;&gt;&gt; # Get a line style by index\n&gt;&gt;&gt; dashed_line = Styles.get_line_style(5)  # \"dashed\"\n&gt;&gt;&gt; # Get a marker style\n&gt;&gt;&gt; marker_style = Styles.get_marker_style(0)  # \"--o\"\n</code></pre> Source code in <code>cleopatra/styles.py</code> <pre><code>class Styles:\n    \"\"\"A class providing line and marker styles for matplotlib plots.\n\n    This class contains collections of predefined line styles and marker styles\n    that can be used to customize matplotlib plots. It provides static methods\n    to retrieve these styles by name or index.\n\n    Attributes\n    ----------\n    line_styles : OrderedDict\n        A dictionary of line style definitions, mapping style names to\n        matplotlib line style tuples. Each tuple defines the line style pattern.\n    marker_style_list : list\n        A list of marker style strings that combine line styles with markers.\n\n    Methods\n    -------\n    get_line_style(style)\n        Get a line style tuple by name or index.\n    get_marker_style(style)\n        Get a marker style string by index.\n\n    Notes\n    -----\n    Line styles define the pattern of the line (solid, dashed, dotted, etc.),\n    while marker styles define both the line pattern and the marker shape\n    (circle, square, triangle, etc.) used at data points.\n\n    Examples\n    --------\n    ```python\n    &gt;&gt;&gt; from cleopatra.styles import Styles\n    &gt;&gt;&gt; # Get a line style by name\n    &gt;&gt;&gt; solid_line = Styles.get_line_style(\"solid\")\n    &gt;&gt;&gt; # Get a line style by index\n    &gt;&gt;&gt; dashed_line = Styles.get_line_style(5)  # \"dashed\"\n    &gt;&gt;&gt; # Get a marker style\n    &gt;&gt;&gt; marker_style = Styles.get_marker_style(0)  # \"--o\"\n\n    ```\n    \"\"\"\n\n    line_styles = OrderedDict(\n        [\n            (\"solid\", (0, ())),  # 0\n            (\"loosely dotted\", (0, (1, 10))),  # 1\n            (\"dotted\", (0, (1, 5))),  # 2\n            (\"densely dotted\", (0, (1, 1))),  # 3\n            (\"loosely dashed\", (0, (5, 10))),  # 4\n            (\"dashed\", (0, (5, 5))),  # 5\n            (\"densely dashed\", (0, (5, 1))),  # 6\n            (\"loosely dashdotted\", (0, (3, 10, 1, 10))),  # 7\n            (\"dashdotted\", (0, (3, 5, 1, 5))),  # 8\n            (\"densely dashdotted\", (0, (3, 1, 1, 1))),  # 9\n            (\"loosely dashdotdotted\", (0, (3, 10, 1, 10, 1, 10))),  # 10\n            (\"dashdotdotted\", (0, (3, 5, 1, 5, 1, 5))),  # 11\n            (\"densely dashdotdotted\", (0, (3, 1, 1, 1, 1, 1))),  # 12\n            (\"densely dashdotdottededited\", (0, (6, 1, 1, 1, 1, 1))),  # 13\n        ]\n    )\n\n    marker_style_list = [\n        \"--o\",\n        \":D\",\n        \"-.H\",\n        \"--x\",\n        \":v\",\n        \"--|\",\n        \"-+\",\n        \"-^\",\n        \"--s\",\n        \"-.*\",\n        \"-.h\",\n    ]\n\n    @staticmethod\n    def get_line_style(style: Union[str, int] = \"loosely dotted\"):\n        \"\"\"Get a matplotlib line style tuple by name or index.\n\n        This method retrieves a line style tuple that can be used with matplotlib\n        plotting functions to customize the appearance of lines. The style can be\n        specified either by name (string) or by index (integer).\n\n        Parameters\n        ----------\n        style : Union[str, int], optional\n            The line style to retrieve, by default \"loosely dotted\".\n            If a string, it should be one of the keys in the `line_styles` dictionary.\n            If an integer, it should be an index into the `line_styles` dictionary.\n            Available style names:\n            - \"solid\"\n            - \"loosely dotted\"\n            - \"dotted\"\n            - \"densely dotted\"\n            - \"loosely dashed\"\n            - \"dashed\"\n            - \"densely dashed\"\n            - \"loosely dashdotted\"\n            - \"dashdotted\"\n            - \"densely dashdotted\"\n            - \"loosely dashdotdotted\"\n            - \"dashdotdotted\"\n            - \"densely dashdotdotted\"\n            - \"densely dashdotdottededited\"\n\n        Returns\n        -------\n        tuple\n            A matplotlib line style tuple that can be used with plot functions.\n            The tuple format is (offset, (on_off_seq)) where:\n            - offset is usually 0\n            - on_off_seq is a sequence of on/off lengths in points\n\n        Raises\n        ------\n        KeyError\n            If the style name provided does not exist in the `line_styles` dictionary.\n            In this case, a message is printed and the available styles are listed.\n\n        Examples\n        --------\n        Get a line style by name:\n        ```python\n        &gt;&gt;&gt; from cleopatra.styles import Styles\n        &gt;&gt;&gt; solid = Styles.get_line_style(\"solid\")\n        &gt;&gt;&gt; solid\n        (0, ())\n\n        ```\n        Get a line style by index:\n        ```python\n        &gt;&gt;&gt; dashed = Styles.get_line_style(5)  # \"dashed\"\n        &gt;&gt;&gt; dashed\n        (0, (5, 5))\n\n        ```\n        Use a line style in a matplotlib plot:\n        ```python\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; x = np.linspace(0, 10, 100)\n        &gt;&gt;&gt; y = np.sin(x)\n        &gt;&gt;&gt; plt.plot(x, y, linestyle=Styles.get_line_style(\"dashed\"))  # doctest: +SKIP\n\n        ```\n        \"\"\"\n        if isinstance(style, str):\n            try:\n                return Styles.line_styles[style]\n            except KeyError:\n                msg = (\n                    f\" The style name you entered-{style}-does not exist please\"\n                    \"choose from the available styles\"\n                )\n                print(msg)\n                print(list(Styles.line_styles))\n        else:\n            return list(Styles.line_styles.items())[style][1]\n\n    @staticmethod\n    def get_marker_style(style: int):\n        \"\"\"Get a matplotlib marker style string by index.\n\n        This method retrieves a marker style string that can be used with matplotlib\n        plotting functions to customize the appearance of markers and lines. The style\n        is specified by an index into the `marker_style_list`.\n\n        Parameters\n        ----------\n        style : int\n            The index of the marker style to retrieve from the `marker_style_list`.\n            If the index is out of range, it will be wrapped around using modulo\n            operation to ensure a valid style is always returned.\n\n        Returns\n        -------\n        str\n            A matplotlib marker style string that combines line style and marker.\n            Examples: \"--o\" (dashed line with circle markers), \":D\" (dotted line with\n            diamond markers), etc.\n\n        Notes\n        -----\n        The marker style strings use matplotlib's shorthand notation:\n        - Line styles: \"-\" (solid), \"--\" (dashed), \"-.\" (dash-dot), \":\" (dotted)\n        - Markers: \"o\" (circle), \"D\" (diamond), \"s\" (square), \"^\" (triangle up), etc.\n\n        Examples\n        --------\n        Get a marker style by index:\n        ```python\n        &gt;&gt;&gt; from cleopatra.styles import Styles\n        &gt;&gt;&gt; # Get the first marker style\n        &gt;&gt;&gt; style0 = Styles.get_marker_style(0)\n        &gt;&gt;&gt; style0\n        '--o'\n\n        &gt;&gt;&gt; # Get another marker style\n        &gt;&gt;&gt; style1 = Styles.get_marker_style(1)\n        &gt;&gt;&gt; style1\n        ':D'\n\n        ```\n        Handle index out of range (wraps around):\n        ```python\n        &gt;&gt;&gt; # If we have 11 styles and request index 15, we get style at index 15 % 11 = 4\n        &gt;&gt;&gt; len(Styles.marker_style_list)\n        11\n        &gt;&gt;&gt; style15 = Styles.get_marker_style(15)  # Same as style4\n        &gt;&gt;&gt; style4 = Styles.get_marker_style(4)\n        &gt;&gt;&gt; style15 == style4\n        True\n\n        ```\n        Use a marker style in a matplotlib plot:\n        ```python\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; x = np.linspace(0, 10, 20)\n        &gt;&gt;&gt; y = np.sin(x)\n        &gt;&gt;&gt; plt.plot(x, y, Styles.get_marker_style(0))  # doctest: +SKIP\n\n        ```\n        \"\"\"\n        if style &gt; len(Styles.marker_style_list) - 1:\n            style = style % len(Styles.marker_style_list)\n        return Styles.marker_style_list[style]\n</code></pre>"},{"location":"api/styles-class/#cleopatra.styles.Styles.get_line_style","title":"<code>get_line_style(style='loosely dotted')</code>  <code>staticmethod</code>","text":"<p>Get a matplotlib line style tuple by name or index.</p> <p>This method retrieves a line style tuple that can be used with matplotlib plotting functions to customize the appearance of lines. The style can be specified either by name (string) or by index (integer).</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>Union[str, int]</code> <p>The line style to retrieve, by default \"loosely dotted\". If a string, it should be one of the keys in the <code>line_styles</code> dictionary. If an integer, it should be an index into the <code>line_styles</code> dictionary. Available style names: - \"solid\" - \"loosely dotted\" - \"dotted\" - \"densely dotted\" - \"loosely dashed\" - \"dashed\" - \"densely dashed\" - \"loosely dashdotted\" - \"dashdotted\" - \"densely dashdotted\" - \"loosely dashdotdotted\" - \"dashdotdotted\" - \"densely dashdotdotted\" - \"densely dashdotdottededited\"</p> <code>'loosely dotted'</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A matplotlib line style tuple that can be used with plot functions. The tuple format is (offset, (on_off_seq)) where: - offset is usually 0 - on_off_seq is a sequence of on/off lengths in points</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the style name provided does not exist in the <code>line_styles</code> dictionary. In this case, a message is printed and the available styles are listed.</p> <p>Examples:</p> <p>Get a line style by name: <pre><code>&gt;&gt;&gt; from cleopatra.styles import Styles\n&gt;&gt;&gt; solid = Styles.get_line_style(\"solid\")\n&gt;&gt;&gt; solid\n(0, ())\n</code></pre> Get a line style by index: <pre><code>&gt;&gt;&gt; dashed = Styles.get_line_style(5)  # \"dashed\"\n&gt;&gt;&gt; dashed\n(0, (5, 5))\n</code></pre> Use a line style in a matplotlib plot: <pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; x = np.linspace(0, 10, 100)\n&gt;&gt;&gt; y = np.sin(x)\n&gt;&gt;&gt; plt.plot(x, y, linestyle=Styles.get_line_style(\"dashed\"))  # doctest: +SKIP\n</code></pre></p> Source code in <code>cleopatra/styles.py</code> <pre><code>@staticmethod\ndef get_line_style(style: Union[str, int] = \"loosely dotted\"):\n    \"\"\"Get a matplotlib line style tuple by name or index.\n\n    This method retrieves a line style tuple that can be used with matplotlib\n    plotting functions to customize the appearance of lines. The style can be\n    specified either by name (string) or by index (integer).\n\n    Parameters\n    ----------\n    style : Union[str, int], optional\n        The line style to retrieve, by default \"loosely dotted\".\n        If a string, it should be one of the keys in the `line_styles` dictionary.\n        If an integer, it should be an index into the `line_styles` dictionary.\n        Available style names:\n        - \"solid\"\n        - \"loosely dotted\"\n        - \"dotted\"\n        - \"densely dotted\"\n        - \"loosely dashed\"\n        - \"dashed\"\n        - \"densely dashed\"\n        - \"loosely dashdotted\"\n        - \"dashdotted\"\n        - \"densely dashdotted\"\n        - \"loosely dashdotdotted\"\n        - \"dashdotdotted\"\n        - \"densely dashdotdotted\"\n        - \"densely dashdotdottededited\"\n\n    Returns\n    -------\n    tuple\n        A matplotlib line style tuple that can be used with plot functions.\n        The tuple format is (offset, (on_off_seq)) where:\n        - offset is usually 0\n        - on_off_seq is a sequence of on/off lengths in points\n\n    Raises\n    ------\n    KeyError\n        If the style name provided does not exist in the `line_styles` dictionary.\n        In this case, a message is printed and the available styles are listed.\n\n    Examples\n    --------\n    Get a line style by name:\n    ```python\n    &gt;&gt;&gt; from cleopatra.styles import Styles\n    &gt;&gt;&gt; solid = Styles.get_line_style(\"solid\")\n    &gt;&gt;&gt; solid\n    (0, ())\n\n    ```\n    Get a line style by index:\n    ```python\n    &gt;&gt;&gt; dashed = Styles.get_line_style(5)  # \"dashed\"\n    &gt;&gt;&gt; dashed\n    (0, (5, 5))\n\n    ```\n    Use a line style in a matplotlib plot:\n    ```python\n    &gt;&gt;&gt; import matplotlib.pyplot as plt\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; x = np.linspace(0, 10, 100)\n    &gt;&gt;&gt; y = np.sin(x)\n    &gt;&gt;&gt; plt.plot(x, y, linestyle=Styles.get_line_style(\"dashed\"))  # doctest: +SKIP\n\n    ```\n    \"\"\"\n    if isinstance(style, str):\n        try:\n            return Styles.line_styles[style]\n        except KeyError:\n            msg = (\n                f\" The style name you entered-{style}-does not exist please\"\n                \"choose from the available styles\"\n            )\n            print(msg)\n            print(list(Styles.line_styles))\n    else:\n        return list(Styles.line_styles.items())[style][1]\n</code></pre>"},{"location":"api/styles-class/#cleopatra.styles.Styles.get_marker_style","title":"<code>get_marker_style(style)</code>  <code>staticmethod</code>","text":"<p>Get a matplotlib marker style string by index.</p> <p>This method retrieves a marker style string that can be used with matplotlib plotting functions to customize the appearance of markers and lines. The style is specified by an index into the <code>marker_style_list</code>.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>int</code> <p>The index of the marker style to retrieve from the <code>marker_style_list</code>. If the index is out of range, it will be wrapped around using modulo operation to ensure a valid style is always returned.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A matplotlib marker style string that combines line style and marker. Examples: \"--o\" (dashed line with circle markers), \":D\" (dotted line with diamond markers), etc.</p> Notes <p>The marker style strings use matplotlib's shorthand notation: - Line styles: \"-\" (solid), \"--\" (dashed), \"-.\" (dash-dot), \":\" (dotted) - Markers: \"o\" (circle), \"D\" (diamond), \"s\" (square), \"^\" (triangle up), etc.</p> <p>Examples:</p> <p>Get a marker style by index: <pre><code>&gt;&gt;&gt; from cleopatra.styles import Styles\n&gt;&gt;&gt; # Get the first marker style\n&gt;&gt;&gt; style0 = Styles.get_marker_style(0)\n&gt;&gt;&gt; style0\n'--o'\n\n&gt;&gt;&gt; # Get another marker style\n&gt;&gt;&gt; style1 = Styles.get_marker_style(1)\n&gt;&gt;&gt; style1\n':D'\n</code></pre> Handle index out of range (wraps around): <pre><code>&gt;&gt;&gt; # If we have 11 styles and request index 15, we get style at index 15 % 11 = 4\n&gt;&gt;&gt; len(Styles.marker_style_list)\n11\n&gt;&gt;&gt; style15 = Styles.get_marker_style(15)  # Same as style4\n&gt;&gt;&gt; style4 = Styles.get_marker_style(4)\n&gt;&gt;&gt; style15 == style4\nTrue\n</code></pre> Use a marker style in a matplotlib plot: <pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; x = np.linspace(0, 10, 20)\n&gt;&gt;&gt; y = np.sin(x)\n&gt;&gt;&gt; plt.plot(x, y, Styles.get_marker_style(0))  # doctest: +SKIP\n</code></pre></p> Source code in <code>cleopatra/styles.py</code> <pre><code>@staticmethod\ndef get_marker_style(style: int):\n    \"\"\"Get a matplotlib marker style string by index.\n\n    This method retrieves a marker style string that can be used with matplotlib\n    plotting functions to customize the appearance of markers and lines. The style\n    is specified by an index into the `marker_style_list`.\n\n    Parameters\n    ----------\n    style : int\n        The index of the marker style to retrieve from the `marker_style_list`.\n        If the index is out of range, it will be wrapped around using modulo\n        operation to ensure a valid style is always returned.\n\n    Returns\n    -------\n    str\n        A matplotlib marker style string that combines line style and marker.\n        Examples: \"--o\" (dashed line with circle markers), \":D\" (dotted line with\n        diamond markers), etc.\n\n    Notes\n    -----\n    The marker style strings use matplotlib's shorthand notation:\n    - Line styles: \"-\" (solid), \"--\" (dashed), \"-.\" (dash-dot), \":\" (dotted)\n    - Markers: \"o\" (circle), \"D\" (diamond), \"s\" (square), \"^\" (triangle up), etc.\n\n    Examples\n    --------\n    Get a marker style by index:\n    ```python\n    &gt;&gt;&gt; from cleopatra.styles import Styles\n    &gt;&gt;&gt; # Get the first marker style\n    &gt;&gt;&gt; style0 = Styles.get_marker_style(0)\n    &gt;&gt;&gt; style0\n    '--o'\n\n    &gt;&gt;&gt; # Get another marker style\n    &gt;&gt;&gt; style1 = Styles.get_marker_style(1)\n    &gt;&gt;&gt; style1\n    ':D'\n\n    ```\n    Handle index out of range (wraps around):\n    ```python\n    &gt;&gt;&gt; # If we have 11 styles and request index 15, we get style at index 15 % 11 = 4\n    &gt;&gt;&gt; len(Styles.marker_style_list)\n    11\n    &gt;&gt;&gt; style15 = Styles.get_marker_style(15)  # Same as style4\n    &gt;&gt;&gt; style4 = Styles.get_marker_style(4)\n    &gt;&gt;&gt; style15 == style4\n    True\n\n    ```\n    Use a marker style in a matplotlib plot:\n    ```python\n    &gt;&gt;&gt; import matplotlib.pyplot as plt\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; x = np.linspace(0, 10, 20)\n    &gt;&gt;&gt; y = np.sin(x)\n    &gt;&gt;&gt; plt.plot(x, y, Styles.get_marker_style(0))  # doctest: +SKIP\n\n    ```\n    \"\"\"\n    if style &gt; len(Styles.marker_style_list) - 1:\n        style = style % len(Styles.marker_style_list)\n    return Styles.marker_style_list[style]\n</code></pre>"},{"location":"api/styles-class/#scale-class","title":"Scale Class","text":""},{"location":"api/styles-class/#cleopatra.styles.Scale","title":"<code>cleopatra.styles.Scale</code>","text":"<p>A class providing various scaling functions for data visualization.</p> <p>This class contains static methods for different types of scaling operations that can be used to transform data values for visualization purposes. These include logarithmic scaling, power scaling, identity scaling, and general value rescaling between different ranges.</p> <p>Methods:</p> Name Description <code>log_scale</code> <p>Apply logarithmic (base 10) scaling to a value.</p> <code>power_scale</code> <p>Create a power scaling function based on a minimum value.</p> <code>identity_scale</code> <p>Create an identity scaling function that always returns 2.</p> <code>rescale</code> <p>Rescale a value from one range to another.</p> Notes <p>Scaling functions are useful for transforming data to improve visualization, especially when dealing with data that spans multiple orders of magnitude or needs to be normalized to a specific range.</p> <p>Examples:</p> <p>Apply logarithmic scaling: <pre><code>&gt;&gt;&gt; from cleopatra.styles import Scale\n&gt;&gt;&gt; Scale.log_scale(100)\nnp.float64(2.0)\n&gt;&gt;&gt; Scale.log_scale(1000)\nnp.float64(3.0)\n</code></pre> Rescale a value from one range to another: <pre><code>&gt;&gt;&gt; Scale.rescale(5, 0, 10, 0, 100)  # 5 is 50% of [0,10], so 50% of [0,100] is 50\n50.0\n&gt;&gt;&gt; Scale.rescale(75, 0, 100, -1, 1)  # 75 is 75% of [0,100], so 75% of [-1,1] is 0.5\n0.5\n</code></pre></p> Source code in <code>cleopatra/styles.py</code> <pre><code>class Scale:\n    \"\"\"A class providing various scaling functions for data visualization.\n\n    This class contains static methods for different types of scaling operations\n    that can be used to transform data values for visualization purposes. These\n    include logarithmic scaling, power scaling, identity scaling, and general\n    value rescaling between different ranges.\n\n    Methods\n    -------\n    log_scale(val)\n        Apply logarithmic (base 10) scaling to a value.\n    power_scale(min_val)\n        Create a power scaling function based on a minimum value.\n    identity_scale(min_val, max_val)\n        Create an identity scaling function that always returns 2.\n    rescale(old_value, old_min, old_max, new_min, new_max)\n        Rescale a value from one range to another.\n\n    Notes\n    -----\n    Scaling functions are useful for transforming data to improve visualization,\n    especially when dealing with data that spans multiple orders of magnitude or\n    needs to be normalized to a specific range.\n\n    Examples\n    --------\n    Apply logarithmic scaling:\n    ```python\n    &gt;&gt;&gt; from cleopatra.styles import Scale\n    &gt;&gt;&gt; Scale.log_scale(100)\n    np.float64(2.0)\n    &gt;&gt;&gt; Scale.log_scale(1000)\n    np.float64(3.0)\n\n    ```\n    Rescale a value from one range to another:\n    ```python\n    &gt;&gt;&gt; Scale.rescale(5, 0, 10, 0, 100)  # 5 is 50% of [0,10], so 50% of [0,100] is 50\n    50.0\n    &gt;&gt;&gt; Scale.rescale(75, 0, 100, -1, 1)  # 75 is 75% of [0,100], so 75% of [-1,1] is 0.5\n    0.5\n\n    ```\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize a Scale object.\n\n        Note that this class is primarily intended to be used via its static methods,\n        so initialization is not typically necessary.\n        \"\"\"\n        pass\n\n    @staticmethod\n    def log_scale(val):\n        \"\"\"Apply logarithmic (base 10) scaling to a value or array.\n\n        This method computes the base-10 logarithm of the input value(s),\n        which is useful for visualizing data that spans multiple orders of magnitude.\n\n        Parameters\n        ----------\n        val : float or numpy.ndarray\n            The value or array of values to be logarithmically scaled.\n            Must be positive (greater than 0) to avoid math domain errors.\n\n        Returns\n        -------\n        float or numpy.ndarray\n            The base-10 logarithm of the input value(s).\n            If the input is an array, the output will be an array of the same shape.\n\n        Notes\n        -----\n        Logarithmic scaling is particularly useful for:\n        - Data that spans multiple orders of magnitude\n        - Compressing wide ranges of values into a more manageable range\n        - Visualizing exponential growth or decay\n\n        Examples\n        --------\n        Scale a single value:\n        ```python\n        &gt;&gt;&gt; from cleopatra.styles import Scale\n        &gt;&gt;&gt; Scale.log_scale(100)\n        np.float64(2.0)\n        &gt;&gt;&gt; Scale.log_scale(1000)\n        np.float64(3.0)\n\n        ```\n        Scale an array of values:\n        ```python\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; values = np.array([1, 10, 100, 1000])\n        &gt;&gt;&gt; Scale.log_scale(values)\n        array([0., 1., 2., 3.])\n\n        ```\n        \"\"\"\n        return np.log10(val)\n\n    @staticmethod\n    def power_scale(min_val) -&gt; callable:\n        \"\"\"Create a power scaling function based on a minimum value.\n\n        This method returns a function that applies power scaling to its input.\n        The scaling function first shifts the input value by adding the absolute\n        value of the minimum value plus 1 (to ensure positive values), then\n        divides by 1000 and squares the result.\n\n        Parameters\n        ----------\n        min_val : float\n            The minimum value in the data range. Used to shift the data to ensure\n            all values are positive before applying the power transformation.\n\n        Returns\n        -------\n        callable\n            A function that takes a value or array and returns the power-scaled result.\n            The returned function has the signature: f(val) -&gt; float or numpy.ndarray\n\n        Notes\n        -----\n        Power scaling is useful for:\n        - Emphasizing differences in smaller values\n        - Compressing the range of larger values\n        - Creating non-linear visualizations where small changes in small values\n          are more important than small changes in large values\n\n        Examples\n        --------\n        Create a power scaling function and apply it to values:\n        ```python\n        &gt;&gt;&gt; from cleopatra.styles import Scale\n        &gt;&gt;&gt; # Create a scaling function with minimum value -10\n        &gt;&gt;&gt; scale_func = Scale.power_scale(-10)\n        &gt;&gt;&gt; # Apply to a single value\n        &gt;&gt;&gt; scale_func(5)  # (5 + |-10| + 1) / 1000)^2 = (5 + 10 + 1)^2 / 1000000 = 16^2 / 1000000 = 256 / 1000000 = 0.000256\n        0.000256\n        &gt;&gt;&gt; # Apply to another value\n        &gt;&gt;&gt; scale_func(100)  # (100 + |-10| + 1) / 1000)^2 = (100 + 10 + 1)^2 / 1000000 = 111^2 / 1000000 = 12321 / 1000000 \u2248 0.012321\n        0.012321\n\n        ```\n        Apply to an array of values:\n        ```python\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; values = np.array([0, 10, 100])\n        &gt;&gt;&gt; scale_func = Scale.power_scale(-5)\n        &gt;&gt;&gt; scale_func(values)  # doctest: +ELLIPSIS\n        array([3.6000e-05, 2.5600e-04, 1.1236e-02])\n\n        &gt;&gt;&gt; # [(0+5+1)/1000]^2, [(10+5+1)/1000]^2, [(100+5+1)/1000]^2]\n        ```\n        \"\"\"\n\n        def scalar(val):\n            val = val + abs(min_val) + 1\n            return (val / 1000) ** 2\n\n        return scalar\n\n    @staticmethod\n    def identity_scale(min_val, max_val):\n        \"\"\"Create a constant scaling function that always returns 2.\n\n        This method returns a function that ignores its input and always returns\n        the constant value 2. Despite its name, this is not a true identity function\n        (which would return the input unchanged), but rather a constant function.\n\n        Parameters\n        ----------\n        min_val : float\n            The minimum value in the data range. This parameter is not used in the\n            implementation but is included for API consistency with other scaling methods.\n        max_val : float\n            The maximum value in the data range. This parameter is not used in the\n            implementation but is included for API consistency with other scaling methods.\n\n        Returns\n        -------\n        callable\n            A function that takes any input and always returns 2.\n            The returned function has the signature: f(val) -&gt; int\n\n        Notes\n        -----\n        This function can be useful in situations where:\n        - A constant size or value is needed regardless of the input data\n        - A placeholder scaling function is required\n        - Testing or debugging code that expects a scaling function\n\n        Examples\n        --------\n        Create and use the constant scaling function:\n        ```python\n        &gt;&gt;&gt; from cleopatra.styles import Scale\n        &gt;&gt;&gt; scale_func = Scale.identity_scale(0, 100)  # min_val and max_val are ignored\n        &gt;&gt;&gt; scale_func(5)  # Returns 2 regardless of input\n        2\n        &gt;&gt;&gt; scale_func(100)  # Still returns 2\n        2\n        &gt;&gt;&gt; scale_func(-10)  # Still returns 2\n        2\n\n        ```\n        Works with arrays too, but returns a scalar, not an array:\n        ```python\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; values = np.array([1, 2, 3, 4, 5])\n        &gt;&gt;&gt; scale_func(values)  # Returns scalar 2, not an array of 2s\n        2\n\n        ```\n        \"\"\"\n\n        def scalar(val):\n            return 2\n\n        return scalar\n\n    @staticmethod\n    def rescale(old_value, old_min, old_max, new_min, new_max):\n        \"\"\"Rescale a value from one range to another.\n\n        This method performs linear rescaling of a value from an original range\n        [old_min, old_max] to a new range [new_min, new_max]. The transformation\n        preserves the relative position of the value within its range.\n\n        Parameters\n        ----------\n        old_value : float or numpy.ndarray\n            The value(s) to be rescaled. Can be a single value or an array.\n        old_min : float\n            The minimum value of the original range.\n        old_max : float\n            The maximum value of the original range.\n        new_min : float\n            The minimum value of the target range.\n        new_max : float\n            The maximum value of the target range.\n\n        Returns\n        -------\n        float or numpy.ndarray\n            The rescaled value(s) in the new range. If the input is an array,\n            the output will be an array of the same shape.\n\n        Notes\n        -----\n        The rescaling formula is:\n        new_value = (((old_value - old_min) * (new_max - new_min)) / (old_max - old_min)) + new_min\n\n        This function is useful for:\n        - Normalizing data to a specific range (e.g., [0, 1])\n        - Converting between different units or scales\n        - Preparing data for visualization with specific bounds\n\n        Examples\n        --------\n        Rescale a value from [0, 10] to [0, 100]:\n        ```python\n        &gt;&gt;&gt; from cleopatra.styles import Scale\n        &gt;&gt;&gt; Scale.rescale(5, 0, 10, 0, 100)  # 5 is 50% of [0,10], so 50% of [0,100] is 50\n        50.0\n\n        ```\n        Rescale a value from [0, 100] to [-1, 1]:\n        ```python\n        &gt;&gt;&gt; Scale.rescale(75, 0, 100, -1, 1)  # 75 is 75% of [0,100], so 75% of [-1,1] is 0.5\n        0.5\n\n        ```\n        Rescale an array of values:\n        ```python\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; values = np.array([0, 5, 10])\n        &gt;&gt;&gt; Scale.rescale(values, 0, 10, 0, 1)  # Normalize to [0,1]\n        array([0. , 0.5, 1. ])\n\n        ```\n        Invert a range by swapping the new min and max:\n        ```python\n        &gt;&gt;&gt; Scale.rescale(25, 0, 100, 1, 0)  # 25 is 25% from min, so 25% from max in new range is 0.75\n        0.75\n\n        ```\n        \"\"\"\n        old_range = old_max - old_min\n        new_range = new_max - new_min\n        new_value = (((old_value - old_min) * new_range) / old_range) + new_min\n\n        return new_value\n</code></pre>"},{"location":"api/styles-class/#cleopatra.styles.Scale.__init__","title":"<code>__init__()</code>","text":"<p>Initialize a Scale object.</p> <p>Note that this class is primarily intended to be used via its static methods, so initialization is not typically necessary.</p> Source code in <code>cleopatra/styles.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize a Scale object.\n\n    Note that this class is primarily intended to be used via its static methods,\n    so initialization is not typically necessary.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/styles-class/#cleopatra.styles.Scale.identity_scale","title":"<code>identity_scale(min_val, max_val)</code>  <code>staticmethod</code>","text":"<p>Create a constant scaling function that always returns 2.</p> <p>This method returns a function that ignores its input and always returns the constant value 2. Despite its name, this is not a true identity function (which would return the input unchanged), but rather a constant function.</p> <p>Parameters:</p> Name Type Description Default <code>min_val</code> <code>float</code> <p>The minimum value in the data range. This parameter is not used in the implementation but is included for API consistency with other scaling methods.</p> required <code>max_val</code> <code>float</code> <p>The maximum value in the data range. This parameter is not used in the implementation but is included for API consistency with other scaling methods.</p> required <p>Returns:</p> Type Description <code>callable</code> <p>A function that takes any input and always returns 2. The returned function has the signature: f(val) -&gt; int</p> Notes <p>This function can be useful in situations where: - A constant size or value is needed regardless of the input data - A placeholder scaling function is required - Testing or debugging code that expects a scaling function</p> <p>Examples:</p> <p>Create and use the constant scaling function: <pre><code>&gt;&gt;&gt; from cleopatra.styles import Scale\n&gt;&gt;&gt; scale_func = Scale.identity_scale(0, 100)  # min_val and max_val are ignored\n&gt;&gt;&gt; scale_func(5)  # Returns 2 regardless of input\n2\n&gt;&gt;&gt; scale_func(100)  # Still returns 2\n2\n&gt;&gt;&gt; scale_func(-10)  # Still returns 2\n2\n</code></pre> Works with arrays too, but returns a scalar, not an array: <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; values = np.array([1, 2, 3, 4, 5])\n&gt;&gt;&gt; scale_func(values)  # Returns scalar 2, not an array of 2s\n2\n</code></pre></p> Source code in <code>cleopatra/styles.py</code> <pre><code>@staticmethod\ndef identity_scale(min_val, max_val):\n    \"\"\"Create a constant scaling function that always returns 2.\n\n    This method returns a function that ignores its input and always returns\n    the constant value 2. Despite its name, this is not a true identity function\n    (which would return the input unchanged), but rather a constant function.\n\n    Parameters\n    ----------\n    min_val : float\n        The minimum value in the data range. This parameter is not used in the\n        implementation but is included for API consistency with other scaling methods.\n    max_val : float\n        The maximum value in the data range. This parameter is not used in the\n        implementation but is included for API consistency with other scaling methods.\n\n    Returns\n    -------\n    callable\n        A function that takes any input and always returns 2.\n        The returned function has the signature: f(val) -&gt; int\n\n    Notes\n    -----\n    This function can be useful in situations where:\n    - A constant size or value is needed regardless of the input data\n    - A placeholder scaling function is required\n    - Testing or debugging code that expects a scaling function\n\n    Examples\n    --------\n    Create and use the constant scaling function:\n    ```python\n    &gt;&gt;&gt; from cleopatra.styles import Scale\n    &gt;&gt;&gt; scale_func = Scale.identity_scale(0, 100)  # min_val and max_val are ignored\n    &gt;&gt;&gt; scale_func(5)  # Returns 2 regardless of input\n    2\n    &gt;&gt;&gt; scale_func(100)  # Still returns 2\n    2\n    &gt;&gt;&gt; scale_func(-10)  # Still returns 2\n    2\n\n    ```\n    Works with arrays too, but returns a scalar, not an array:\n    ```python\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; values = np.array([1, 2, 3, 4, 5])\n    &gt;&gt;&gt; scale_func(values)  # Returns scalar 2, not an array of 2s\n    2\n\n    ```\n    \"\"\"\n\n    def scalar(val):\n        return 2\n\n    return scalar\n</code></pre>"},{"location":"api/styles-class/#cleopatra.styles.Scale.log_scale","title":"<code>log_scale(val)</code>  <code>staticmethod</code>","text":"<p>Apply logarithmic (base 10) scaling to a value or array.</p> <p>This method computes the base-10 logarithm of the input value(s), which is useful for visualizing data that spans multiple orders of magnitude.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>float or ndarray</code> <p>The value or array of values to be logarithmically scaled. Must be positive (greater than 0) to avoid math domain errors.</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>The base-10 logarithm of the input value(s). If the input is an array, the output will be an array of the same shape.</p> Notes <p>Logarithmic scaling is particularly useful for: - Data that spans multiple orders of magnitude - Compressing wide ranges of values into a more manageable range - Visualizing exponential growth or decay</p> <p>Examples:</p> <p>Scale a single value: <pre><code>&gt;&gt;&gt; from cleopatra.styles import Scale\n&gt;&gt;&gt; Scale.log_scale(100)\nnp.float64(2.0)\n&gt;&gt;&gt; Scale.log_scale(1000)\nnp.float64(3.0)\n</code></pre> Scale an array of values: <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; values = np.array([1, 10, 100, 1000])\n&gt;&gt;&gt; Scale.log_scale(values)\narray([0., 1., 2., 3.])\n</code></pre></p> Source code in <code>cleopatra/styles.py</code> <pre><code>@staticmethod\ndef log_scale(val):\n    \"\"\"Apply logarithmic (base 10) scaling to a value or array.\n\n    This method computes the base-10 logarithm of the input value(s),\n    which is useful for visualizing data that spans multiple orders of magnitude.\n\n    Parameters\n    ----------\n    val : float or numpy.ndarray\n        The value or array of values to be logarithmically scaled.\n        Must be positive (greater than 0) to avoid math domain errors.\n\n    Returns\n    -------\n    float or numpy.ndarray\n        The base-10 logarithm of the input value(s).\n        If the input is an array, the output will be an array of the same shape.\n\n    Notes\n    -----\n    Logarithmic scaling is particularly useful for:\n    - Data that spans multiple orders of magnitude\n    - Compressing wide ranges of values into a more manageable range\n    - Visualizing exponential growth or decay\n\n    Examples\n    --------\n    Scale a single value:\n    ```python\n    &gt;&gt;&gt; from cleopatra.styles import Scale\n    &gt;&gt;&gt; Scale.log_scale(100)\n    np.float64(2.0)\n    &gt;&gt;&gt; Scale.log_scale(1000)\n    np.float64(3.0)\n\n    ```\n    Scale an array of values:\n    ```python\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; values = np.array([1, 10, 100, 1000])\n    &gt;&gt;&gt; Scale.log_scale(values)\n    array([0., 1., 2., 3.])\n\n    ```\n    \"\"\"\n    return np.log10(val)\n</code></pre>"},{"location":"api/styles-class/#cleopatra.styles.Scale.power_scale","title":"<code>power_scale(min_val)</code>  <code>staticmethod</code>","text":"<p>Create a power scaling function based on a minimum value.</p> <p>This method returns a function that applies power scaling to its input. The scaling function first shifts the input value by adding the absolute value of the minimum value plus 1 (to ensure positive values), then divides by 1000 and squares the result.</p> <p>Parameters:</p> Name Type Description Default <code>min_val</code> <code>float</code> <p>The minimum value in the data range. Used to shift the data to ensure all values are positive before applying the power transformation.</p> required <p>Returns:</p> Type Description <code>callable</code> <p>A function that takes a value or array and returns the power-scaled result. The returned function has the signature: f(val) -&gt; float or numpy.ndarray</p> Notes <p>Power scaling is useful for: - Emphasizing differences in smaller values - Compressing the range of larger values - Creating non-linear visualizations where small changes in small values   are more important than small changes in large values</p> <p>Examples:</p> <p>Create a power scaling function and apply it to values: <pre><code>&gt;&gt;&gt; from cleopatra.styles import Scale\n&gt;&gt;&gt; # Create a scaling function with minimum value -10\n&gt;&gt;&gt; scale_func = Scale.power_scale(-10)\n&gt;&gt;&gt; # Apply to a single value\n&gt;&gt;&gt; scale_func(5)  # (5 + |-10| + 1) / 1000)^2 = (5 + 10 + 1)^2 / 1000000 = 16^2 / 1000000 = 256 / 1000000 = 0.000256\n0.000256\n&gt;&gt;&gt; # Apply to another value\n&gt;&gt;&gt; scale_func(100)  # (100 + |-10| + 1) / 1000)^2 = (100 + 10 + 1)^2 / 1000000 = 111^2 / 1000000 = 12321 / 1000000 \u2248 0.012321\n0.012321\n</code></pre> Apply to an array of values: <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; values = np.array([0, 10, 100])\n&gt;&gt;&gt; scale_func = Scale.power_scale(-5)\n&gt;&gt;&gt; scale_func(values)  # doctest: +ELLIPSIS\narray([3.6000e-05, 2.5600e-04, 1.1236e-02])\n\n&gt;&gt;&gt; # [(0+5+1)/1000]^2, [(10+5+1)/1000]^2, [(100+5+1)/1000]^2]\n</code></pre></p> Source code in <code>cleopatra/styles.py</code> <pre><code>@staticmethod\ndef power_scale(min_val) -&gt; callable:\n    \"\"\"Create a power scaling function based on a minimum value.\n\n    This method returns a function that applies power scaling to its input.\n    The scaling function first shifts the input value by adding the absolute\n    value of the minimum value plus 1 (to ensure positive values), then\n    divides by 1000 and squares the result.\n\n    Parameters\n    ----------\n    min_val : float\n        The minimum value in the data range. Used to shift the data to ensure\n        all values are positive before applying the power transformation.\n\n    Returns\n    -------\n    callable\n        A function that takes a value or array and returns the power-scaled result.\n        The returned function has the signature: f(val) -&gt; float or numpy.ndarray\n\n    Notes\n    -----\n    Power scaling is useful for:\n    - Emphasizing differences in smaller values\n    - Compressing the range of larger values\n    - Creating non-linear visualizations where small changes in small values\n      are more important than small changes in large values\n\n    Examples\n    --------\n    Create a power scaling function and apply it to values:\n    ```python\n    &gt;&gt;&gt; from cleopatra.styles import Scale\n    &gt;&gt;&gt; # Create a scaling function with minimum value -10\n    &gt;&gt;&gt; scale_func = Scale.power_scale(-10)\n    &gt;&gt;&gt; # Apply to a single value\n    &gt;&gt;&gt; scale_func(5)  # (5 + |-10| + 1) / 1000)^2 = (5 + 10 + 1)^2 / 1000000 = 16^2 / 1000000 = 256 / 1000000 = 0.000256\n    0.000256\n    &gt;&gt;&gt; # Apply to another value\n    &gt;&gt;&gt; scale_func(100)  # (100 + |-10| + 1) / 1000)^2 = (100 + 10 + 1)^2 / 1000000 = 111^2 / 1000000 = 12321 / 1000000 \u2248 0.012321\n    0.012321\n\n    ```\n    Apply to an array of values:\n    ```python\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; values = np.array([0, 10, 100])\n    &gt;&gt;&gt; scale_func = Scale.power_scale(-5)\n    &gt;&gt;&gt; scale_func(values)  # doctest: +ELLIPSIS\n    array([3.6000e-05, 2.5600e-04, 1.1236e-02])\n\n    &gt;&gt;&gt; # [(0+5+1)/1000]^2, [(10+5+1)/1000]^2, [(100+5+1)/1000]^2]\n    ```\n    \"\"\"\n\n    def scalar(val):\n        val = val + abs(min_val) + 1\n        return (val / 1000) ** 2\n\n    return scalar\n</code></pre>"},{"location":"api/styles-class/#cleopatra.styles.Scale.rescale","title":"<code>rescale(old_value, old_min, old_max, new_min, new_max)</code>  <code>staticmethod</code>","text":"<p>Rescale a value from one range to another.</p> <p>This method performs linear rescaling of a value from an original range [old_min, old_max] to a new range [new_min, new_max]. The transformation preserves the relative position of the value within its range.</p> <p>Parameters:</p> Name Type Description Default <code>old_value</code> <code>float or ndarray</code> <p>The value(s) to be rescaled. Can be a single value or an array.</p> required <code>old_min</code> <code>float</code> <p>The minimum value of the original range.</p> required <code>old_max</code> <code>float</code> <p>The maximum value of the original range.</p> required <code>new_min</code> <code>float</code> <p>The minimum value of the target range.</p> required <code>new_max</code> <code>float</code> <p>The maximum value of the target range.</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>The rescaled value(s) in the new range. If the input is an array, the output will be an array of the same shape.</p> Notes <p>The rescaling formula is: new_value = (((old_value - old_min) * (new_max - new_min)) / (old_max - old_min)) + new_min</p> <p>This function is useful for: - Normalizing data to a specific range (e.g., [0, 1]) - Converting between different units or scales - Preparing data for visualization with specific bounds</p> <p>Examples:</p> <p>Rescale a value from [0, 10] to [0, 100]: <pre><code>&gt;&gt;&gt; from cleopatra.styles import Scale\n&gt;&gt;&gt; Scale.rescale(5, 0, 10, 0, 100)  # 5 is 50% of [0,10], so 50% of [0,100] is 50\n50.0\n</code></pre> Rescale a value from [0, 100] to [-1, 1]: <pre><code>&gt;&gt;&gt; Scale.rescale(75, 0, 100, -1, 1)  # 75 is 75% of [0,100], so 75% of [-1,1] is 0.5\n0.5\n</code></pre> Rescale an array of values: <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; values = np.array([0, 5, 10])\n&gt;&gt;&gt; Scale.rescale(values, 0, 10, 0, 1)  # Normalize to [0,1]\narray([0. , 0.5, 1. ])\n</code></pre> Invert a range by swapping the new min and max: <pre><code>&gt;&gt;&gt; Scale.rescale(25, 0, 100, 1, 0)  # 25 is 25% from min, so 25% from max in new range is 0.75\n0.75\n</code></pre></p> Source code in <code>cleopatra/styles.py</code> <pre><code>@staticmethod\ndef rescale(old_value, old_min, old_max, new_min, new_max):\n    \"\"\"Rescale a value from one range to another.\n\n    This method performs linear rescaling of a value from an original range\n    [old_min, old_max] to a new range [new_min, new_max]. The transformation\n    preserves the relative position of the value within its range.\n\n    Parameters\n    ----------\n    old_value : float or numpy.ndarray\n        The value(s) to be rescaled. Can be a single value or an array.\n    old_min : float\n        The minimum value of the original range.\n    old_max : float\n        The maximum value of the original range.\n    new_min : float\n        The minimum value of the target range.\n    new_max : float\n        The maximum value of the target range.\n\n    Returns\n    -------\n    float or numpy.ndarray\n        The rescaled value(s) in the new range. If the input is an array,\n        the output will be an array of the same shape.\n\n    Notes\n    -----\n    The rescaling formula is:\n    new_value = (((old_value - old_min) * (new_max - new_min)) / (old_max - old_min)) + new_min\n\n    This function is useful for:\n    - Normalizing data to a specific range (e.g., [0, 1])\n    - Converting between different units or scales\n    - Preparing data for visualization with specific bounds\n\n    Examples\n    --------\n    Rescale a value from [0, 10] to [0, 100]:\n    ```python\n    &gt;&gt;&gt; from cleopatra.styles import Scale\n    &gt;&gt;&gt; Scale.rescale(5, 0, 10, 0, 100)  # 5 is 50% of [0,10], so 50% of [0,100] is 50\n    50.0\n\n    ```\n    Rescale a value from [0, 100] to [-1, 1]:\n    ```python\n    &gt;&gt;&gt; Scale.rescale(75, 0, 100, -1, 1)  # 75 is 75% of [0,100], so 75% of [-1,1] is 0.5\n    0.5\n\n    ```\n    Rescale an array of values:\n    ```python\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; values = np.array([0, 5, 10])\n    &gt;&gt;&gt; Scale.rescale(values, 0, 10, 0, 1)  # Normalize to [0,1]\n    array([0. , 0.5, 1. ])\n\n    ```\n    Invert a range by swapping the new min and max:\n    ```python\n    &gt;&gt;&gt; Scale.rescale(25, 0, 100, 1, 0)  # 25 is 25% from min, so 25% from max in new range is 0.75\n    0.75\n\n    ```\n    \"\"\"\n    old_range = old_max - old_min\n    new_range = new_max - new_min\n    new_value = (((old_value - old_min) * new_range) / old_range) + new_min\n\n    return new_value\n</code></pre>"},{"location":"api/styles-class/#midpointnormalize-class","title":"MidpointNormalize Class","text":""},{"location":"api/styles-class/#cleopatra.styles.MidpointNormalize","title":"<code>cleopatra.styles.MidpointNormalize</code>","text":"<p>               Bases: <code>Normalize</code></p> <p>A normalization class that scales data with a midpoint.</p> <p>This class extends matplotlib's Normalize class to create a colormap normalization that has a fixed midpoint. This is useful for data that has a natural midpoint (like zero) where the colormap should be centered, regardless of the actual data range.</p> <p>The normalization maps values to the range [0, 1] with the midpoint mapped to 0.5, which allows for symmetric colormaps to be properly centered.</p> <p>Parameters:</p> Name Type Description Default <code>vmin</code> <code>float</code> <p>The minimum data value that corresponds to 0 in the normalized data. If None, it is automatically calculated from the data.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum data value that corresponds to 1 in the normalized data. If None, it is automatically calculated from the data.</p> <code>None</code> <code>midpoint</code> <code>float</code> <p>The data value that corresponds to 0.5 in the normalized data. If None, it defaults to the midpoint between vmin and vmax.</p> <code>None</code> <code>clip</code> <code>bool</code> <p>If True, values outside the [vmin, vmax] range are clipped to be within that range, by default False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>midpoint</code> <code>float</code> <p>The data value that will be mapped to 0.5 in the normalized data.</p> Notes <p>This normalization is particularly useful for: - Diverging colormaps where a specific value should be at the center - Data with positive and negative values where zero should be the midpoint - Highlighting deviations from a reference value</p> <p>Examples:</p> <p>Create a plot with a midpoint normalization: <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from cleopatra.styles import MidpointNormalize\n&gt;&gt;&gt; # Create some data with positive and negative values\n&gt;&gt;&gt; data = np.linspace(-10, 10, 100)\n&gt;&gt;&gt; # Create a normalization with midpoint at 0\n&gt;&gt;&gt; norm = MidpointNormalize(vmin=-10, vmax=10, midpoint=0)\n&gt;&gt;&gt; # Use in a plot\n&gt;&gt;&gt; plt.figure(figsize=(8, 1)) # doctest: +SKIP\n&gt;&gt;&gt; plt.imshow([data], cmap='coolwarm', norm=norm, aspect='auto')  # doctest: +SKIP\n&gt;&gt;&gt; plt.colorbar()  # doctest: +SKIP\n&gt;&gt;&gt; plt.title('Midpoint Normalization with midpoint=0')  # doctest: +SKIP\n&gt;&gt;&gt; plt.tight_layout()  # doctest: +SKIP\n</code></pre> Create a normalization with a non-zero midpoint: <pre><code>&gt;&gt;&gt; # Create a normalization with midpoint at 5\n&gt;&gt;&gt; norm = MidpointNormalize(vmin=0, vmax=10, midpoint=5)\n&gt;&gt;&gt; # Values below midpoint are mapped to [0, 0.5]\n&gt;&gt;&gt; norm(0)\nmasked_array(data=0.,\n             mask=False,\n       fill_value=1e+20)\n&gt;&gt;&gt; norm(2.5)\nmasked_array(data=0.25,\n             mask=False,\n       fill_value=1e+20)\n&gt;&gt;&gt; # Midpoint is mapped to 0.5\n&gt;&gt;&gt; norm(5)\nmasked_array(data=0.5,\n             mask=False,\n       fill_value=1e+20)\n&gt;&gt;&gt; # Values above midpoint are mapped to [0.5, 1]\n&gt;&gt;&gt; norm(7.5)\nmasked_array(data=0.75,\n             mask=False,\n       fill_value=1e+20)\n&gt;&gt;&gt; norm(10)\nmasked_array(data=1.,\n             mask=False,\n       fill_value=1e+20)\n</code></pre></p> Source code in <code>cleopatra/styles.py</code> <pre><code>class MidpointNormalize(colors.Normalize):\n    \"\"\"A normalization class that scales data with a midpoint.\n\n    This class extends matplotlib's Normalize class to create a colormap\n    normalization that has a fixed midpoint. This is useful for data that\n    has a natural midpoint (like zero) where the colormap should be centered,\n    regardless of the actual data range.\n\n    The normalization maps values to the range [0, 1] with the midpoint\n    mapped to 0.5, which allows for symmetric colormaps to be properly centered.\n\n    Parameters\n    ----------\n    vmin : float, optional\n        The minimum data value that corresponds to 0 in the normalized data.\n        If None, it is automatically calculated from the data.\n    vmax : float, optional\n        The maximum data value that corresponds to 1 in the normalized data.\n        If None, it is automatically calculated from the data.\n    midpoint : float, optional\n        The data value that corresponds to 0.5 in the normalized data.\n        If None, it defaults to the midpoint between vmin and vmax.\n    clip : bool, optional\n        If True, values outside the [vmin, vmax] range are clipped to be\n        within that range, by default False.\n\n    Attributes\n    ----------\n    midpoint : float\n        The data value that will be mapped to 0.5 in the normalized data.\n\n    Notes\n    -----\n    This normalization is particularly useful for:\n    - Diverging colormaps where a specific value should be at the center\n    - Data with positive and negative values where zero should be the midpoint\n    - Highlighting deviations from a reference value\n\n    Examples\n    --------\n    Create a plot with a midpoint normalization:\n    ```python\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; import matplotlib.pyplot as plt\n    &gt;&gt;&gt; from cleopatra.styles import MidpointNormalize\n    &gt;&gt;&gt; # Create some data with positive and negative values\n    &gt;&gt;&gt; data = np.linspace(-10, 10, 100)\n    &gt;&gt;&gt; # Create a normalization with midpoint at 0\n    &gt;&gt;&gt; norm = MidpointNormalize(vmin=-10, vmax=10, midpoint=0)\n    &gt;&gt;&gt; # Use in a plot\n    &gt;&gt;&gt; plt.figure(figsize=(8, 1)) # doctest: +SKIP\n    &gt;&gt;&gt; plt.imshow([data], cmap='coolwarm', norm=norm, aspect='auto')  # doctest: +SKIP\n    &gt;&gt;&gt; plt.colorbar()  # doctest: +SKIP\n    &gt;&gt;&gt; plt.title('Midpoint Normalization with midpoint=0')  # doctest: +SKIP\n    &gt;&gt;&gt; plt.tight_layout()  # doctest: +SKIP\n\n    ```\n    Create a normalization with a non-zero midpoint:\n    ```python\n    &gt;&gt;&gt; # Create a normalization with midpoint at 5\n    &gt;&gt;&gt; norm = MidpointNormalize(vmin=0, vmax=10, midpoint=5)\n    &gt;&gt;&gt; # Values below midpoint are mapped to [0, 0.5]\n    &gt;&gt;&gt; norm(0)\n    masked_array(data=0.,\n                 mask=False,\n           fill_value=1e+20)\n    &gt;&gt;&gt; norm(2.5)\n    masked_array(data=0.25,\n                 mask=False,\n           fill_value=1e+20)\n    &gt;&gt;&gt; # Midpoint is mapped to 0.5\n    &gt;&gt;&gt; norm(5)\n    masked_array(data=0.5,\n                 mask=False,\n           fill_value=1e+20)\n    &gt;&gt;&gt; # Values above midpoint are mapped to [0.5, 1]\n    &gt;&gt;&gt; norm(7.5)\n    masked_array(data=0.75,\n                 mask=False,\n           fill_value=1e+20)\n    &gt;&gt;&gt; norm(10)\n    masked_array(data=1.,\n                 mask=False,\n           fill_value=1e+20)\n\n    ```\n    \"\"\"\n\n    def __init__(self, vmin=None, vmax=None, midpoint=None, clip=False):\n        \"\"\"Initialize a MidpointNormalize instance.\n\n        Parameters\n        ----------\n        vmin : float, optional\n            The minimum data value that corresponds to 0 in the normalized data.\n            If None, it is automatically calculated from the data when the\n            normalization is applied.\n        vmax : float, optional\n            The maximum data value that corresponds to 1 in the normalized data.\n            If None, it is automatically calculated from the data when the\n            normalization is applied.\n        midpoint : float, optional\n            The data value that corresponds to 0.5 in the normalized data.\n            If None, it defaults to the midpoint between vmin and vmax.\n        clip : bool, optional\n            If True, values outside the [vmin, vmax] range are clipped to be\n            within that range, by default False.\n\n        Notes\n        -----\n        This initialization sets up the midpoint attribute and calls the parent\n        class (matplotlib.colors.Normalize) constructor with the vmin, vmax, and\n        clip parameters.\n\n        Examples\n        --------\n        Create a normalization with default parameters:\n        ```python\n        &gt;&gt;&gt; from cleopatra.styles import MidpointNormalize\n        &gt;&gt;&gt; norm = MidpointNormalize()  # vmin, vmax, midpoint will be determined from data\n\n        Create a normalization with specific range and midpoint:\n        ```python\n        &gt;&gt;&gt; norm = MidpointNormalize(vmin=-10, vmax=10, midpoint=0)\n        &gt;&gt;&gt; norm.midpoint\n        0\n\n        ```\n        \"\"\"\n        self.midpoint = midpoint\n        colors.Normalize.__init__(self, vmin, vmax, clip)\n\n    def __call__(self, value, clip=None):\n        \"\"\"Normalize data values to the [0, 1] range with a fixed midpoint.\n\n        This method implements the normalization logic, mapping input values to\n        the range [0, 1] with the midpoint mapped to 0.5. It uses linear interpolation\n        to create two separate linear mappings: one for values below the midpoint\n        and another for values above the midpoint.\n\n        Parameters\n        ----------\n        value : float or numpy.ndarray\n            The data value(s) to normalize. Can be a single value or an array.\n        clip : bool, optional\n            Whether to clip the input values to the [vmin, vmax] range.\n            If None, the clip attribute of the instance is used.\n\n        Returns\n        -------\n        numpy.ma.masked_array\n            The normalized value(s) in the range [0, 1], with the midpoint mapped to 0.5.\n            If the input is an array, the output will be an array of the same shape.\n            Masked values in the input remain masked in the output.\n\n        Notes\n        -----\n        The normalization is performed using numpy's interp function, which does\n        linear interpolation between the points:\n        - (vmin, 0): minimum value maps to 0\n        - (midpoint, 0.5): midpoint value maps to 0.5\n        - (vmax, 1): maximum value maps to 1\n\n        This creates a piecewise linear mapping that ensures the midpoint is\n        always at 0.5 in the normalized range.\n\n        Examples\n        --------\n        Normalize values with a zero midpoint:\n        ```python\n        &gt;&gt;&gt; from cleopatra.styles import MidpointNormalize\n        &gt;&gt;&gt; norm = MidpointNormalize(vmin=-10, vmax=10, midpoint=0)\n        &gt;&gt;&gt; # Values below midpoint are mapped to [0, 0.5]\n        &gt;&gt;&gt; norm(-10)  # vmin maps to 0\n        masked_array(data=0.,\n                     mask=False,\n               fill_value=1e+20)\n        &gt;&gt;&gt; norm(-5)   # halfway between vmin and midpoint maps to 0.25\n        masked_array(data=0.25,\n                     mask=False,\n               fill_value=1e+20)\n        &gt;&gt;&gt; # Midpoint maps to 0.5\n        &gt;&gt;&gt; norm(0)\n        masked_array(data=0.5,\n                     mask=False,\n               fill_value=1e+20)\n        &gt;&gt;&gt; # Values above midpoint are mapped to [0.5, 1]\n        &gt;&gt;&gt; norm(5)    # halfway between midpoint and vmax maps to 0.75\n        masked_array(data=0.75,\n                     mask=False,\n               fill_value=1e+20)\n        &gt;&gt;&gt; norm(10)   # vmax maps to 1\n        masked_array(data=1.,\n                     mask=False,\n               fill_value=1e+20)\n\n        ```\n        Normalize an array of values:\n        ```python\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; values = np.array([-10, -5, 0, 5, 10])\n        &gt;&gt;&gt; norm(values)\n        masked_array(data=[0.  , 0.25, 0.5 , 0.75, 1.  ],\n                     mask=False,\n               fill_value=1e+20)\n\n        ```\n        \"\"\"\n        # I'm ignoring masked values and all kinds of edge cases to make a\n        # simple example...\n        x, y = [self.vmin, self.midpoint, self.vmax], [0, 0.5, 1]\n\n        return np.ma.masked_array(np.interp(value, x, y))\n</code></pre>"},{"location":"api/styles-class/#cleopatra.styles.MidpointNormalize.__call__","title":"<code>__call__(value, clip=None)</code>","text":"<p>Normalize data values to the [0, 1] range with a fixed midpoint.</p> <p>This method implements the normalization logic, mapping input values to the range [0, 1] with the midpoint mapped to 0.5. It uses linear interpolation to create two separate linear mappings: one for values below the midpoint and another for values above the midpoint.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float or ndarray</code> <p>The data value(s) to normalize. Can be a single value or an array.</p> required <code>clip</code> <code>bool</code> <p>Whether to clip the input values to the [vmin, vmax] range. If None, the clip attribute of the instance is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>masked_array</code> <p>The normalized value(s) in the range [0, 1], with the midpoint mapped to 0.5. If the input is an array, the output will be an array of the same shape. Masked values in the input remain masked in the output.</p> Notes <p>The normalization is performed using numpy's interp function, which does linear interpolation between the points: - (vmin, 0): minimum value maps to 0 - (midpoint, 0.5): midpoint value maps to 0.5 - (vmax, 1): maximum value maps to 1</p> <p>This creates a piecewise linear mapping that ensures the midpoint is always at 0.5 in the normalized range.</p> <p>Examples:</p> <p>Normalize values with a zero midpoint: <pre><code>&gt;&gt;&gt; from cleopatra.styles import MidpointNormalize\n&gt;&gt;&gt; norm = MidpointNormalize(vmin=-10, vmax=10, midpoint=0)\n&gt;&gt;&gt; # Values below midpoint are mapped to [0, 0.5]\n&gt;&gt;&gt; norm(-10)  # vmin maps to 0\nmasked_array(data=0.,\n             mask=False,\n       fill_value=1e+20)\n&gt;&gt;&gt; norm(-5)   # halfway between vmin and midpoint maps to 0.25\nmasked_array(data=0.25,\n             mask=False,\n       fill_value=1e+20)\n&gt;&gt;&gt; # Midpoint maps to 0.5\n&gt;&gt;&gt; norm(0)\nmasked_array(data=0.5,\n             mask=False,\n       fill_value=1e+20)\n&gt;&gt;&gt; # Values above midpoint are mapped to [0.5, 1]\n&gt;&gt;&gt; norm(5)    # halfway between midpoint and vmax maps to 0.75\nmasked_array(data=0.75,\n             mask=False,\n       fill_value=1e+20)\n&gt;&gt;&gt; norm(10)   # vmax maps to 1\nmasked_array(data=1.,\n             mask=False,\n       fill_value=1e+20)\n</code></pre> Normalize an array of values: <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; values = np.array([-10, -5, 0, 5, 10])\n&gt;&gt;&gt; norm(values)\nmasked_array(data=[0.  , 0.25, 0.5 , 0.75, 1.  ],\n             mask=False,\n       fill_value=1e+20)\n</code></pre></p> Source code in <code>cleopatra/styles.py</code> <pre><code>def __call__(self, value, clip=None):\n    \"\"\"Normalize data values to the [0, 1] range with a fixed midpoint.\n\n    This method implements the normalization logic, mapping input values to\n    the range [0, 1] with the midpoint mapped to 0.5. It uses linear interpolation\n    to create two separate linear mappings: one for values below the midpoint\n    and another for values above the midpoint.\n\n    Parameters\n    ----------\n    value : float or numpy.ndarray\n        The data value(s) to normalize. Can be a single value or an array.\n    clip : bool, optional\n        Whether to clip the input values to the [vmin, vmax] range.\n        If None, the clip attribute of the instance is used.\n\n    Returns\n    -------\n    numpy.ma.masked_array\n        The normalized value(s) in the range [0, 1], with the midpoint mapped to 0.5.\n        If the input is an array, the output will be an array of the same shape.\n        Masked values in the input remain masked in the output.\n\n    Notes\n    -----\n    The normalization is performed using numpy's interp function, which does\n    linear interpolation between the points:\n    - (vmin, 0): minimum value maps to 0\n    - (midpoint, 0.5): midpoint value maps to 0.5\n    - (vmax, 1): maximum value maps to 1\n\n    This creates a piecewise linear mapping that ensures the midpoint is\n    always at 0.5 in the normalized range.\n\n    Examples\n    --------\n    Normalize values with a zero midpoint:\n    ```python\n    &gt;&gt;&gt; from cleopatra.styles import MidpointNormalize\n    &gt;&gt;&gt; norm = MidpointNormalize(vmin=-10, vmax=10, midpoint=0)\n    &gt;&gt;&gt; # Values below midpoint are mapped to [0, 0.5]\n    &gt;&gt;&gt; norm(-10)  # vmin maps to 0\n    masked_array(data=0.,\n                 mask=False,\n           fill_value=1e+20)\n    &gt;&gt;&gt; norm(-5)   # halfway between vmin and midpoint maps to 0.25\n    masked_array(data=0.25,\n                 mask=False,\n           fill_value=1e+20)\n    &gt;&gt;&gt; # Midpoint maps to 0.5\n    &gt;&gt;&gt; norm(0)\n    masked_array(data=0.5,\n                 mask=False,\n           fill_value=1e+20)\n    &gt;&gt;&gt; # Values above midpoint are mapped to [0.5, 1]\n    &gt;&gt;&gt; norm(5)    # halfway between midpoint and vmax maps to 0.75\n    masked_array(data=0.75,\n                 mask=False,\n           fill_value=1e+20)\n    &gt;&gt;&gt; norm(10)   # vmax maps to 1\n    masked_array(data=1.,\n                 mask=False,\n           fill_value=1e+20)\n\n    ```\n    Normalize an array of values:\n    ```python\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; values = np.array([-10, -5, 0, 5, 10])\n    &gt;&gt;&gt; norm(values)\n    masked_array(data=[0.  , 0.25, 0.5 , 0.75, 1.  ],\n                 mask=False,\n           fill_value=1e+20)\n\n    ```\n    \"\"\"\n    # I'm ignoring masked values and all kinds of edge cases to make a\n    # simple example...\n    x, y = [self.vmin, self.midpoint, self.vmax], [0, 0.5, 1]\n\n    return np.ma.masked_array(np.interp(value, x, y))\n</code></pre>"},{"location":"api/styles-class/#cleopatra.styles.MidpointNormalize.__init__","title":"<code>__init__(vmin=None, vmax=None, midpoint=None, clip=False)</code>","text":"<p>Initialize a MidpointNormalize instance.</p> <p>Parameters:</p> Name Type Description Default <code>vmin</code> <code>float</code> <p>The minimum data value that corresponds to 0 in the normalized data. If None, it is automatically calculated from the data when the normalization is applied.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum data value that corresponds to 1 in the normalized data. If None, it is automatically calculated from the data when the normalization is applied.</p> <code>None</code> <code>midpoint</code> <code>float</code> <p>The data value that corresponds to 0.5 in the normalized data. If None, it defaults to the midpoint between vmin and vmax.</p> <code>None</code> <code>clip</code> <code>bool</code> <p>If True, values outside the [vmin, vmax] range are clipped to be within that range, by default False.</p> <code>False</code> Notes <p>This initialization sets up the midpoint attribute and calls the parent class (matplotlib.colors.Normalize) constructor with the vmin, vmax, and clip parameters.</p> <p>Examples:</p> <p>Create a normalization with default parameters: ```python</p> <p>from cleopatra.styles import MidpointNormalize norm = MidpointNormalize()  # vmin, vmax, midpoint will be determined from data</p> <p>Create a normalization with specific range and midpoint: ```python</p> <pre><code>&gt;&gt;&gt; norm = MidpointNormalize(vmin=-10, vmax=10, midpoint=0)\n&gt;&gt;&gt; norm.midpoint\n0\n</code></pre> <p>```</p> Source code in <code>cleopatra/styles.py</code> <pre><code>def __init__(self, vmin=None, vmax=None, midpoint=None, clip=False):\n    \"\"\"Initialize a MidpointNormalize instance.\n\n    Parameters\n    ----------\n    vmin : float, optional\n        The minimum data value that corresponds to 0 in the normalized data.\n        If None, it is automatically calculated from the data when the\n        normalization is applied.\n    vmax : float, optional\n        The maximum data value that corresponds to 1 in the normalized data.\n        If None, it is automatically calculated from the data when the\n        normalization is applied.\n    midpoint : float, optional\n        The data value that corresponds to 0.5 in the normalized data.\n        If None, it defaults to the midpoint between vmin and vmax.\n    clip : bool, optional\n        If True, values outside the [vmin, vmax] range are clipped to be\n        within that range, by default False.\n\n    Notes\n    -----\n    This initialization sets up the midpoint attribute and calls the parent\n    class (matplotlib.colors.Normalize) constructor with the vmin, vmax, and\n    clip parameters.\n\n    Examples\n    --------\n    Create a normalization with default parameters:\n    ```python\n    &gt;&gt;&gt; from cleopatra.styles import MidpointNormalize\n    &gt;&gt;&gt; norm = MidpointNormalize()  # vmin, vmax, midpoint will be determined from data\n\n    Create a normalization with specific range and midpoint:\n    ```python\n    &gt;&gt;&gt; norm = MidpointNormalize(vmin=-10, vmax=10, midpoint=0)\n    &gt;&gt;&gt; norm.midpoint\n    0\n\n    ```\n    \"\"\"\n    self.midpoint = midpoint\n    colors.Normalize.__init__(self, vmin, vmax, clip)\n</code></pre>"},{"location":"api/styles-class/#examples","title":"Examples","text":""},{"location":"api/styles-class/#log-scale","title":"Log Scale","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom cleopatra.styles import Scale\n\n# Create some data with a wide range of values\ndata = np.array([0.1, 1, 10, 100, 1000])\n\n# Apply log scale\nscale = Scale()\nlog_data = scale.log_scale(data)\n\n# Plot the original and log-scaled data\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 4))\nax1.plot(data)\nax1.set_title('Original Data')\nax2.plot(log_data)\nax2.set_title('Log-Scaled Data')\nplt.tight_layout()\n</code></pre>"},{"location":"api/styles-class/#power-scale","title":"Power Scale","text":"<pre><code># Apply power scale with gamma=0.5 (square root)\npower_data = scale.power_scale(data)(0.5)\n\n# Plot the original and power-scaled data\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 4))\nax1.plot(data)\nax1.set_title('Original Data')\nax2.plot(power_data)\nax2.set_title('Power-Scaled Data (gamma=0.5)')\nplt.tight_layout()\n</code></pre>"},{"location":"api/styles-class/#midpoint-normalize","title":"Midpoint Normalize","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom cleopatra.styles import MidpointNormalize\nimport matplotlib.colors as colors\n\n# Create some data with positive and negative values\ndata = np.random.uniform(-10, 10, (10, 10))\n\n# Create a figure with two subplots\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 4))\n\n# Plot with standard normalization\nim1 = ax1.imshow(data, cmap='RdBu_r', norm=colors.Normalize(vmin=-10, vmax=10))\nax1.set_title('Standard Normalization')\nplt.colorbar(im1, ax=ax1)\n\n# Plot with midpoint normalization (midpoint at 0)\nim2 = ax2.imshow(data, cmap='RdBu_r', norm=MidpointNormalize(vmin=-10, vmax=10, midpoint=0))\nax2.set_title('Midpoint Normalization')\nplt.colorbar(im2, ax=ax2)\n\nplt.tight_layout()\n</code></pre>"},{"location":"notebooks/array_glyph/array_glyph_examples/","title":"ArrayGlyph","text":"In\u00a0[1]: Copied! <pre>import os\nimport numpy as np\n\nfrom cleopatra.array_glyph import ArrayGlyph\nget_ipython().run_line_magic(\"matplotlib\", \"notebook\")  # noqa: F821\n# Set the random seed for reproducibility\nnp.random.seed(42)\n</pre> import os import numpy as np  from cleopatra.array_glyph import ArrayGlyph get_ipython().run_line_magic(\"matplotlib\", \"notebook\")  # noqa: F821 # Set the random seed for reproducibility np.random.seed(42) In\u00a0[2]: Copied! <pre># Create a simple 2D array\nsimple_array = np.zeros((10, 10))\nfor i in range(10):\n    for j in range(10):\n        simple_array[i, j] = i * j  # Create a multiplication table pattern\n</pre> # Create a simple 2D array simple_array = np.zeros((10, 10)) for i in range(10):     for j in range(10):         simple_array[i, j] = i * j  # Create a multiplication table pattern In\u00a0[3]: Copied! <pre># Initialize the ArrayGlyph with the array\narray_glyph = ArrayGlyph(simple_array)\n</pre> # Initialize the ArrayGlyph with the array array_glyph = ArrayGlyph(simple_array) In\u00a0[4]: Copied! <pre># Plot the array with default settings\nfig, ax = array_glyph.plot()\n\n# Display information about the array\nprint(f\"Array shape: {simple_array.shape}\")\nprint(f\"Min value: {simple_array.min()}\")\nprint(f\"Max value: {simple_array.max()}\")\n</pre> # Plot the array with default settings fig, ax = array_glyph.plot()  # Display information about the array print(f\"Array shape: {simple_array.shape}\") print(f\"Min value: {simple_array.min()}\") print(f\"Max value: {simple_array.max()}\") <pre>Array shape: (10, 10)\nMin value: 0.0\nMax value: 81.0\n</pre> <p>Create a more complex array</p> In\u00a0[5]: Copied! <pre>complex_array = np.random.rand(20, 20)  # Random values between 0 and 1\ncomplex_array[5:15, 5:15] = complex_array[5:15, 5:15] * 2  # Increase values in the center\n</pre> complex_array = np.random.rand(20, 20)  # Random values between 0 and 1 complex_array[5:15, 5:15] = complex_array[5:15, 5:15] * 2  # Increase values in the center <ul> <li>Initialize the ArrayGlyph with the array</li> </ul> In\u00a0[6]: Copied! <pre>array_glyph_custom = ArrayGlyph(complex_array)\n\n# Plot with custom settings\nfig, ax = array_glyph_custom.plot(\n    cmap=\"viridis\",           # Use the viridis colormap\n    title=\"Custom Array Plot\", # Add a title\n    ticks_spacing=0.5,          # Set tick spacing\n    figsize=(10, 8)           # Set figure size\n)\n</pre> array_glyph_custom = ArrayGlyph(complex_array)  # Plot with custom settings fig, ax = array_glyph_custom.plot(     cmap=\"viridis\",           # Use the viridis colormap     title=\"Custom Array Plot\", # Add a title     ticks_spacing=0.5,          # Set tick spacing     figsize=(10, 8)           # Set figure size ) <ul> <li>Create an array with positive and negative values</li> </ul> In\u00a0[7]: Copied! <pre>mixed_array = np.random.randn(15, 15)  # Random values from a normal distribution\n</pre> mixed_array = np.random.randn(15, 15)  # Random values from a normal distribution <ul> <li>Initialize the ArrayGlyph with the array</li> </ul> In\u00a0[8]: Copied! <pre>array_glyph_scales = ArrayGlyph(mixed_array)\n</pre> array_glyph_scales = ArrayGlyph(mixed_array) In\u00a0[9]: Copied! <pre>fig1, ax1 = array_glyph_scales.plot(\n    color_scale=\"linear\",\n    cmap=\"RdBu_r\",\n    title=\"Linear Scale\"\n)\n</pre> fig1, ax1 = array_glyph_scales.plot(     color_scale=\"linear\",     cmap=\"RdBu_r\",     title=\"Linear Scale\" ) In\u00a0[10]: Copied! <pre>array_glyph_scales = ArrayGlyph(mixed_array)\nfig2, ax2 = array_glyph_scales.plot(\n    color_scale=\"power\",\n    cmap=\"RdBu_r\",\n    title=\"Power Scale\"\n)\n</pre> array_glyph_scales = ArrayGlyph(mixed_array) fig2, ax2 = array_glyph_scales.plot(     color_scale=\"power\",     cmap=\"RdBu_r\",     title=\"Power Scale\" ) In\u00a0[11]: Copied! <pre># For log scale, we need positive values\npositive_array = np.abs(mixed_array) + 0.1  # Make all values positive and non-zero\narray_glyph_positive = ArrayGlyph(positive_array)\n\nfig3, ax3 = array_glyph_positive.plot(\n    color_scale=\"sym-lognorm\",\n    cmap=\"viridis\",\n    title=\"Log Scale\"\n)\n</pre> # For log scale, we need positive values positive_array = np.abs(mixed_array) + 0.1  # Make all values positive and non-zero array_glyph_positive = ArrayGlyph(positive_array)  fig3, ax3 = array_glyph_positive.plot(     color_scale=\"sym-lognorm\",     cmap=\"viridis\",     title=\"Log Scale\" ) In\u00a0[12]: Copied! <pre>array_glyph_scales = ArrayGlyph(mixed_array)\nfig4, ax4 = array_glyph_scales.plot(\n    color_scale=\"midpoint\",\n    midpoint=0,  # Set the midpoint at 0\n    cmap=\"RdBu_r\",\n    title=\"Midpoint Scale\"\n)\n</pre> array_glyph_scales = ArrayGlyph(mixed_array) fig4, ax4 = array_glyph_scales.plot(     color_scale=\"midpoint\",     midpoint=0,  # Set the midpoint at 0     cmap=\"RdBu_r\",     title=\"Midpoint Scale\" ) <ul> <li>Create a small array for better visibility of cell values</li> </ul> In\u00a0[13]: Copied! <pre># Create a small array for better visibility of cell values\nsmall_array = np.random.randint(0, 100, (5, 5))\n</pre> # Create a small array for better visibility of cell values small_array = np.random.randint(0, 100, (5, 5)) In\u00a0[14]: Copied! <pre># Initialize the ArrayGlyph with the array\narray_glyph_values = ArrayGlyph(small_array)\n\n# Plot with cell values displayed\nfig, ax = array_glyph_values.plot(\n    display_cell_value=True,   # Display cell values\n    num_size=12,               # Set text font size\n    cmap=\"viridis\",            # Use the viridis colormap\n    title=\"Array with Cell Values\",\n    figsize=(8, 6)\n)\n</pre> # Initialize the ArrayGlyph with the array array_glyph_values = ArrayGlyph(small_array)  # Plot with cell values displayed fig, ax = array_glyph_values.plot(     display_cell_value=True,   # Display cell values     num_size=12,               # Set text font size     cmap=\"viridis\",            # Use the viridis colormap     title=\"Array with Cell Values\",     figsize=(8, 6) ) In\u00a0[15]: Copied! <pre># Create an array\npoint_array = np.random.rand(15, 15)\n\n# Create some points to display on the array\n# Points are specified as [value, row, column] coordinates\npoints = np.array([\n    [1, 3, 3],    # Top-left region\n    [2, 3, 11],   # Top-right region\n    [3, 11, 3],   # Bottom-left region\n    [4, 11, 11]   # Bottom-right region\n])\n\n# Initialize the ArrayGlyph with the array\narray_glyph_points = ArrayGlyph(point_array)\n\n# Plot with points\nfig, ax = array_glyph_points.plot(\n    points=points,            # Points to display\n    point_color=\"red\",        # Set point color\n    point_size=100,           # Set point size\n    pid_color=\"blue\",         # Set point ID color\n    pid_size=16,              # Set point ID size\n    cmap=\"viridis\",           # Use the viridis colormap\n    title=\"Array with Points\",\n    figsize=(10, 8)\n)\n</pre> # Create an array point_array = np.random.rand(15, 15)  # Create some points to display on the array # Points are specified as [value, row, column] coordinates points = np.array([     [1, 3, 3],    # Top-left region     [2, 3, 11],   # Top-right region     [3, 11, 3],   # Bottom-left region     [4, 11, 11]   # Bottom-right region ])  # Initialize the ArrayGlyph with the array array_glyph_points = ArrayGlyph(point_array)  # Plot with points fig, ax = array_glyph_points.plot(     points=points,            # Points to display     point_color=\"red\",        # Set point color     point_size=100,           # Set point size     pid_color=\"blue\",         # Set point ID color     pid_size=16,              # Set point ID size     cmap=\"viridis\",           # Use the viridis colormap     title=\"Array with Points\",     figsize=(10, 8) ) In\u00a0[16]: Copied! <pre># Create a 3D array for the animation\nn_frames = 10\nx = np.linspace(0, 10, 20)\ny = np.linspace(0, 10, 20)\nX, Y = np.meshgrid(x, y)\n\n# Create a 3D array with shape (n_frames, 20, 20)\nanimation_array = np.zeros((n_frames, 20, 20))\nfor i in range(n_frames):\n    # Create a wave pattern that changes with time\n    animation_array[i] = np.sin(X + i * 0.5) * np.cos(Y + i * 0.5)\n\n# Initialize the ArrayGlyph with the 3D array\narray_glyph_animation = ArrayGlyph(animation_array)\n\n# Create the animation\nanim = array_glyph_animation.animate(\n    time=list(range(n_frames)),  # Time points\n    points=None,                 # No points to display\n    interval=200,                # Interval between frames (ms)\n    cmap=\"viridis\",              # Use the viridis colormap\n    title=\"Array Animation\",\n    figsize=(10, 8)\n)\n</pre> # Create a 3D array for the animation n_frames = 10 x = np.linspace(0, 10, 20) y = np.linspace(0, 10, 20) X, Y = np.meshgrid(x, y)  # Create a 3D array with shape (n_frames, 20, 20) animation_array = np.zeros((n_frames, 20, 20)) for i in range(n_frames):     # Create a wave pattern that changes with time     animation_array[i] = np.sin(X + i * 0.5) * np.cos(Y + i * 0.5)  # Initialize the ArrayGlyph with the 3D array array_glyph_animation = ArrayGlyph(animation_array)  # Create the animation anim = array_glyph_animation.animate(     time=list(range(n_frames)),  # Time points     points=None,                 # No points to display     interval=200,                # Interval between frames (ms)     cmap=\"viridis\",              # Use the viridis colormap     title=\"Array Animation\",     figsize=(10, 8) ) <ul> <li>Note: To save the animation, you would use:</li> </ul> In\u00a0[17]: Copied! <pre>array_glyph_animation.save_animation(\"animation.gif\", fps=5)\n</pre> array_glyph_animation.save_animation(\"animation.gif\", fps=5) In\u00a0[18]: Copied! <pre>os.listdir(\".\")\n</pre> os.listdir(\".\") Out[18]: <pre>['.ipynb_checkpoints', 'animation.gif', 'array_glyph_examples.ipynb']</pre> In\u00a0[19]: Copied! <pre># Create an array with a wide range of values\nwide_range_array = np.random.exponential(scale=2.0, size=(15, 15))\n\n# Initialize the ArrayGlyph with cutoff values\narray_glyph_cutoff = ArrayGlyph(\n    wide_range_array,\n    cutoff=[1.0, 5.0]  # Set minimum and maximum values\n)\n\n# Plot the array\nfig, ax = array_glyph_cutoff.plot(\n    title=\"Array with Cutoff Values\",\n    figsize=(8, 6)\n)\n</pre> # Create an array with a wide range of values wide_range_array = np.random.exponential(scale=2.0, size=(15, 15))  # Initialize the ArrayGlyph with cutoff values array_glyph_cutoff = ArrayGlyph(     wide_range_array,     cutoff=[1.0, 5.0]  # Set minimum and maximum values )  # Plot the array fig, ax = array_glyph_cutoff.plot(     title=\"Array with Cutoff Values\",     figsize=(8, 6) ) In\u00a0[20]: Copied! <pre># Initialize the ArrayGlyph with percentile cutoff\narray_glyph_percentile = ArrayGlyph(\n    wide_range_array,\n    percentile=2  # Exclude values below 2nd percentile and above 98th percentile\n)\n\n# Plot the array\nfig, ax = array_glyph_percentile.plot(\n    title=\"Array with Percentile Cutoff\",\n    figsize=(8, 6)\n)\n</pre> # Initialize the ArrayGlyph with percentile cutoff array_glyph_percentile = ArrayGlyph(     wide_range_array,     percentile=2  # Exclude values below 2nd percentile and above 98th percentile )  # Plot the array fig, ax = array_glyph_percentile.plot(     title=\"Array with Percentile Cutoff\",     figsize=(8, 6) ) In\u00a0[21]: Copied! <pre># Create an array with some specific values to exclude\nexclude_array = np.random.rand(15, 15)\nexclude_array[5:10, 5:10] = -9999  # Set some values to -9999 (to be excluded)\n\n# Initialize the ArrayGlyph with excluded values\narray_glyph_exclude = ArrayGlyph(\n    exclude_array,\n    exclude_value=[-9999]  # Exclude values equal to -9999\n)\n\n# Plot the array\nfig, ax = array_glyph_exclude.plot(\n    title=\"Array with Excluded Values\",\n    figsize=(8, 6)\n)\n</pre> # Create an array with some specific values to exclude exclude_array = np.random.rand(15, 15) exclude_array[5:10, 5:10] = -9999  # Set some values to -9999 (to be excluded)  # Initialize the ArrayGlyph with excluded values array_glyph_exclude = ArrayGlyph(     exclude_array,     exclude_value=[-9999]  # Exclude values equal to -9999 )  # Plot the array fig, ax = array_glyph_exclude.plot(     title=\"Array with Excluded Values\",     figsize=(8, 6) ) In\u00a0[22]: Copied! <pre># Create an array\ncolorbar_array = np.random.rand(15, 15)\n\n# Initialize the ArrayGlyph with the array\narray_glyph_colorbar = ArrayGlyph(colorbar_array)\n\n# Plot with a custom colorbar\nfig, ax = array_glyph_colorbar.plot(\n    cbar_label=\"Values\",              # Set colorbar label\n    cbar_orientation=\"horizontal\",    # Set colorbar orientation\n    cbar_length=0.8,                  # Shrink the colorbar\n    cmap=\"plasma\",                    # Use the plasma colormap\n    title=\"Array with Custom Colorbar\",\n    figsize=(10, 8)\n)\n</pre> # Create an array colorbar_array = np.random.rand(15, 15)  # Initialize the ArrayGlyph with the array array_glyph_colorbar = ArrayGlyph(colorbar_array)  # Plot with a custom colorbar fig, ax = array_glyph_colorbar.plot(     cbar_label=\"Values\",              # Set colorbar label     cbar_orientation=\"horizontal\",    # Set colorbar orientation     cbar_length=0.8,                  # Shrink the colorbar     cmap=\"plasma\",                    # Use the plasma colormap     title=\"Array with Custom Colorbar\",     figsize=(10, 8) )"},{"location":"notebooks/array_glyph/array_glyph_examples/#arrayglyph","title":"ArrayGlyph\u00b6","text":"<ul> <li>This script demonstrates the usage of the ArrayGlyph class from the Cleopatra package. The ArrayGlyph class provides functionality for visualizing arrays and creating animations.</li> </ul>"},{"location":"notebooks/array_glyph/array_glyph_examples/#1-creating-and-visualizing-a-simple-array","title":"1. Creating and Visualizing a Simple Array\u00b6","text":"<p>Let's start by creating a simple 2D array and visualizing it with ArrayGlyph.</p>"},{"location":"notebooks/array_glyph/array_glyph_examples/#2-customizing-the-array-visualization","title":"2. Customizing the Array Visualization\u00b6","text":"<p>The ArrayGlyph class provides many options for customizing the visualization.</p>"},{"location":"notebooks/array_glyph/array_glyph_examples/#3-using-different-color-scales","title":"3. Using Different Color Scales\u00b6","text":"<ul> <li>The ArrayGlyph class supports different color scales for visualizing arrays.</li> </ul>"},{"location":"notebooks/array_glyph/array_glyph_examples/#31-linear-scale-default","title":"3.1 Linear Scale (default)\u00b6","text":""},{"location":"notebooks/array_glyph/array_glyph_examples/#32-power-scale","title":"3.2 Power Scale\u00b6","text":""},{"location":"notebooks/array_glyph/array_glyph_examples/#33-log-scale","title":"3.3 Log Scale\u00b6","text":""},{"location":"notebooks/array_glyph/array_glyph_examples/#34-midpoint-scale","title":"3.4 Midpoint Scale\u00b6","text":""},{"location":"notebooks/array_glyph/array_glyph_examples/#4-displaying-cell-values","title":"4. Displaying Cell Values\u00b6","text":"<ul> <li>The ArrayGlyph class can display the values of each cell in the array.</li> </ul>"},{"location":"notebooks/array_glyph/array_glyph_examples/#5-displaying-points-on-the-array","title":"5. Displaying Points on the Array\u00b6","text":"<ul> <li>The ArrayGlyph class can display points on top of the array.</li> </ul>"},{"location":"notebooks/array_glyph/array_glyph_examples/#6-creating-an-animation","title":"6. Creating an Animation\u00b6","text":"<ul> <li>The ArrayGlyph class can create animations of arrays changing over time.</li> </ul>"},{"location":"notebooks/array_glyph/array_glyph_examples/#7-preparing-arrays-with-different-methods","title":"7. Preparing Arrays with Different Methods\u00b6","text":"<ul> <li>The ArrayGlyph class provides methods for preparing arrays for visualization.</li> </ul>"},{"location":"notebooks/array_glyph/array_glyph_examples/#71-preparing-an-array-with-cutoff-values","title":"7.1 Preparing an Array with Cutoff Values\u00b6","text":""},{"location":"notebooks/array_glyph/array_glyph_examples/#72-preparing-an-array-with-percentile-cutoff","title":"7.2 Preparing an Array with Percentile Cutoff\u00b6","text":""},{"location":"notebooks/array_glyph/array_glyph_examples/#73-preparing-an-array-with-excluded-values","title":"7.3 Preparing an Array with Excluded Values\u00b6","text":""},{"location":"notebooks/array_glyph/array_glyph_examples/#8-creating-a-custom-colorbar","title":"8. Creating a Custom Colorbar\u00b6","text":"<ul> <li>The ArrayGlyph class allows customization of the colorbar.</li> </ul>"},{"location":"notebooks/array_glyph/array_glyph_examples/#summary","title":"Summary\u00b6","text":"<p>In this notebook, we've explored the ArrayGlyph class from the Cleopatra package.</p> <p>We've seen how to:</p> <ol> <li>Create and visualize simple arrays</li> <li>Customize array visualizations</li> <li>Use different color scales</li> <li>Display cell values</li> <li>Display points on arrays</li> <li>Create animations</li> <li>Prepare arrays with different methods</li> <li>Create custom colorbars</li> </ol> <p>The ArrayGlyph class provides powerful tools for visualizing and animating arrays.</p>"},{"location":"notebooks/colors/colors_examples/","title":"Colors","text":"<ul> <li>This script demonstrates the usage of the Colors class from the Cleopatra package.</li> <li>The Colors class provides functionality for working with colors in different formats.</li> </ul> In\u00a0[26]: Copied! <pre>import matplotlib.pyplot as plt\nfrom cleopatra.colors import Colors\n</pre> import matplotlib.pyplot as plt from cleopatra.colors import Colors In\u00a0[\u00a0]: Copied! <pre>hex_color = Colors(\"#FF5733\")\nprint(f\"Hex color: {hex_color.color_value}\") # pragma: allowlist secret\n</pre> hex_color = Colors(\"#FF5733\") print(f\"Hex color: {hex_color.color_value}\") # pragma: allowlist secret In\u00a0[\u00a0]: Copied! <pre>named_color = Colors(\"blue\")\nprint(f\"Named color: {named_color.color_value}\")\n</pre> named_color = Colors(\"blue\") print(f\"Named color: {named_color.color_value}\") In\u00a0[\u00a0]: Copied! <pre>rgb_color_255 = Colors((255, 0, 0))\nprint(f\"RGB color (0-255): {rgb_color_255.color_value}\")\n</pre> rgb_color_255 = Colors((255, 0, 0)) print(f\"RGB color (0-255): {rgb_color_255.color_value}\") In\u00a0[\u00a0]: Copied! <pre>rgb_color_norm = Colors((1.0, 0.0, 0.0))\nprint(f\"RGB color (0-1): {rgb_color_norm.color_value}\")\n</pre> rgb_color_norm = Colors((1.0, 0.0, 0.0)) print(f\"RGB color (0-1): {rgb_color_norm.color_value}\") In\u00a0[6]: Copied! <pre>color_list = Colors([\"red\", \"green\", \"blue\"])\nprint(f\"Color list: {color_list.color_value}\")\n</pre> color_list = Colors([\"red\", \"green\", \"blue\"]) print(f\"Color list: {color_list.color_value}\") <pre>Color list: ['red', 'green', 'blue']\n</pre> <ul> <li>The to_hex() method converts colors to hexadecimal format.</li> </ul> In\u00a0[7]: Copied! <pre>named_to_hex = Colors(\"purple\")\nhex_value = named_to_hex.to_hex()\nprint(f\"Purple in hex: {hex_value}\")\n</pre> named_to_hex = Colors(\"purple\") hex_value = named_to_hex.to_hex() print(f\"Purple in hex: {hex_value}\") <pre>Purple in hex: ['purple']\n</pre> In\u00a0[8]: Copied! <pre>rgb_to_hex = Colors((0, 128, 0))  # Green in RGB\nhex_value = rgb_to_hex.to_hex()\nprint(f\"Green RGB in hex: {hex_value}\")\n</pre> rgb_to_hex = Colors((0, 128, 0))  # Green in RGB hex_value = rgb_to_hex.to_hex() print(f\"Green RGB in hex: {hex_value}\") <pre>Green RGB in hex: ['#008000']\n</pre> In\u00a0[9]: Copied! <pre>colors_to_hex = Colors([\"red\", (0, 0, 255), \"#00FF00\"])\nhex_values = colors_to_hex.to_hex()\nprint(f\"List of colors in hex: {hex_values}\")\n</pre> colors_to_hex = Colors([\"red\", (0, 0, 255), \"#00FF00\"]) hex_values = colors_to_hex.to_hex() print(f\"List of colors in hex: {hex_values}\") <pre>List of colors in hex: ['red', '#0000ff', '#00FF00']\n</pre> In\u00a0[10]: Copied! <pre>named_to_rgb = Colors(\"orange\")\nrgb_value = named_to_rgb.to_rgb(normalized=True)\nprint(f\"Orange in normalized RGB: {rgb_value}\")\n</pre> named_to_rgb = Colors(\"orange\") rgb_value = named_to_rgb.to_rgb(normalized=True) print(f\"Orange in normalized RGB: {rgb_value}\")  <pre>Orange in normalized RGB: [(1.0, 0.6470588235294118, 0.0)]\n</pre> In\u00a0[11]: Copied! <pre>named_to_rgb_255 = Colors(\"orange\")\nrgb_value_255 = named_to_rgb_255.to_rgb(normalized=False)\nprint(f\"Orange in RGB (0-255): {rgb_value_255}\")\n</pre> named_to_rgb_255 = Colors(\"orange\") rgb_value_255 = named_to_rgb_255.to_rgb(normalized=False) print(f\"Orange in RGB (0-255): {rgb_value_255}\") <pre>Orange in RGB (0-255): [(255, 165, 0)]\n</pre> In\u00a0[12]: Copied! <pre>hex_to_rgb = Colors(\"#4287f5\")  # Blue-ish color\nrgb_value = hex_to_rgb.to_rgb(normalized=True)\nprint(f\"#4287f5 in normalized RGB: {rgb_value}\")\n</pre> hex_to_rgb = Colors(\"#4287f5\")  # Blue-ish color rgb_value = hex_to_rgb.to_rgb(normalized=True) print(f\"#4287f5 in normalized RGB: {rgb_value}\") <pre>#4287f5 in normalized RGB: [(0.25882352941176473, 0.5294117647058824, 0.9607843137254902)]\n</pre> In\u00a0[13]: Copied! <pre>colors_to_rgb = Colors([\"red\", \"#00FF00\", (0, 0, 255)])\nrgb_values = colors_to_rgb.to_rgb(normalized=True)\nprint(f\"List of colors in normalized RGB: {rgb_values}\")\n</pre> colors_to_rgb = Colors([\"red\", \"#00FF00\", (0, 0, 255)]) rgb_values = colors_to_rgb.to_rgb(normalized=True) print(f\"List of colors in normalized RGB: {rgb_values}\") <pre>List of colors in normalized RGB: [(1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)]\n</pre> In\u00a0[14]: Copied! <pre>valid_hex = Colors.is_valid_hex_i(\"#FF5733\")\ninvalid_hex = Colors.is_valid_hex_i(\"#XYZ\")\nprint(f\"Is #FF5733 a valid hex color? {valid_hex}\")\nprint(f\"Is #XYZ a valid hex color? {invalid_hex}\")\n</pre> valid_hex = Colors.is_valid_hex_i(\"#FF5733\") invalid_hex = Colors.is_valid_hex_i(\"#XYZ\") print(f\"Is #FF5733 a valid hex color? {valid_hex}\") print(f\"Is #XYZ a valid hex color? {invalid_hex}\") <pre>Is #FF5733 a valid hex color? True\nIs #XYZ a valid hex color? False\n</pre> In\u00a0[15]: Copied! <pre>valid_rgb_255 = Colors.is_valid_rgb_255((255, 0, 0))\ninvalid_rgb_255 = Colors.is_valid_rgb_255((300, 0, 0))  # 300 is out of range\nprint(f\"Is (255, 0, 0) a valid RGB color? {valid_rgb_255}\")\nprint(f\"Is (300, 0, 0) a valid RGB color? {invalid_rgb_255}\")\n</pre> valid_rgb_255 = Colors.is_valid_rgb_255((255, 0, 0)) invalid_rgb_255 = Colors.is_valid_rgb_255((300, 0, 0))  # 300 is out of range print(f\"Is (255, 0, 0) a valid RGB color? {valid_rgb_255}\") print(f\"Is (300, 0, 0) a valid RGB color? {invalid_rgb_255}\") <pre>Is (255, 0, 0) a valid RGB color? True\nIs (300, 0, 0) a valid RGB color? False\n</pre> In\u00a0[16]: Copied! <pre>valid_rgb_norm = Colors.is_valid_rgb_norm((0.5, 0.5, 0.5))\ninvalid_rgb_norm = Colors.is_valid_rgb_norm((1.5, 0.5, 0.5))  # 1.5 is out of range\nprint(f\"Is (0.5, 0.5, 0.5) a valid normalized RGB color? {valid_rgb_norm}\")\nprint(f\"Is (1.5, 0.5, 0.5) a valid normalized RGB color? {invalid_rgb_norm}\")\n</pre> valid_rgb_norm = Colors.is_valid_rgb_norm((0.5, 0.5, 0.5)) invalid_rgb_norm = Colors.is_valid_rgb_norm((1.5, 0.5, 0.5))  # 1.5 is out of range print(f\"Is (0.5, 0.5, 0.5) a valid normalized RGB color? {valid_rgb_norm}\") print(f\"Is (1.5, 0.5, 0.5) a valid normalized RGB color? {invalid_rgb_norm}\") <pre>Is (0.5, 0.5, 0.5) a valid normalized RGB color? True\nIs (1.5, 0.5, 0.5) a valid normalized RGB color? False\n</pre> In\u00a0[17]: Copied! <pre>hex_color_type = Colors(\"#FF5733\")\nprint(f\"Type of #FF5733: {hex_color_type.get_type()}\")\n</pre> hex_color_type = Colors(\"#FF5733\") print(f\"Type of #FF5733: {hex_color_type.get_type()}\") <pre>Type of #FF5733: ['hex']\n</pre> In\u00a0[18]: Copied! <pre>named_color_type = Colors(\"blue\")\nprint(f\"Type of 'blue': {named_color_type.get_type()}\")\n</pre> named_color_type = Colors(\"blue\") print(f\"Type of 'blue': {named_color_type.get_type()}\") <pre>Type of 'blue': ['hex']\n</pre> In\u00a0[19]: Copied! <pre>rgb_color_type = Colors((255, 0, 0))\nprint(f\"Type of (255, 0, 0): {rgb_color_type.get_type()}\")\n</pre> rgb_color_type = Colors((255, 0, 0)) print(f\"Type of (255, 0, 0): {rgb_color_type.get_type()}\") <pre>Type of (255, 0, 0): ['rgb']\n</pre> In\u00a0[20]: Copied! <pre>color_list_type = Colors([\"red\", \"green\", \"blue\"])\nprint(f\"Type of ['red', 'green', 'blue']: {color_list_type.get_type()}\")\n</pre> color_list_type = Colors([\"red\", \"green\", \"blue\"]) print(f\"Type of ['red', 'green', 'blue']: {color_list_type.get_type()}\") <pre>Type of ['red', 'green', 'blue']: ['hex', 'hex', 'hex']\n</pre> In\u00a0[21]: Copied! <pre>color_names = [\"red\", \"green\", \"blue\", \"yellow\", \"purple\", \"orange\", \"cyan\", \"magenta\"]\ncolors_obj = Colors(color_names)\nhex_colors = colors_obj.to_hex()\n</pre> color_names = [\"red\", \"green\", \"blue\", \"yellow\", \"purple\", \"orange\", \"cyan\", \"magenta\"] colors_obj = Colors(color_names) hex_colors = colors_obj.to_hex() In\u00a0[22]: Copied! <pre>plt.figure(figsize=(10, 6))\nbars = plt.bar(range(len(color_names)), [1] * len(color_names), color=hex_colors)\n\n# Add color names as labels\nfor i, bar in enumerate(bars):\n    plt.text(bar.get_x() + bar.get_width()/2, 0.5, color_names[i], \n             ha='center', va='center', color='white' if color_names[i] in ['blue', 'purple'] else 'black')\n\nplt.title(\"Visualization of Different Colors\")\nplt.xticks([])\nplt.yticks([])\nplt.show()\n</pre> plt.figure(figsize=(10, 6)) bars = plt.bar(range(len(color_names)), [1] * len(color_names), color=hex_colors)  # Add color names as labels for i, bar in enumerate(bars):     plt.text(bar.get_x() + bar.get_width()/2, 0.5, color_names[i],               ha='center', va='center', color='white' if color_names[i] in ['blue', 'purple'] else 'black')  plt.title(\"Visualization of Different Colors\") plt.xticks([]) plt.yticks([]) plt.show() In\u00a0[23]: Copied! <pre>custom_colors = [\n    \"#1f77b4\",  # Blue\n    \"#ff7f0e\",  # Orange\n    \"#2ca02c\",  # Green\n    \"#d62728\",  # Red\n    \"#9467bd\",  # Purple\n    \"#8c564b\",  # Brown\n    \"#e377c2\",  # Pink\n    \"#7f7f7f\"   # Gray\n]\n</pre> custom_colors = [     \"#1f77b4\",  # Blue     \"#ff7f0e\",  # Orange     \"#2ca02c\",  # Green     \"#d62728\",  # Red     \"#9467bd\",  # Purple     \"#8c564b\",  # Brown     \"#e377c2\",  # Pink     \"#7f7f7f\"   # Gray ] In\u00a0[24]: Copied! <pre>custom_palette = Colors(custom_colors)\nrgb_palette = custom_palette.to_rgb(normalized=True)\n</pre> custom_palette = Colors(custom_colors) rgb_palette = custom_palette.to_rgb(normalized=True) In\u00a0[25]: Copied! <pre>plt.figure(figsize=(10, 6))\nbars = plt.bar(range(len(custom_colors)), [1] * len(custom_colors), color=custom_colors)\n\n# Add RGB values as labels\nfor i, bar in enumerate(bars):\n    rgb_values = [round(val, 2) for val in rgb_palette[i]]\n    plt.text(bar.get_x() + bar.get_width()/2, 0.5, str(rgb_values), \n             ha='center', va='center', color='white' if i in [0, 2, 4, 5] else 'black')\n\nplt.title(\"Custom Color Palette with RGB Values\")\nplt.xticks([])\nplt.yticks([])\nplt.show()\n</pre> plt.figure(figsize=(10, 6)) bars = plt.bar(range(len(custom_colors)), [1] * len(custom_colors), color=custom_colors)  # Add RGB values as labels for i, bar in enumerate(bars):     rgb_values = [round(val, 2) for val in rgb_palette[i]]     plt.text(bar.get_x() + bar.get_width()/2, 0.5, str(rgb_values),               ha='center', va='center', color='white' if i in [0, 2, 4, 5] else 'black')  plt.title(\"Custom Color Palette with RGB Values\") plt.xticks([]) plt.yticks([]) plt.show()"},{"location":"notebooks/colors/colors_examples/#colors","title":"Colors\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#1-initializing-colors-with-different-formats","title":"1. Initializing Colors with Different Formats\u00b6","text":"<p>The Colors class can be initialized with different color formats:</p> <ul> <li>Hex color strings (e.g., \"#FF5733\")</li> <li>Named colors (e.g., \"red\", \"blue\")</li> <li>RGB tuples (e.g., (255, 0, 0) or (1.0, 0.0, 0.0))</li> <li>Lists of any of the above</li> </ul>"},{"location":"notebooks/colors/colors_examples/#11-initializing-with-hex-colors","title":"1.1 Initializing with Hex Colors\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#12-initializing-with-named-colors","title":"1.2 Initializing with Named Colors\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#13-initializing-with-rgb-tuples-0-255","title":"1.3 Initializing with RGB Tuples (0-255)\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#14-initializing-with-rgb-tuples-0-1","title":"1.4 Initializing with RGB Tuples (0-1)\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#15-initializing-with-a-list-of-colors","title":"1.5 Initializing with a List of Colors\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#2-converting-colors-to-hex-format","title":"2. Converting Colors to Hex Format\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#21-converting-a-named-color-to-hex","title":"2.1 Converting a Named Color to Hex\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#22-converting-rgb-to-hex","title":"2.2 Converting RGB to Hex\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#23-converting-a-list-of-colors-to-hex","title":"2.3 Converting a List of Colors to Hex\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#3-converting-colors-to-rgb-format","title":"3. Converting Colors to RGB Format\u00b6","text":"<ul> <li>The to_rgb() method converts colors to RGB format.</li> </ul>"},{"location":"notebooks/colors/colors_examples/#31-converting-a-named-color-to-rgb-normalized","title":"3.1 Converting a Named Color to RGB (normalized)\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#32-converting-a-named-color-to-rgb-0-255","title":"3.2 Converting a Named Color to RGB (0-255)\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#33-converting-hex-to-rgb","title":"3.3 Converting Hex to RGB\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#34-converting-a-list-of-colors-to-rgb","title":"3.4 Converting a List of Colors to RGB\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#4-checking-color-validity","title":"4. Checking Color Validity\u00b6","text":"<ul> <li>The Colors class provides methods to check if colors are valid.</li> </ul>"},{"location":"notebooks/colors/colors_examples/#41-checking-if-a-hex-color-is-valid","title":"4.1 Checking if a Hex Color is Valid\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#42-checking-if-an-rgb-color-is-valid-0-255","title":"4.2 Checking if an RGB Color is Valid (0-255)\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#43-checking-if-an-rgb-color-is-valid-0-1","title":"4.3 Checking if an RGB Color is Valid (0-1)\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#5-getting-the-type-of-color","title":"5. Getting the Type of Color\u00b6","text":"<ul> <li>The get_type() method returns the type of color.</li> </ul>"},{"location":"notebooks/colors/colors_examples/#51-getting-the-type-of-a-hex-color","title":"5.1 Getting the Type of a Hex Color\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#52-getting-the-type-of-a-named-color","title":"5.2 Getting the Type of a Named Color\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#53-getting-the-type-of-an-rgb-color","title":"5.3 Getting the Type of an RGB Color\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#54-getting-the-type-of-a-list-of-colors","title":"5.4 Getting the Type of a List of Colors\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#6-visualizing-colors","title":"6. Visualizing Colors\u00b6","text":"<ul> <li>Let's visualize some colors using matplotlib.</li> </ul>"},{"location":"notebooks/colors/colors_examples/#61-create-a-list-of-colors","title":"6.1 Create a list of colors\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#62-create-a-bar-chart-with-these-colors","title":"6.2 Create a bar chart with these colors\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#7-creating-a-custom-color-palette","title":"7. Creating a Custom Color Palette\u00b6","text":"<ul> <li>Let's create a custom color palette and visualize it.</li> </ul>"},{"location":"notebooks/colors/colors_examples/#71-define-a-list-of-custom-colors","title":"7.1 Define a list of custom colors\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#72-create-a-colors-object-and-convert-to-rgb","title":"7.2 Create a Colors object and convert to RGB\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#73-visualize-the-palette","title":"7.3 Visualize the palette\u00b6","text":""},{"location":"notebooks/colors/colors_examples/#summary","title":"Summary\u00b6","text":"<p>In this notebook, we've explored the Colors class from the Cleopatra package. We've seen how to:</p> <ol> <li>Initialize the Colors class with different color formats</li> <li>Convert colors to hexadecimal format</li> <li>Convert colors to RGB format</li> <li>Check if colors are valid</li> <li>Get the type of color</li> <li>Visualize colors</li> <li>Create custom color palettes</li> </ol> <p>The Colors class provides a convenient way to work with colors in different formats for data visualization and plotting.</p>"},{"location":"notebooks/statistics/statistics_examples/","title":"Statistics","text":"<ul> <li>This script demonstrates the usage of the Statistic class from the Cleopatra package.</li> <li>The Statistic class provides functionality for creating statistical plots, specifically histograms.</li> </ul> In\u00a0[1]: Copied! <pre>import numpy as np\nfrom cleopatra.statistics import Statistic\n\n# Set the random seed for reproducibility\nnp.random.seed(1)\n</pre> import numpy as np from cleopatra.statistics import Statistic  # Set the random seed for reproducibility np.random.seed(1) In\u00a0[2]: Copied! <pre>data_1d = 4 + np.random.normal(0, 1.5, 200)\n</pre> data_1d = 4 + np.random.normal(0, 1.5, 200) In\u00a0[3]: Copied! <pre>stat_plot_1d = Statistic(data_1d)\n</pre> stat_plot_1d = Statistic(data_1d) In\u00a0[4]: Copied! <pre>fig_1d, ax_1d, hist_1d = stat_plot_1d.histogram()\n\n# Display information about the histogram\nprint(f\"Number of bins: {len(hist_1d['n'][0])}\")\nprint(f\"Bin counts: {hist_1d['n'][0]}\")\nprint(f\"Bin edges: {hist_1d['bins'][0][:5]}... (showing first 5)\")\n</pre> fig_1d, ax_1d, hist_1d = stat_plot_1d.histogram()  # Display information about the histogram print(f\"Number of bins: {len(hist_1d['n'][0])}\") print(f\"Bin counts: {hist_1d['n'][0]}\") print(f\"Bin edges: {hist_1d['bins'][0][:5]}... (showing first 5)\") <pre>Number of bins: 15\nBin counts: [ 2.  4.  3. 10. 11. 20. 30. 27. 31. 25. 17.  8.  5.  6.  1.]\nBin edges: [0.34774335 0.8440597  1.34037605 1.8366924  2.33300874]... (showing first 5)\n</pre> In\u00a0[5]: Copied! <pre>stat_plot_1d_custom = Statistic(data_1d)\n</pre> stat_plot_1d_custom = Statistic(data_1d) In\u00a0[6]: Copied! <pre>fig_1d_custom, ax_1d_custom, hist_1d_custom = stat_plot_1d_custom.histogram(\n    bins=20,                # Increase the number of bins\n    color=[\"#FF5733\"],      # Change the color to orange-red\n    alpha=0.8,              # Slightly increase transparency\n    rwidth=0.9,             # Increase the width of the bins\n    xlabel=\"Values\",         # Add x-axis label\n    ylabel=\"Frequency\",      # Add y-axis label\n    xlabel_font_size=12,    # Set x-axis label font size\n    ylabel_font_size=12,    # Set y-axis label font size\n    grid_alpha=0.3          # Reduce grid transparency\n)\n</pre> fig_1d_custom, ax_1d_custom, hist_1d_custom = stat_plot_1d_custom.histogram(     bins=20,                # Increase the number of bins     color=[\"#FF5733\"],      # Change the color to orange-red     alpha=0.8,              # Slightly increase transparency     rwidth=0.9,             # Increase the width of the bins     xlabel=\"Values\",         # Add x-axis label     ylabel=\"Frequency\",      # Add y-axis label     xlabel_font_size=12,    # Set x-axis label font size     ylabel_font_size=12,    # Set y-axis label font size     grid_alpha=0.3          # Reduce grid transparency ) In\u00a0[7]: Copied! <pre>data_2d = np.zeros((200, 3))\ndata_2d[:, 0] = 3 + np.random.normal(0, 1.0, 200)  # Mean of 3, std of 1.0\ndata_2d[:, 1] = 5 + np.random.normal(0, 1.2, 200)  # Mean of 5, std of 1.2\ndata_2d[:, 2] = 7 + np.random.normal(0, 0.8, 200)  # Mean of 7, std of 0.8\n</pre> data_2d = np.zeros((200, 3)) data_2d[:, 0] = 3 + np.random.normal(0, 1.0, 200)  # Mean of 3, std of 1.0 data_2d[:, 1] = 5 + np.random.normal(0, 1.2, 200)  # Mean of 5, std of 1.2 data_2d[:, 2] = 7 + np.random.normal(0, 0.8, 200)  # Mean of 7, std of 0.8 In\u00a0[8]: Copied! <pre>stat_plot_2d = Statistic(data_2d)\n</pre> stat_plot_2d = Statistic(data_2d) <ul> <li><p>Generate a histogram plot for the 2D data</p> </li> <li><p>Note: We need to provide colors for each column</p> </li> </ul> In\u00a0[9]: Copied! <pre>fig_2d, ax_2d, hist_2d = stat_plot_2d.histogram(color=[\"red\", \"green\", \"blue\"])\n</pre> fig_2d, ax_2d, hist_2d = stat_plot_2d.histogram(color=[\"red\", \"green\", \"blue\"]) In\u00a0[10]: Copied! <pre>stat_plot_2d_custom = Statistic(\n    data_2d,\n    color=[\"#FF5733\", \"#33FF57\", \"#3357FF\"],  # Custom colors\n    alpha=0.5,                                # Set transparency\n    rwidth=0.8                                # Set bin width\n)\n</pre> stat_plot_2d_custom = Statistic(     data_2d,     color=[\"#FF5733\", \"#33FF57\", \"#3357FF\"],  # Custom colors     alpha=0.5,                                # Set transparency     rwidth=0.8                                # Set bin width ) In\u00a0[11]: Copied! <pre>fig_2d_custom, ax_2d_custom, hist_2d_custom = stat_plot_2d_custom.histogram(\n    bins=25,                # Increase the number of bins\n    xlabel=\"Values\",         # Add x-axis label\n    ylabel=\"Frequency\",      # Add y-axis label\n    xlabel_font_size=14,    # Set x-axis label font size\n    ylabel_font_size=14,    # Set y-axis label font size\n    xtick_font_size=10,     # Set x-axis tick font size\n    ytick_font_size=10,     # Set y-axis tick font size\n    grid_alpha=0.2,         # Reduce grid transparency\n    figsize=(10, 6)         # Set figure size\n)\n</pre> fig_2d_custom, ax_2d_custom, hist_2d_custom = stat_plot_2d_custom.histogram(     bins=25,                # Increase the number of bins     xlabel=\"Values\",         # Add x-axis label     ylabel=\"Frequency\",      # Add y-axis label     xlabel_font_size=14,    # Set x-axis label font size     ylabel_font_size=14,    # Set y-axis label font size     xtick_font_size=10,     # Set x-axis tick font size     ytick_font_size=10,     # Set y-axis tick font size     grid_alpha=0.2,         # Reduce grid transparency     figsize=(10, 6)         # Set figure size ) In\u00a0[12]: Copied! <pre>n_samples = 1000\ndata_distributions = np.zeros((n_samples, 3))\n</pre> n_samples = 1000 data_distributions = np.zeros((n_samples, 3)) In\u00a0[13]: Copied! <pre>data_distributions[:, 0] = np.random.normal(0, 1, n_samples)\n</pre> data_distributions[:, 0] = np.random.normal(0, 1, n_samples) In\u00a0[14]: Copied! <pre>data_distributions[:, 1] = np.random.exponential(1, n_samples)\n</pre> data_distributions[:, 1] = np.random.exponential(1, n_samples) In\u00a0[15]: Copied! <pre>data_distributions[:, 2] = np.random.uniform(-1.5, 1.5, n_samples)\n</pre> data_distributions[:, 2] = np.random.uniform(-1.5, 1.5, n_samples) In\u00a0[16]: Copied! <pre>stat_plot_distributions = Statistic(\n    data_distributions,\n    color=[\"#3498DB\", \"#E74C3C\", \"#2ECC71\"],  # Blue, Red, Green\n    alpha=0.6,\n    rwidth=0.9\n)\n</pre> stat_plot_distributions = Statistic(     data_distributions,     color=[\"#3498DB\", \"#E74C3C\", \"#2ECC71\"],  # Blue, Red, Green     alpha=0.6,     rwidth=0.9 ) In\u00a0[17]: Copied! <pre>fig_dist, ax_dist, hist_dist = stat_plot_distributions.histogram(\n    bins=30,\n    xlabel=\"Values\",\n    ylabel=\"Frequency\",\n    figsize=(12, 7)\n)\n\n# Add a legend to identify the distributions\nax_dist.legend([\"Normal\", \"Exponential\", \"Uniform\"])\n</pre> fig_dist, ax_dist, hist_dist = stat_plot_distributions.histogram(     bins=30,     xlabel=\"Values\",     ylabel=\"Frequency\",     figsize=(12, 7) )  # Add a legend to identify the distributions ax_dist.legend([\"Normal\", \"Exponential\", \"Uniform\"]) Out[17]: <pre>&lt;matplotlib.legend.Legend at 0x175e8aba660&gt;</pre> In\u00a0[18]: Copied! <pre>try:\n    # Create a Statistic object with 2D data but only 2 colors for 3 columns\n    stat_plot_error = Statistic(data_2d)\n    \n    # This should raise an error because we're providing only 2 colors for 3 columns\n    fig_error, ax_error, hist_error = stat_plot_error.histogram(color=[\"red\", \"green\"])\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n</pre> try:     # Create a Statistic object with 2D data but only 2 colors for 3 columns     stat_plot_error = Statistic(data_2d)          # This should raise an error because we're providing only 2 colors for 3 columns     fig_error, ax_error, hist_error = stat_plot_error.histogram(color=[\"red\", \"green\"]) except ValueError as e:     print(f\"Error: {e}\") <pre>Error: The number of colors:2 should be equal to the number of samples:3\n</pre>"},{"location":"notebooks/statistics/statistics_examples/#statistics","title":"Statistics\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#1-creating-histograms-with-1d-data","title":"1. Creating Histograms with 1D Data\u00b6","text":"<ul> <li>Let's start by creating a histogram for 1D data.</li> <li>We'll generate some random data and use the Statistic class to create a histogram.</li> </ul>"},{"location":"notebooks/statistics/statistics_examples/#generate-1d-data","title":"Generate 1D data\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#create-a-statistic-object-with-the-1d-data","title":"Create a Statistic object with the 1D data\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#generate-a-histogram-plot-for-the-1d-data","title":"Generate a histogram plot for the 1D data\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#11-customizing-the-histogram","title":"1.1 Customizing the Histogram\u00b6","text":"<ul> <li>Now let's customize the histogram by changing the number of bins, color, transparency, and width.</li> </ul>"},{"location":"notebooks/statistics/statistics_examples/#create-a-statistic-object-with-the-1d-data","title":"Create a Statistic object with the 1D data\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#generate-a-customized-histogram-plot","title":"Generate a customized histogram plot\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#2-creating-histograms-with-2d-data","title":"2. Creating Histograms with 2D Data\u00b6","text":"<ul> <li>The Statistic class can also handle 2D data, creating multiple histograms in the same plot.</li> <li>Let's generate some 2D data and create histograms.</li> </ul>"},{"location":"notebooks/statistics/statistics_examples/#generate-2d-data-with-3-columns","title":"Generate 2D data with 3 columns\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#create-a-statistic-object-with-the-2d-data","title":"Create a Statistic object with the 2D data\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#21-customizing-the-2d-histogram","title":"2.1 Customizing the 2D Histogram\u00b6","text":"<ul> <li>Let's customize the 2D histogram with more options.</li> </ul>"},{"location":"notebooks/statistics/statistics_examples/#create-a-statistic-object-with-the-2d-data-and-custom-parameters","title":"Create a Statistic object with the 2D data and custom parameters\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#generate-a-customized-histogram-plot","title":"Generate a customized histogram plot\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#3-comparing-distributions","title":"3. Comparing Distributions\u00b6","text":"<ul> <li>The Statistic class is particularly useful for comparing multiple distributions.</li> <li>Let's create an example that compares different distributions.</li> </ul>"},{"location":"notebooks/statistics/statistics_examples/#generate-data-from-different-distributions","title":"Generate data from different distributions\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#normal-distribution","title":"Normal distribution\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#exponential-distribution","title":"Exponential distribution\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#uniform-distribution","title":"Uniform distribution\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#create-a-statistic-object-with-the-distribution-data","title":"Create a Statistic object with the distribution data\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#generate-a-histogram-plot-comparing-the-distributions","title":"Generate a histogram plot comparing the distributions\u00b6","text":""},{"location":"notebooks/statistics/statistics_examples/#4-error-handling","title":"4. Error Handling\u00b6","text":"<ul> <li>The Statistic class includes error handling to ensure that the number of colors</li> <li>provided matches the number of samples in the data.</li> <li>Let's see what happens when we provide an incorrect number of colors.</li> </ul>"},{"location":"notebooks/statistics/statistics_examples/#summary","title":"Summary\u00b6","text":"<p>In this notebook, we've explored the Statistic class from the Cleopatra package. We've seen how to:</p> <ol> <li>Create histograms for 1D data</li> <li>Create histograms for 2D data</li> <li>Customize histograms with various parameters</li> <li>Compare different distributions</li> <li>Handle errors when using the class</li> </ol> <p>The Statistic class provides a convenient way to create and customize histograms for statistical analysis and visualization.</p>"},{"location":"notebooks/styles/styles_examples/","title":"Styles","text":"In\u00a0[13]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nfrom cleopatra.styles import Styles, Scale, MidpointNormalize\nimport matplotlib.colors as colors\n</pre> import numpy as np import matplotlib.pyplot as plt from cleopatra.styles import Styles, Scale, MidpointNormalize import matplotlib.colors as colors In\u00a0[14]: Copied! <pre># Get a list of available line style names\nline_style_names = [\n    \"solid\", \"dotted\", \"dashed\", \"dashdot\", \n    \"loosely dotted\", \"densely dotted\", \n    \"loosely dashed\", \"densely dashed\", \n    \"loosely dashdotted\", \"densely dashdotted\"\n]\n\n# Create a figure to display different line styles\nplt.figure(figsize=(12, 8))\n\n# Plot each line style\nfor i, style_name in enumerate(line_style_names):\n    # Get the line style\n    line_style = Styles.get_line_style(style_name)\n\n    # Plot a line with this style\n    plt.plot([0, 1], [i, i], linestyle=line_style, linewidth=2, color='blue', label=style_name)\n\n    # Add the style name as text\n    plt.text(1.1, i, style_name, va='center')\n\nplt.xlim(0, 2)\nplt.ylim(-0.5, len(line_style_names) - 0.5)\nplt.title(\"Line Styles Available in Styles Class\")\nplt.grid(True, linestyle='--', alpha=0.7)\nplt.tight_layout()\nplt.show()\n</pre> # Get a list of available line style names line_style_names = [     \"solid\", \"dotted\", \"dashed\", \"dashdot\",      \"loosely dotted\", \"densely dotted\",      \"loosely dashed\", \"densely dashed\",      \"loosely dashdotted\", \"densely dashdotted\" ]  # Create a figure to display different line styles plt.figure(figsize=(12, 8))  # Plot each line style for i, style_name in enumerate(line_style_names):     # Get the line style     line_style = Styles.get_line_style(style_name)      # Plot a line with this style     plt.plot([0, 1], [i, i], linestyle=line_style, linewidth=2, color='blue', label=style_name)      # Add the style name as text     plt.text(1.1, i, style_name, va='center')  plt.xlim(0, 2) plt.ylim(-0.5, len(line_style_names) - 0.5) plt.title(\"Line Styles Available in Styles Class\") plt.grid(True, linestyle='--', alpha=0.7) plt.tight_layout() plt.show() <pre> The style name you entered-dashdot-does not exist pleasechoose from the available styles\n['solid', 'loosely dotted', 'dotted', 'densely dotted', 'loosely dashed', 'dashed', 'densely dashed', 'loosely dashdotted', 'dashdotted', 'densely dashdotted', 'loosely dashdotdotted', 'dashdotdotted', 'densely dashdotdotted', 'densely dashdotdottededited']\n</pre> In\u00a0[15]: Copied! <pre># Create a list of standard matplotlib markers\nstandard_markers = ['o', 's', 'D', '^', 'v', '&lt;', '&gt;', 'p', '*', 'h', '+', 'x', '|', '_', '.', ',', '1', '2', '3', '4', '8']\n\n# Create a figure to display different marker styles\nplt.figure(figsize=(12, 8))\n\n# Plot markers\nfor i, marker in enumerate(standard_markers):\n    if i &gt;= 21:  # Limit to 21 markers to match the original example\n        break\n\n    # Calculate grid position (5 markers per row)\n    row = i // 5\n    col = i % 5\n\n    # Plot the marker\n    plt.plot(col, row, marker=marker, markersize=15, color='blue')\n\n    # Add the marker as text\n    plt.text(col + 0.2, row, f\"Marker '{marker}'\", va='center')\n\nplt.xlim(-0.5, 5.5)\nplt.ylim(-0.5, 4.5)\nplt.gca().invert_yaxis()  # Invert y-axis to have marker 0 at the top\nplt.title(\"Standard Matplotlib Markers\")\nplt.grid(False)\nplt.tight_layout()\nplt.show()\n</pre> # Create a list of standard matplotlib markers standard_markers = ['o', 's', 'D', '^', 'v', '&lt;', '&gt;', 'p', '*', 'h', '+', 'x', '|', '_', '.', ',', '1', '2', '3', '4', '8']  # Create a figure to display different marker styles plt.figure(figsize=(12, 8))  # Plot markers for i, marker in enumerate(standard_markers):     if i &gt;= 21:  # Limit to 21 markers to match the original example         break      # Calculate grid position (5 markers per row)     row = i // 5     col = i % 5      # Plot the marker     plt.plot(col, row, marker=marker, markersize=15, color='blue')      # Add the marker as text     plt.text(col + 0.2, row, f\"Marker '{marker}'\", va='center')  plt.xlim(-0.5, 5.5) plt.ylim(-0.5, 4.5) plt.gca().invert_yaxis()  # Invert y-axis to have marker 0 at the top plt.title(\"Standard Matplotlib Markers\") plt.grid(False) plt.tight_layout() plt.show() In\u00a0[16]: Copied! <pre># Create some sample data\nx = np.linspace(0, 10, 100)\ny = np.exp(x/5)  # Exponential data that grows quickly\n\n# 2.1 Log Scale\n# The log_scale method applies a logarithmic scale to the data.\n\n# Apply log scale to the data\ny_log = Scale.log_scale(y)\n\n# Plot original and log-scaled data\nplt.figure(figsize=(12, 6))\n\nplt.subplot(1, 2, 1)\nplt.plot(x, y, 'b-', linewidth=2)\nplt.title(\"Original Data (Exponential)\")\nplt.grid(True)\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\n\nplt.subplot(1, 2, 2)\nplt.plot(x, y_log, 'r-', linewidth=2)\nplt.title(\"Log-Scaled Data\")\nplt.grid(True)\nplt.xlabel(\"x\")\nplt.ylabel(\"log(y)\")\n\nplt.tight_layout()\nplt.show()\n</pre> # Create some sample data x = np.linspace(0, 10, 100) y = np.exp(x/5)  # Exponential data that grows quickly  # 2.1 Log Scale # The log_scale method applies a logarithmic scale to the data.  # Apply log scale to the data y_log = Scale.log_scale(y)  # Plot original and log-scaled data plt.figure(figsize=(12, 6))  plt.subplot(1, 2, 1) plt.plot(x, y, 'b-', linewidth=2) plt.title(\"Original Data (Exponential)\") plt.grid(True) plt.xlabel(\"x\") plt.ylabel(\"y\")  plt.subplot(1, 2, 2) plt.plot(x, y_log, 'r-', linewidth=2) plt.title(\"Log-Scaled Data\") plt.grid(True) plt.xlabel(\"x\") plt.ylabel(\"log(y)\")  plt.tight_layout() plt.show() In\u00a0[17]: Copied! <pre># Create power scale functions with different minimum values\npower_scale_func1 = Scale.power_scale(min_val=0)\npower_scale_func2 = Scale.power_scale(min_val=1)\npower_scale_func3 = Scale.power_scale(min_val=2)\n\n# Apply power scale to the data\ny_power_1 = power_scale_func1(y)  # Power scale with min_val=0\ny_power_2 = power_scale_func2(y)  # Power scale with min_val=1\ny_power_3 = power_scale_func3(y)  # Power scale with min_val=2\n\n# Plot original and power-scaled data\nplt.figure(figsize=(12, 8))\n\nplt.subplot(2, 2, 1)\nplt.plot(x, y, 'b-', linewidth=2)\nplt.title(\"Original Data\")\nplt.grid(True)\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\n\nplt.subplot(2, 2, 2)\nplt.plot(x, y_power_1, 'r-', linewidth=2)\nplt.title(\"Power Scale (min_val=0)\")\nplt.grid(True)\nplt.xlabel(\"x\")\nplt.ylabel(\"y (power scaled)\")\n\nplt.subplot(2, 2, 3)\nplt.plot(x, y_power_2, 'g-', linewidth=2)\nplt.title(\"Power Scale (min_val=1)\")\nplt.grid(True)\nplt.xlabel(\"x\")\nplt.ylabel(\"y (power scaled)\")\n\nplt.subplot(2, 2, 4)\nplt.plot(x, y_power_3, 'm-', linewidth=2)\nplt.title(\"Power Scale (min_val=2)\")\nplt.grid(True)\nplt.xlabel(\"x\")\nplt.ylabel(\"y (power scaled)\")\n\nplt.tight_layout()\nplt.show()\n</pre> # Create power scale functions with different minimum values power_scale_func1 = Scale.power_scale(min_val=0) power_scale_func2 = Scale.power_scale(min_val=1) power_scale_func3 = Scale.power_scale(min_val=2)  # Apply power scale to the data y_power_1 = power_scale_func1(y)  # Power scale with min_val=0 y_power_2 = power_scale_func2(y)  # Power scale with min_val=1 y_power_3 = power_scale_func3(y)  # Power scale with min_val=2  # Plot original and power-scaled data plt.figure(figsize=(12, 8))  plt.subplot(2, 2, 1) plt.plot(x, y, 'b-', linewidth=2) plt.title(\"Original Data\") plt.grid(True) plt.xlabel(\"x\") plt.ylabel(\"y\")  plt.subplot(2, 2, 2) plt.plot(x, y_power_1, 'r-', linewidth=2) plt.title(\"Power Scale (min_val=0)\") plt.grid(True) plt.xlabel(\"x\") plt.ylabel(\"y (power scaled)\")  plt.subplot(2, 2, 3) plt.plot(x, y_power_2, 'g-', linewidth=2) plt.title(\"Power Scale (min_val=1)\") plt.grid(True) plt.xlabel(\"x\") plt.ylabel(\"y (power scaled)\")  plt.subplot(2, 2, 4) plt.plot(x, y_power_3, 'm-', linewidth=2) plt.title(\"Power Scale (min_val=2)\") plt.grid(True) plt.xlabel(\"x\") plt.ylabel(\"y (power scaled)\")  plt.tight_layout() plt.show() In\u00a0[18]: Copied! <pre># Create some data with values between -10 and 10\nx = np.linspace(0, 10, 100)\ny = np.sin(x) * 10\n\n# Create a custom scaling function that scales data to range [0, 1]\ndef custom_scale(values, old_min=-10, old_max=10):\n    \"\"\"Scale values from range [old_min, old_max] to range [0, 1]\"\"\"\n    return (values - old_min) / (old_max - old_min)\n\n# Apply custom scale to the data\ny_scaled = custom_scale(y)\n\n# Plot original and identity-scaled data\nplt.figure(figsize=(12, 6))\n\nplt.subplot(1, 2, 1)\nplt.plot(x, y, 'b-', linewidth=2)\nplt.title(\"Original Data\")\nplt.grid(True)\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.ylim(-12, 12)\n\nplt.subplot(1, 2, 2)\nplt.plot(x, y_scaled, 'r-', linewidth=2)\nplt.title(\"Custom-Scaled Data (0-1)\")\nplt.grid(True)\nplt.xlabel(\"x\")\nplt.ylabel(\"Scaled y\")\nplt.ylim(-0.2, 1.2)\n\nplt.tight_layout()\nplt.show()\n</pre> # Create some data with values between -10 and 10 x = np.linspace(0, 10, 100) y = np.sin(x) * 10  # Create a custom scaling function that scales data to range [0, 1] def custom_scale(values, old_min=-10, old_max=10):     \"\"\"Scale values from range [old_min, old_max] to range [0, 1]\"\"\"     return (values - old_min) / (old_max - old_min)  # Apply custom scale to the data y_scaled = custom_scale(y)  # Plot original and identity-scaled data plt.figure(figsize=(12, 6))  plt.subplot(1, 2, 1) plt.plot(x, y, 'b-', linewidth=2) plt.title(\"Original Data\") plt.grid(True) plt.xlabel(\"x\") plt.ylabel(\"y\") plt.ylim(-12, 12)  plt.subplot(1, 2, 2) plt.plot(x, y_scaled, 'r-', linewidth=2) plt.title(\"Custom-Scaled Data (0-1)\") plt.grid(True) plt.xlabel(\"x\") plt.ylabel(\"Scaled y\") plt.ylim(-0.2, 1.2)  plt.tight_layout() plt.show() In\u00a0[19]: Copied! <pre># Create some data\nx = np.linspace(0, 10, 100)\ny = np.sin(x)  # Values between -1 and 1\n\n# Rescale the data from range [-1, 1] to range [0, 100]\ny_rescaled = Scale.rescale(y, old_min=-1, old_max=1, new_min=0, new_max=100)\n\n# Plot original and rescaled data\nplt.figure(figsize=(12, 6))\n\nplt.subplot(1, 2, 1)\nplt.plot(x, y, 'b-', linewidth=2)\nplt.title(\"Original Data (Range: -1 to 1)\")\nplt.grid(True)\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.ylim(-1.2, 1.2)\n\nplt.subplot(1, 2, 2)\nplt.plot(x, y_rescaled, 'r-', linewidth=2)\nplt.title(\"Rescaled Data (Range: 0 to 100)\")\nplt.grid(True)\nplt.xlabel(\"x\")\nplt.ylabel(\"Rescaled y\")\nplt.ylim(-10, 110)\n\nplt.tight_layout()\nplt.show()\n</pre> # Create some data x = np.linspace(0, 10, 100) y = np.sin(x)  # Values between -1 and 1  # Rescale the data from range [-1, 1] to range [0, 100] y_rescaled = Scale.rescale(y, old_min=-1, old_max=1, new_min=0, new_max=100)  # Plot original and rescaled data plt.figure(figsize=(12, 6))  plt.subplot(1, 2, 1) plt.plot(x, y, 'b-', linewidth=2) plt.title(\"Original Data (Range: -1 to 1)\") plt.grid(True) plt.xlabel(\"x\") plt.ylabel(\"y\") plt.ylim(-1.2, 1.2)  plt.subplot(1, 2, 2) plt.plot(x, y_rescaled, 'r-', linewidth=2) plt.title(\"Rescaled Data (Range: 0 to 100)\") plt.grid(True) plt.xlabel(\"x\") plt.ylabel(\"Rescaled y\") plt.ylim(-10, 110)  plt.tight_layout() plt.show() In\u00a0[20]: Copied! <pre># Create a 2D array with positive and negative values\ndelta = 0.025\nx = np.arange(-3.0, 3.0, delta)\ny = np.arange(-2.0, 2.0, delta)\nX, Y = np.meshgrid(x, y)\nZ = np.sin(X) * np.cos(Y) * 3  # Values between -3 and 3\n\n# 3.1 Standard Normalization\n# First, let's use the standard normalization for comparison\nplt.figure(figsize=(15, 5))\n\nplt.subplot(1, 3, 1)\nstandard_norm = plt.pcolormesh(X, Y, Z, cmap='RdBu_r', shading='auto')\nplt.colorbar(standard_norm)\nplt.title(\"Standard Normalization\")\nplt.axis('equal')\n\n# 3.2 MidpointNormalize with midpoint=0\n# Now, let's use MidpointNormalize with midpoint at 0\nmidpoint_norm_0 = MidpointNormalize(vmin=-3, vmax=3, midpoint=0)\nplt.subplot(1, 3, 2)\nmid_norm_plot = plt.pcolormesh(X, Y, Z, norm=midpoint_norm_0, cmap='RdBu_r', shading='auto')\nplt.colorbar(mid_norm_plot)\nplt.title(\"MidpointNormalize (midpoint=0)\")\nplt.axis('equal')\n\n# 3.3 MidpointNormalize with midpoint=1\n# Let's use MidpointNormalize with midpoint at 1\nmidpoint_norm_1 = MidpointNormalize(vmin=-3, vmax=3, midpoint=1)\nplt.subplot(1, 3, 3)\nmid_norm_plot_1 = plt.pcolormesh(X, Y, Z, norm=midpoint_norm_1, cmap='RdBu_r', shading='auto')\nplt.colorbar(mid_norm_plot_1)\nplt.title(\"MidpointNormalize (midpoint=1)\")\nplt.axis('equal')\n\nplt.tight_layout()\nplt.show()\n</pre> # Create a 2D array with positive and negative values delta = 0.025 x = np.arange(-3.0, 3.0, delta) y = np.arange(-2.0, 2.0, delta) X, Y = np.meshgrid(x, y) Z = np.sin(X) * np.cos(Y) * 3  # Values between -3 and 3  # 3.1 Standard Normalization # First, let's use the standard normalization for comparison plt.figure(figsize=(15, 5))  plt.subplot(1, 3, 1) standard_norm = plt.pcolormesh(X, Y, Z, cmap='RdBu_r', shading='auto') plt.colorbar(standard_norm) plt.title(\"Standard Normalization\") plt.axis('equal')  # 3.2 MidpointNormalize with midpoint=0 # Now, let's use MidpointNormalize with midpoint at 0 midpoint_norm_0 = MidpointNormalize(vmin=-3, vmax=3, midpoint=0) plt.subplot(1, 3, 2) mid_norm_plot = plt.pcolormesh(X, Y, Z, norm=midpoint_norm_0, cmap='RdBu_r', shading='auto') plt.colorbar(mid_norm_plot) plt.title(\"MidpointNormalize (midpoint=0)\") plt.axis('equal')  # 3.3 MidpointNormalize with midpoint=1 # Let's use MidpointNormalize with midpoint at 1 midpoint_norm_1 = MidpointNormalize(vmin=-3, vmax=3, midpoint=1) plt.subplot(1, 3, 3) mid_norm_plot_1 = plt.pcolormesh(X, Y, Z, norm=midpoint_norm_1, cmap='RdBu_r', shading='auto') plt.colorbar(mid_norm_plot_1) plt.title(\"MidpointNormalize (midpoint=1)\") plt.axis('equal')  plt.tight_layout() plt.show() In\u00a0[21]: Copied! <pre># Create some data\nx = np.linspace(0, 10, 100)\ny1 = np.sin(x)\ny2 = np.cos(x)\ny3 = np.sin(x) * np.exp(x/10)\ny4 = np.cos(x) * np.exp(-x/10)\n\n# Create a figure with different line styles and markers\nplt.figure(figsize=(12, 8))\n\n# Define standard matplotlib markers to use\nmarkers = ['o', 's', '^', 'D']\n\n# Plot with solid line style\nplt.plot(x, y1, linestyle=Styles.get_line_style(\"solid\"), \n         marker=markers[0], markersize=8, \n         markevery=10, linewidth=2, label=\"sin(x)\")\n\n# Plot with dashed line style\nplt.plot(x, y2, linestyle=Styles.get_line_style(\"dashed\"), \n         marker=markers[1], markersize=8, \n         markevery=10, linewidth=2, label=\"cos(x)\")\n\n# Plot with dashdot line style\nplt.plot(x, y3, linestyle=Styles.get_line_style(\"dashdot\"), \n         marker=markers[2], markersize=8, \n         markevery=10, linewidth=2, label=\"sin(x) * exp(x/10)\")\n\n# Plot with dotted line style\nplt.plot(x, y4, linestyle=Styles.get_line_style(\"dotted\"), \n         marker=markers[3], markersize=8, \n         markevery=10, linewidth=2, label=\"cos(x) * exp(-x/10)\")\n\nplt.title(\"Combining Different Styles\")\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.grid(True, linestyle='--', alpha=0.7)\nplt.legend()\nplt.tight_layout()\nplt.show()\n</pre> # Create some data x = np.linspace(0, 10, 100) y1 = np.sin(x) y2 = np.cos(x) y3 = np.sin(x) * np.exp(x/10) y4 = np.cos(x) * np.exp(-x/10)  # Create a figure with different line styles and markers plt.figure(figsize=(12, 8))  # Define standard matplotlib markers to use markers = ['o', 's', '^', 'D']  # Plot with solid line style plt.plot(x, y1, linestyle=Styles.get_line_style(\"solid\"),           marker=markers[0], markersize=8,           markevery=10, linewidth=2, label=\"sin(x)\")  # Plot with dashed line style plt.plot(x, y2, linestyle=Styles.get_line_style(\"dashed\"),           marker=markers[1], markersize=8,           markevery=10, linewidth=2, label=\"cos(x)\")  # Plot with dashdot line style plt.plot(x, y3, linestyle=Styles.get_line_style(\"dashdot\"),           marker=markers[2], markersize=8,           markevery=10, linewidth=2, label=\"sin(x) * exp(x/10)\")  # Plot with dotted line style plt.plot(x, y4, linestyle=Styles.get_line_style(\"dotted\"),           marker=markers[3], markersize=8,           markevery=10, linewidth=2, label=\"cos(x) * exp(-x/10)\")  plt.title(\"Combining Different Styles\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.grid(True, linestyle='--', alpha=0.7) plt.legend() plt.tight_layout() plt.show() <pre> The style name you entered-dashdot-does not exist pleasechoose from the available styles\n['solid', 'loosely dotted', 'dotted', 'densely dotted', 'loosely dashed', 'dashed', 'densely dashed', 'loosely dashdotted', 'dashdotted', 'densely dashdotted', 'loosely dashdotdotted', 'dashdotdotted', 'densely dashdotdotted', 'densely dashdotdottededited']\n</pre>"},{"location":"notebooks/styles/styles_examples/#styles","title":"Styles\u00b6","text":"<ul> <li><p>This notebook demonstrates the usage of the Styles, Scale, and MidpointNormalize classes from the Cleopatra package.</p> </li> <li><p>The styles class provides functionality for styling and scaling visualizations.</p> </li> </ul>"},{"location":"notebooks/styles/styles_examples/#1-using-the-styles-class","title":"1. Using the Styles Class\u00b6","text":"<ul> <li>The Styles class provides methods for getting line and marker styles.</li> </ul>"},{"location":"notebooks/styles/styles_examples/#11-getting-line-styles","title":"1.1 Getting Line Styles\u00b6","text":"<ul> <li>The get_line_style method returns line styles for matplotlib plots.</li> </ul>"},{"location":"notebooks/styles/styles_examples/#12-using-standard-matplotlib-markers","title":"1.2 Using Standard Matplotlib Markers\u00b6","text":"<ul> <li>Instead of using Styles.get_marker_style, we'll use standard matplotlib markers.</li> </ul>"},{"location":"notebooks/styles/styles_examples/#2-using-the-scale-class","title":"2. Using the Scale Class\u00b6","text":"<ul> <li>The Scale class provides methods for scaling data in different ways.</li> </ul>"},{"location":"notebooks/styles/styles_examples/#22-power-scale","title":"2.2 Power Scale\u00b6","text":"<ul> <li>The power_scale method applies a power scale to the data.</li> </ul>"},{"location":"notebooks/styles/styles_examples/#23-custom-scaling-function","title":"2.3 Custom Scaling Function\u00b6","text":"<ul> <li>Instead of using Scale.identity_scale, we'll create our own scaling function</li> </ul>"},{"location":"notebooks/styles/styles_examples/#24-rescale","title":"2.4 Rescale\u00b6","text":"<ul> <li>The rescale method rescales values from one range to another.</li> </ul>"},{"location":"notebooks/styles/styles_examples/#3-using-the-midpointnormalize-class","title":"3. Using the MidpointNormalize Class\u00b6","text":"<ul> <li>The MidpointNormalize class is a normalization that maps a range of values to colors, with a specific midpoint value that maps to a specific color.</li> </ul>"},{"location":"notebooks/styles/styles_examples/#4-combining-different-styles-and-scales","title":"4. Combining Different Styles and Scales\u00b6","text":"<ul> <li>Let's combine different styles and scales in a single visualization.</li> </ul>"},{"location":"notebooks/styles/styles_examples/#summary","title":"Summary\u00b6","text":"<ul> <li>In this notebook, we've explored the Styles, Scale, and MidpointNormalize classes from the Cleopatra package.</li> <li>We've seen how to:</li> </ul> <ol> <li>Use the Styles class to get line styles</li> <li>Use standard matplotlib markers</li> <li>Use the Scale class to apply different scaling methods:<ul> <li>Log scale</li> <li>Power scale</li> <li>Identity scale</li> <li>Rescale</li> </ul> </li> <li>Use the MidpointNormalize class to create color maps with specific midpoints</li> <li>Combine different styles and scales in visualizations</li> </ol> <p>These classes provide powerful tools for customizing and enhancing visualizations.</p>"}]}