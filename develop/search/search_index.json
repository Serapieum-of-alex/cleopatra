{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"md/","title":"Cleopatra - Matplotlib utility package","text":"<p>cleopatra is a Python package providing a fast and flexible way to build visualize data using matplotlib. It provides functionalities to handle 3D arrays and perform various operations on them, such as plotting, animating, and displaying the array. It also provides functionalities for creating statistical plots.</p>"},{"location":"md/#main-features","title":"Main Features","text":"<p>The <code>Array</code> class has the following functionalities:</p> <ul> <li>Initialize an array object with the provided parameters.</li> <li>Plot the array with optional parameters to customize the appearance and display cell values.</li> <li>Animate the array over time with optional parameters to customize the animation speed and display points.</li> <li>Display the array with optional parameters to customize the appearance and display point IDs.</li> </ul> <p>The <code>Statistic</code> module provides a class for creating statistical plots, specifically histograms. The class, <code>Statistic</code>, is designed to handle both 1D (single-dimensional) and 2D (multi-dimensional) data.</p>"},{"location":"md/array-glyph-class/","title":"Array Class","text":"<p>The <code>ArrayGlyph</code> class provides functionality for visualizing and manipulating arrays, including plotting, animating, and saving animations.</p>"},{"location":"md/array-glyph-class/#class-documentation","title":"Class Documentation","text":""},{"location":"md/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph","title":"<code>cleopatra.array_glyph.ArrayGlyph</code>","text":"<p>A class to handle 3D arrays and perform various operations on them.</p> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>class ArrayGlyph:\n    \"\"\"A class to handle 3D arrays and perform various operations on them.\"\"\"\n\n    def __init__(\n        self,\n        array: np.ndarray,\n        exclude_value: List = np.nan,\n        extent: List = None,\n        rgb: List[int] = None,\n        surface_reflectance: int = None,\n        cutoff: List = None,\n        ax: Axes = None,\n        fig: Figure = None,\n        percentile: int = None,\n        **kwargs,\n    ):\n        \"\"\"Array.\n\n        Parameters\n        ----------\n        array: np.ndarray\n            array.\n        exclude_value: numeric, Optional, Default is np.nan.\n            value used to fill cells out of the domain.\n        extent: List, Default is None.\n            [xmin, ymin, xmax, ymax].\n        rgb: List\n            the indices of the red, green, and blue bands in the given array. the `rgb` parameter can be a list of\n            three values, or a list of four values if the alpha band is also included.\n        surface_reflectance: int, Default is 10000.\n            surface reflectance value of the sentinel data.\n        cutoff: List, Default is None.\n            clip the range of pixel values for each band. (take only the pixel values from 0 to the value of the cutoff\n            and scale them back to between 0 and 1.\n        percentile: int\n            The percentile value to be used for scaling.\n        **kwargs:\n            figsize : [tuple], optional\n                    figure size. The default is (8,8).\n\n        the object does not need any parameters to be initialized.\n\n        Examples\n        --------\n        - Create an array and instantiate the `Array` object.\n            ```python\n            &gt;&gt;&gt; import numpy as np\n            &gt;&gt;&gt; arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n            &gt;&gt;&gt; array = ArrayGlyph(arr)\n            &gt;&gt;&gt; fig, ax = array.plot()\n            ```\n\n          ![image](../_images/image-plot.png)\n\n        \"\"\"\n        self._default_options = DEFAULT_OPTIONS.copy()\n\n        for key, val in kwargs.items():\n            if key not in self.default_options.keys():\n                raise ValueError(\n                    f\"The given keyword argument:{key} is not correct, possible parameters are,\"\n                    f\" {DEFAULT_OPTIONS}\"\n                )\n            else:\n                self.default_options[key] = val\n        # first replace the no_data_value by nan\n        # convert the array to float32 to be able to replace the no data value with nan\n        if exclude_value is not np.nan:\n            if len(exclude_value) &gt; 1:\n                mask = np.logical_or(\n                    np.isclose(array, exclude_value[0], rtol=0.001),\n                    np.isclose(array, exclude_value[1], rtol=0.001),\n                )\n            else:\n                mask = np.isclose(array, exclude_value[0], rtol=0.0000001)\n            array = ma.array(array, mask=mask, dtype=array.dtype)\n        else:\n            array = ma.array(array)\n\n        # convert the extent from [xmin, ymin, xmax, ymax] to [xmin, xmax, ymin, ymax] as required by matplotlib.\n        if extent is not None:\n            extent = [extent[0], extent[2], extent[1], extent[3]]\n        self.extent = extent\n\n        if rgb is not None:\n            self.rgb = True\n            # prepare to plot rgb plot only if there are three arrays\n            if array.shape[0] &lt; 3:\n                raise ValueError(\n                    f\"To plot RGB plot the given array should have only 3 arrays, given array have \"\n                    f\"{array.shape[0]}\"\n                )\n            else:\n                array = self.prepare_array(\n                    array,\n                    rgb=rgb,\n                    surface_reflectance=surface_reflectance,\n                    cutoff=cutoff,\n                    percentile=percentile,\n                )\n        else:\n            self.rgb = False\n\n        self._exclude_value = exclude_value\n\n        self._vmax = (\n            np.nanmax(array) if kwargs.get(\"vmax\") is None else kwargs.get(\"vmax\")\n        )\n        self._vmin = (\n            np.nanmin(array) if kwargs.get(\"vmin\") is None else kwargs.get(\"vmin\")\n        )\n\n        self.arr = array\n        # get the tick spacing that has 10 ticks only\n        self.ticks_spacing = (self._vmax - self._vmin) / 10\n        shape = array.shape\n        if len(shape) == 3:\n            no_elem = array[0, :, :].count()\n        else:\n            no_elem = array.count()\n\n        self.no_elem = no_elem\n        if fig is None:\n            self.fig, self.ax = self.create_figure_axes()\n        else:\n            self.fig, self.ax = fig, ax\n\n    def prepare_array(\n        self,\n        array: np.ndarray,\n        rgb: List[int] = None,\n        surface_reflectance: int = None,\n        cutoff: List = None,\n        percentile: int = None,\n    ) -&gt; np.ndarray:\n        \"\"\"Prepare Array.\n\n        Parameters\n        ----------\n        array: np.ndarray\n            array.\n        rgb: List, Default is [3,2,1]\n            the indices of the red, green, and blue bands in the given array.\n        surface_reflectance: int, Default is 10000.\n            surface reflectance value of the sentinel data.\n        cutoff: List, Default is None.\n            clip the range of pixel values for each band. (take only the pixel values from 0 to the value of the cutoff\n            and scale them back to between 0 and 1).\n        percentile: int\n            The percentile value to be used for scaling.\n\n        Returns\n        -------\n        np.ndarray: np.float32\n            the rgb 3d array is converted into 2d array to be plotted using the plt.imshow function.\n            a float32 array normalized between 0 and 1 using the percentile values.\n        \"\"\"\n        # take the rgb arrays and reorder them to have the red-green-blue, if the order is not given, assume the\n        # order as sentinel data. [3, 2, 1]\n        array = array[rgb].transpose(1, 2, 0)\n\n        if percentile is not None:\n            array = self.scale_percentile(array, percentile=percentile)\n        elif surface_reflectance is not None:\n            array = self._prepare_sentinel_rgb(\n                array,\n                rgb=rgb,\n                surface_reflectance=surface_reflectance,\n                cutoff=cutoff,\n            )\n        return array\n\n    def _prepare_sentinel_rgb(\n        self,\n        array: np.ndarray,\n        rgb: List[int] = None,\n        surface_reflectance: int = 10000,\n        cutoff: List = None,\n    ) -&gt; np.ndarray:\n        \"\"\"Prepare for RGB plot.\n\n        Parameters\n        ----------\n        array: np.ndarray\n            array.\n        rgb: List, Default is [3,2,1]\n            the indices of the red, green, and blue bands in the given array.\n        surface_reflectance: int, Default is 10000.\n            surface reflectance value of the sentinel data.\n        cutoff: List, Default is None.\n            clip the range of pixel values for each band. (take only the pixel values from 0 to the value of the cutoff\n            and scale them back to between 0 and 1).\n\n        Returns\n        -------\n        np.ndarray:\n            the rgb 3d array is converted into 2d array to be plotted using the plt.imshow function.\n        \"\"\"\n        array = np.clip(array / surface_reflectance, 0, 1)\n        if cutoff is not None:\n            array[0] = np.clip(rgb[0], 0, cutoff[0]) / cutoff[0]\n            array[1] = np.clip(rgb[1], 0, cutoff[1]) / cutoff[1]\n            array[2] = np.clip(rgb[2], 0, cutoff[2]) / cutoff[2]\n\n        return array\n\n    @staticmethod\n    def scale_percentile(arr: np.ndarray, percentile: int = 1) -&gt; np.ndarray:\n        \"\"\"Scale the array.\n\n        Parameters\n        ----------\n        arr: np.ndarray\n            The array to be scaled.\n        percentile: int\n            The percentile value to be used for scaling.\n\n        Returns\n        -------\n        np.ndarray: float32\n            The scaled array, normalized between 0 and 1. using the percentile values.\n        \"\"\"\n        rows, columns, bands = arr.shape\n        # flatten image.\n        arr = np.reshape(arr, [rows * columns, bands]).astype(np.float32)\n        # lower percentile values (one value for each band).\n        lower_percent = np.percentile(arr, percentile, axis=0)\n        # 98 percentile values.\n        upper_percent = np.percentile(arr, 100 - percentile, axis=0) - lower_percent\n        # normalize the 3 bands using the percentile values for each band.\n        arr = (arr - lower_percent[None, :]) / upper_percent[None, :]\n        arr = np.reshape(arr, [rows, columns, bands])\n        # discard outliers.\n        arr = arr.clip(0, 1)\n\n        return arr\n\n    def __str__(self):\n        \"\"\"String representation of the Array object.\"\"\"\n        message = f\"\"\"\n                    Min: {self.vmin}\n                    Max: {self.vmax}\n                    Exclude values: {self.exclude_value}\n                    RGB: {self.rgb}\n                \"\"\"\n        return message\n\n    @property\n    def vmin(self):\n        \"\"\"min value in the array\"\"\"\n        return self._vmin\n\n    @property\n    def vmax(self):\n        \"\"\"max value in the array\"\"\"\n        return self._vmax\n\n    @property\n    def exclude_value(self):\n        \"\"\"exclude_value\"\"\"\n        return self._exclude_value\n\n    @exclude_value.setter\n    def exclude_value(self, value):\n        self._exclude_value = value\n\n    @property\n    def default_options(self):\n        \"\"\"Default plot options\"\"\"\n        return self._default_options\n\n    @property\n    def anim(self):\n        \"\"\"Animation function\"\"\"\n        if hasattr(self, \"_anim\"):\n            val = self._anim\n        else:\n            raise ValueError(\n                \"Please first use the function animate to create the animation object\"\n            )\n        return val\n\n    def create_figure_axes(self) -&gt; Tuple[Figure, Axes]:\n        \"\"\"Create the figure and the axes.\n\n        Returns\n        -------\n        fig: matplotlib.figure.Figure\n            the created figure.\n        ax: matplotlib.axes.Axes\n            the created axes.\n        \"\"\"\n        fig = plt.figure(figsize=self.default_options[\"figsize\"])\n        ax = fig.add_subplot()\n\n        return fig, ax\n\n    def get_ticks(self) -&gt; np.ndarray:\n        \"\"\"get a list of ticks for the color bar\"\"\"\n        ticks_spacing = self.default_options[\"ticks_spacing\"]\n        vmax = self.default_options[\"vmax\"]\n        vmin = self.default_options[\"vmin\"]\n        remainder = np.round(math.remainder(vmax, ticks_spacing), 3)\n        # np.mod(vmax, ticks_spacing) gives float point error, so we use the round function.\n        if remainder == 0:\n            ticks = np.arange(vmin, vmax + ticks_spacing, ticks_spacing)\n        else:\n            try:\n                ticks = np.arange(vmin, vmax + ticks_spacing, ticks_spacing)\n            except ValueError:\n                raise ValueError(\n                    \"The number of ticks exceeded the max allowed size, possible errors\"\n                    f\" is the value of the NodataValue you entered-{self.exclude_value}\"\n                )\n            ticks = np.append(\n                ticks,\n                [int(vmax / ticks_spacing) * ticks_spacing + ticks_spacing],\n            )\n        return ticks\n\n    def _plot_im_get_cbar_kw(\n        self, ax: Axes, arr: np.ndarray, ticks: np.ndarray\n    ) -&gt; Tuple[AxesImage, Dict[str, str]]:\n        \"\"\"Plot a single image and get color bar keyword arguments.\n\n        Parameters\n        ----------\n        ax: [axes]\n            matplotlib figure axes.\n        arr: [array]\n            numpy array.\n        ticks: [list]\n            color bar ticks.\n\n        Returns\n        -------\n        im: AxesImage\n            image axes.\n        cbar: Dict[str,str]\n            color bar keyword arguments.\n        \"\"\"\n        color_scale = self.default_options[\"color_scale\"]\n        cmap = self.default_options[\"cmap\"]\n        # get the vmin and vmax from the tick instead of the default values.\n        vmin: float = ticks[0]  # self.default_options[\"vmin\"]\n        vmax: float = ticks[-1]  # self.default_options[\"vmax\"]\n\n        if color_scale.lower() == \"linear\":\n            im = ax.matshow(arr, cmap=cmap, vmin=vmin, vmax=vmax, extent=self.extent)\n            cbar_kw = dict(ticks=ticks)\n        elif color_scale.lower() == \"power\":\n            im = ax.matshow(\n                arr,\n                cmap=cmap,\n                norm=colors.PowerNorm(\n                    gamma=self.default_options[\"gamma\"], vmin=vmin, vmax=vmax\n                ),\n                extent=self.extent,\n            )\n            cbar_kw = dict(ticks=ticks)\n        elif color_scale.lower() == \"sym-lognorm\":\n            im = ax.matshow(\n                arr,\n                cmap=cmap,\n                norm=colors.SymLogNorm(\n                    linthresh=self.default_options[\"line_threshold\"],\n                    linscale=self.default_options[\"line_scale\"],\n                    base=np.e,\n                    vmin=vmin,\n                    vmax=vmax,\n                ),\n                extent=self.extent,\n            )\n            formatter = LogFormatter(10, labelOnlyBase=False)\n            cbar_kw = dict(ticks=ticks, format=formatter)\n        elif color_scale.lower() == \"boundary-norm\":\n            if not self.default_options[\"bounds\"]:\n                bounds = ticks\n                cbar_kw = dict(ticks=ticks)\n            else:\n                bounds = self.default_options[\"bounds\"]\n                cbar_kw = dict(ticks=self.default_options[\"bounds\"])\n            norm = colors.BoundaryNorm(boundaries=bounds, ncolors=256)\n            im = ax.matshow(arr, cmap=cmap, norm=norm, extent=self.extent)\n        elif color_scale.lower() == \"midpoint\":\n            arr = arr.filled(np.nan)\n            im = ax.matshow(\n                arr,\n                cmap=cmap,\n                norm=MidpointNormalize(\n                    midpoint=self.default_options[\"midpoint\"],\n                    vmin=vmin,\n                    vmax=vmax,\n                ),\n                extent=self.extent,\n            )\n            cbar_kw = dict(ticks=ticks)\n        else:\n            raise ValueError(\n                f\"Invalid color scale option: {color_scale}. Use 'linear', 'power', 'power-norm',\"\n                \"'sym-lognorm', 'boundary-norm'\"\n            )\n\n        return im, cbar_kw\n\n    @staticmethod\n    def _plot_text(\n        ax: Axes, arr: np.ndarray, indices, default_options_dict: dict\n    ) -&gt; list:\n        \"\"\"plot values as a text in each cell.\n\n        Parameters\n        ----------\n        ax:[matplotlib ax]\n            matplotlib axes\n        indices: [array]\n            array with columns, (row, col)\n        default_options_dict: Dict\n            default options dictionary after updating the options.\n\n        Returns\n        -------\n        list:\n            list of the text object\n        \"\"\"\n        # https://github.com/Serapieum-of-alex/cleopatra/issues/75\n        # add text for the cell values\n        add_text = lambda elem: ax.text(\n            elem[1],\n            elem[0],\n            np.round(arr[elem[0], elem[1]], 2),\n            ha=\"center\",\n            va=\"center\",\n            color=\"w\",\n            fontsize=default_options_dict[\"num_size\"],\n        )\n        return list(map(add_text, indices))\n\n    @staticmethod\n    def _plot_point_values(ax, point_table: np.ndarray, pid_color, pid_size):\n        write_points = lambda x: ax.text(\n            x[2],\n            x[1],\n            x[0],\n            ha=\"center\",\n            va=\"center\",\n            color=pid_color,\n            fontsize=pid_size,\n        )\n        return list(map(write_points, point_table))\n\n    def create_color_bar(self, ax: Axes, im: AxesImage, cbar_kw: dict) -&gt; Colorbar:\n        \"\"\"Create Color bar.\n\n        Parameters\n        ----------\n        ax: Axes\n            matplotlib axes.\n        im: AxesImage\n            Image axes.\n        cbar_kw: dict\n            color bar keyword arguments.\n\n        Returns\n        -------\n        Colorbar:\n            colorbar object.\n        \"\"\"\n        # im or cax is the last image added to the axes\n        # im = ax.images[-1]\n        cbar = ax.figure.colorbar(\n            im,\n            ax=ax,\n            shrink=self.default_options[\"cbar_length\"],\n            orientation=self.default_options[\"cbar_orientation\"],\n            **cbar_kw,\n        )\n        # cbar.ax.set_ylabel(\n        #     self.default_options[\"cbar_label\"],\n        #     rotation=self.default_options[\"cbar_label_rotation\"],\n        #     va=self.default_options[\"cbar_label_location\"],\n        #     fontsize=self.default_options[\"cbar_label_size\"],\n        # )\n        cbar.ax.tick_params(labelsize=10)\n        cbar.set_label(\n            self.default_options[\"cbar_label\"],\n            fontsize=self.default_options[\"cbar_label_size\"],\n            loc=self.default_options[\"cbar_label_location\"],\n        )\n\n        return cbar\n\n    def plot(\n        self,\n        points: np.ndarray = None,\n        point_color: str = \"red\",\n        point_size: Union[int, float] = 100,\n        pid_color=\"blue\",\n        pid_size: Union[int, float] = 10,\n        **kwargs,\n    ) -&gt; Tuple[Figure, Axes]:\n        \"\"\"plot an array.\n\n        Parameters\n        ----------\n        points : [array]\n            3 column array with the first column as the value you want to display for the point, the second is the rows'\n            index of the point in the array, and the third column as the column index in the array.\n            - the second and third column tells the location of the point in the array.\n        point_color: [str]\n            color.\n        point_size: [Any]\n            size of the point.\n        pid_color: [str]\n            the annotation color of the point. Default is blue.\n        pid_size: [Any]\n            size of the point annotation.\n        **kwargs: [dict]\n            title: [str], optional\n                title of the plot. The default is 'Total Discharge'.\n            title_size: [integer], optional, default is 15.\n                title size.\n            cbar_orientation: [string], optional, default is 'vertical'\n                orientation of the color bar horizontal/vertical.\n            cbar_label_rotation: [number], optional, default is -90.\n                rotation of the color bar label.\n            cbar_label_location: str, optional, default is 'bottom'.\n                location of the color bar title 'top', 'bottom', 'center', 'baseline', 'center_baseline'.\n            cbar_length: float, optional\n                ratio to control the height of the color bar. The default is 0.75.\n            ticks_spacing: int, optional\n                Spacing in the color bar ticks. The default is 2.\n            cbar_label_size: integer, optional\n                size of the color bar label. The default is 12.\n            cbar_label: str, optional\n                label of the color bar. The default is 'Discharge m3/s'.\n            color_scale : integer, optional, default is 1.\n                there are 5 options to change the scale of the colors.\n\n                1- `linear`:\n                    linear scale.\n                2- `power`:\n                    for the power scale. Linearly map a given value to the 0-1 range and then apply a power-law\n                    normalization over that range.\n                3- `sym-lognorm`:\n                    the symmetrical logarithmic scale `SymLogNorm` is logarithmic in both the positive and\n                    negative directions from the origin.\n                4- `boundary-norm`:\n                    the BoundaryNorm scale generates a colormap index based on discrete intervals.\n                5- `midpoint`:\n                    the midpoint scale splits the scale into 2 halfs, be the given value.\n            gamma: [float], optional, default is 0.5.\n                value needed for the color_scale `power`.\n            line_threshold: float, optional, default is 0.0001.\n                value needed for the color_scale `sym-lognorm`.\n            line_scale: float, optional, default is 0.001.\n                value needed for the color_scale `sym-lognorm`.\n            bounds: List, default is None,\n                a list of number to be used as a discrete bounds for the color scale `boundary-norm`.\n            midpoint: float, optional, default is 0.\n                value needed for the color_scale `midpoint`.\n            cmap: str, optional, default is 'coolwarm_r'.\n                color style.\n            display_cell_value: bool\n                True if you want to display the values of the cells as a text\n            num_size: integer, optional, default is 8.\n                size of the numbers plotted on top of each cell.\n            background_color_threshold: [float/integer], optional, default is None.\n                threshold value if the value of the cell is greater, the plotted\n                numbers will be black, and if smaller the plotted number will be white\n                if None given the max value/2 is considered.\n\n        Returns\n        -------\n        axes: [figure axes].\n            the axes of the matplotlib figure\n        fig: [matplotlib figure object]\n            the figure object\n\n        Examples\n        --------\n        - Create an array and instantiate the `Array` object.\n            ```python\n            &gt;&gt;&gt; import numpy as np\n            &gt;&gt;&gt; arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n            &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Customized Plot\", title_size=18)\n            &gt;&gt;&gt; fig, ax = array.plot()\n            ```\n        ![image](../_images/array-plot.png)\n\n        - Color bar customization:\n\n            - Create an array and instantiate the `Array` object with custom options.\n                ```python\n                &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Customized color bar\", title_size=18)\n                &gt;&gt;&gt; fig, ax = array.plot(\n                ...     cbar_orientation=\"horizontal\",\n                ...     cbar_label_rotation=-90,\n                ...     cbar_label_location=\"center\",\n                ...     cbar_length=0.7,\n                ...     cbar_label_size=12,\n                ...     cbar_label=\"Discharge m3/s\",\n                ...     ticks_spacing=5,\n                ...     color_scale=\"linear\",\n                ...     cmap=\"coolwarm_r\",\n                ... )\n                ```\n                ![image](../_images/color-bar-customization.png)\n\n                - Color bar customization:\n\n        - Display values for each cell:\n\n            - you can display the values for each cell by using thr parameter `display_cell_value`, and customize how\n                the values are displayed using the parameter `background_color_threshold` and `num_size`.\n                ```python\n                &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Display array values\", title_size=18)\n                &gt;&gt;&gt; fig, ax = array.plot(\n                ...     display_cell_value=True,\n                ...     num_size=12\n                ... )\n                ```\n                ![image](../_images/display-cell-values.png)\n\n        - Plot points at specific locations in the array:\n\n            - you can display points in specific cells in the array and also display a value for each of these points.\n                The point parameter takes an array with the first column as the values to be displayed on top of the\n                points, the second and third columns are the row and column index of the point in the array.\n            - The `point_color` and `point_size` parameters are used to customize the appearance of the points,\n                while the `pid_color` and `pid_size` parameters are used to customize the appearance of the point\n                IDs/text.\n                ```python\n                &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Display Points in top of the array\", title_size=14)\n                &gt;&gt;&gt; points = np.array([[1, 0, 0], [2, 1, 1], [3, 2, 2]])\n                &gt;&gt;&gt; fig, ax = array.plot(\n                ...     points=points,\n                ...     point_color=\"black\",\n                ...     point_size=100,\n                ...     pid_color=\"orange\",\n                ...     pid_size=30,\n                ... )\n                ```\n                ![image](../_images/display-points.png)\n\n        - Color scale customization:\n\n            - Power scale.\n\n                - The default power scale uses a gamma value of 0.5.\n                    ```python\n                    &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Power scale\", title_size=18)\n                    &gt;&gt;&gt; fig, ax = array.plot(\n                    ...     cbar_label_rotation=-90,\n                    ...     cbar_label=\"Discharge m3/s\",\n                    ...     color_scale=\"power\",\n                    ...     cmap=\"coolwarm_r\",\n                    ... )\n                    ```\n                    ![image](../_images/power-scale.png)\n\n                - change the gamma of 0.8.\n                    ```python\n                    &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Power scale: gamma=0.8\", title_size=18)\n                    &gt;&gt;&gt; fig, ax = array.plot(\n                    ...     cbar_label_rotation=-90,\n                    ...     cbar_label=\"Discharge m3/s\",\n                    ...     color_scale=\"power\",\n                    ...     gamma=0.8,\n                    ...     cmap=\"coolwarm_r\",\n                    ... )\n                    ```\n                    ![image](../_images/power-scale-gamma-0.8.png)\n\n                - change the gamma of 0.1.\n                    ```python\n                    &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Power scale: gamma=0.1\", title_size=18)\n                    &gt;&gt;&gt; fig, ax = array.plot(\n                    ...     cbar_label_rotation=-90,\n                    ...     cbar_label=\"Discharge m3/s\",\n                    ...     color_scale=\"power\",\n                    ...     gamma=0.1,\n                    ...     cmap=\"coolwarm_r\",\n                    ... )\n                    ```\n                    ![image](../_images/power-scale-gamma-0.1.png)\n\n            - Logarithmic scale.\n\n                - the logarithmic scale uses to parameters `line_threshold` and `line_scale` with a default\n                value if 0.0001, and 0.001 respectively.\n                    ```python\n                    &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"logarithmic scale\", title_size=18)\n                    &gt;&gt;&gt; fig, ax = array.plot(\n                    ...     cbar_label_rotation=-90,\n                    ...     cbar_label=\"Discharge m3/s\",\n                    ...     color_scale=\"sym-lognorm\",\n                    ...     cmap=\"coolwarm_r\",\n                    ... )\n                    ```\n                    ![image](../_images/log-scale.png)\n\n                - you can change the `line_threshold` and `line_scale` values.\n                    ```python\n                    &gt;&gt;&gt; array = ArrayGlyph(\n                    ...     arr, figsize=(6, 6), title=\"Logarithmic scale: Customized Parameter\", title_size=12\n                    ... )\n                    &gt;&gt;&gt; fig, ax = array.plot(\n                    ...     cbar_label_rotation=-90,\n                    ...     cbar_label=\"Discharge m3/s\",\n                    ...     color_scale=\"sym-lognorm\",\n                    ...     cmap=\"coolwarm_r\",\n                    ...     line_threshold=0.015,\n                    ...     line_scale=0.1,\n                    ... )\n                    ```\n                    ![image](../_images/log-scale-custom-parameters.png)\n\n            - Defined boundary scale.\n                ```python\n                &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Defined boundary scale\", title_size=18)\n                &gt;&gt;&gt; fig, ax = array.plot(\n                ...     cbar_label_rotation=-90,\n                ...     cbar_label=\"Discharge m3/s\",\n                ...     color_scale=\"boundary-norm\",\n                ...     cmap=\"coolwarm_r\",\n                ... )\n                ```\n                ![image](../_images/boundary-scale.png)\n\n                - You can also define the boundaries.\n                    ```python\n                    &gt;&gt;&gt; array = ArrayGlyph(\n                    ...     arr, figsize=(6, 6), title=\"Defined boundary scale: defined bounds\", title_size=18\n                    ... )\n                    &gt;&gt;&gt; bounds = [0, 5, 10]\n                    &gt;&gt;&gt; fig, ax = array.plot(\n                    ...     cbar_label_rotation=-90,\n                    ...     cbar_label=\"Discharge m3/s\",\n                    ...     color_scale=\"boundary-norm\",\n                    ...     bounds=bounds,\n                    ...     cmap=\"coolwarm_r\",\n                    ... )\n                    ```\n                    ![image](../_images/boundary-scale-defined-bounds.png)\n\n            - Midpoint scale.\n                ```python\n                in the midpoint scale you can define a value that splits the scale into half.\n                &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Midpoint scale\", title_size=18)\n                &gt;&gt;&gt; fig, ax = array.plot(\n                ...     cbar_label_rotation=-90,\n                ...     cbar_label=\"Discharge m3/s\",\n                ...     color_scale=\"midpoint\",\n                ...     cmap=\"coolwarm_r\",\n                ...     midpoint=2,\n                ... )\n                ```\n                ![image](../_images/midpoint-scale-costom-parameters.png)\n        \"\"\"\n        for key, val in kwargs.items():\n            if key not in self.default_options.keys():\n                raise ValueError(\n                    f\"The given keyword argument:{key} is not correct, possible parameters are,\"\n                    f\" {DEFAULT_OPTIONS}\"\n                )\n            else:\n                self.default_options[key] = val\n\n        arr = self.arr\n        fig, ax = self.fig, self.ax\n\n        if self.rgb:\n            ax.imshow(arr, extent=self.extent)\n        else:\n            # if user did not input ticks spacing use the calculated one.\n            if \"ticks_spacing\" in kwargs.keys():\n                self.default_options[\"ticks_spacing\"] = kwargs[\"ticks_spacing\"]\n            else:\n                self.default_options[\"ticks_spacing\"] = self.ticks_spacing\n\n            if \"vmin\" in kwargs.keys():\n                self.default_options[\"vmin\"] = kwargs[\"vmin\"]\n            else:\n                self.default_options[\"vmin\"] = self.vmin\n\n            if \"vmax\" in kwargs.keys():\n                self.default_options[\"vmax\"] = kwargs[\"vmax\"]\n            else:\n                self.default_options[\"vmax\"] = self.vmax\n\n            # creating the ticks/bounds\n            ticks = self.get_ticks()\n            im, cbar_kw = self._plot_im_get_cbar_kw(ax, arr, ticks)\n\n            # Create colorbar\n            self.create_color_bar(ax, im, cbar_kw)\n\n        ax.set_title(\n            self.default_options[\"title\"], fontsize=self.default_options[\"title_size\"]\n        )\n\n        if self.extent is None:\n            ax.set_xticklabels([])\n            ax.set_yticklabels([])\n            ax.set_xticks([])\n            ax.set_yticks([])\n\n        optional_display = {}\n        if self.default_options[\"display_cell_value\"]:\n            indices = get_indices2(arr, [np.nan])\n            optional_display[\"cell_text_value\"] = self._plot_text(\n                ax, arr, indices, self.default_options\n            )\n\n        if points is not None:\n            row = points[:, 1]\n            col = points[:, 2]\n            optional_display[\"points_scatter\"] = ax.scatter(\n                col, row, color=point_color, s=point_size\n            )\n            optional_display[\"points_id\"] = self._plot_point_values(\n                ax, points, pid_color, pid_size\n            )\n\n        # # Normalize the threshold to the image color range.\n        # if self.default_options[\"background_color_threshold\"] is not None:\n        #     im.norm(self.default_options[\"background_color_threshold\"])\n        # else:\n        #     im.norm(self.vmax) / 2.0\n        plt.show()\n        return fig, ax\n\n    def animate(\n        self,\n        time: List[Any],\n        points: np.ndarray = None,\n        text_colors=(\"white\", \"black\"),\n        interval=200,\n        text_loc: list[Any, Any] = None,\n        point_color=\"red\",\n        point_size=100,\n        pid_color=\"blue\",\n        pid_size=10,\n        **kwargs,\n    ):\n        \"\"\"AnimateArray.\n\n        plot an animation for 3d arrays\n\n        Parameters\n        ----------\n        time : List[Any]\n            A list containing the date of values for each frame in the animation.\n        points : np.ndarray, optional\n            A 3 column array with the first column as the value you want to display for the point, the second is the\n            rows index of the point in the array, and the third column as the column index in the array.\n            - the second and third column tells the location of the point in the array.\n        point_color : str, optional, default is 'red'.\n            The color of the points.\n        point_size: int, optional, default is 100.\n            The size of the point.\n        pid_color : str, optional, default is blue.\n            The annotation color of the point.\n        pid_size : int, optional, default is 10.\n            The size of the point annotation.\n        text_colors : Tuple[str, str], optional, The default is (\"white\",\"black\").\n            Two colors to be used to plot the values on top of each cell.\n        interval: int, optional, default is 200.\n            number to control the speed of the animation.\n        text_loc: list, optional, default is [0.1,0.2].\n            location of the date text.\n        **kwargs: [dict]\n            figsize: [tuple], optional\n                figure size. The default is (8,8).\n            title: [str], optional\n                title of the plot. The default is 'Total Discharge'.\n            title_size: [integer], optional\n                title size. The default is 15.\n            cbar_orientation: [string], optional\n                orientation of the color bar horizontal/vertical. The default is 'vertical'.\n            cbar_label_rotation: [number], optional\n                rotation of the color bar label. The default is -90.\n            cbar_label_location: str, optional, default is 'bottom'.\n                location of the color bar title 'top', 'bottom', 'center', 'baseline', 'center_baseline'.\n            cbar_length: float, optional\n                ratio to control the height of the color bar. The default is 0.75.\n            ticks_spacing: int, optional\n                Spacing in the color bar ticks. The default is 2.\n            cbar_label_size: integer, optional\n                size of the color bar label. The default is 12.\n            cbar_label: str, optional\n                label of the color bar. The default is 'Discharge m3/s'.\n            color_scale : integer, optional, default is 1.\n                there are 5 options to change the scale of the colors.\n\n                1- `linear`:\n                    linear scale.\n                2- `power`:\n                    for the power scale. Linearly map a given value to the 0-1 range and then apply a power-law\n                    normalization over that range.\n                3- `sym-lognorm`:\n                    the symmetrical logarithmic scale `SymLogNorm` is logarithmic in both the positive and\n                    negative directions from the origin.\n                4- `boundary-norm`:\n                    the BoundaryNorm scale generates a colormap index based on discrete intervals.\n                5- `midpoint`:\n                    the midpoint scale splits the scale into 2 halfs, be the given value.\n            gamma: [float], optional, default is 0.5.\n                value needed for the color_scale `power`.\n            line_threshold: float, optional, default is 0.0001.\n                value needed for the color_scale `sym-lognorm`.\n            line_scale: float, optional, default is 0.001.\n                value needed for the color_scale `sym-lognorm`.\n            bounds: List, default is None,\n                a list of number to be used as a discrete bounds for the color scale `boundary-norm`.\n            midpoint: float, optional, default is 0.\n                value needed for the color_scale `midpoint`.\n            cmap: str, optional, default is 'coolwarm_r'.\n                color style.\n            display_cell_value: bool\n                True if you want to display the values of the cells as a text\n            num_size: integer, optional, default is 8.\n                size of the numbers plotted on top of each cell.\n            background_color_threshold: [float/integer], optional, default is None.\n                threshold value if the value of the cell is greater, the plotted\n                numbers will be black, and if smaller the plotted number will be white\n                if None given the max value/2 is considered.\n\n        Returns\n        -------\n        animation.FuncAnimation.\n\n        Examples\n        --------\n        - First create a 3D array with the first dimension `frame_0 = arr[0, :, :]` as the dimension that the function\n            will loop over as the frame, then create a list of what you want to be displayed with each frame (i.e.,\n            time stamp, counter, ...)\n\n        ```python\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; arr = np.random.randint(1, 10, size=(5, 10, 10))\n        &gt;&gt;&gt; animate_time_list = [1, 2, 3, 4, 5]\n        &gt;&gt;&gt; animated_array = ArrayGlyph(arr, figsize=(8, 8), title=\"Animated 3D array\", title_size=18)\n        &gt;&gt;&gt; anim_obj = animated_array.animate(animate_time_list)\n        ```\n\n        ![image](../_images/animated_array.gif)\n\n        - To save the animation to a file, use the `save_animation` method, and provide the frame per second `fps`\n            parameter.\n\n            ```python\n            &gt;&gt;&gt; animated_array.save_animation(\"animated_array.gif\", fps=2)\n            ```\n\n        \"\"\"\n        if text_loc is None:\n            text_loc = [0.1, 0.2]\n\n        for key, val in kwargs.items():\n            if key not in self.default_options.keys():\n                raise ValueError(\n                    f\"The given keyword argument:{key} is not correct, possible parameters are,\"\n                    f\" {DEFAULT_OPTIONS}\"\n                )\n            else:\n                self.default_options[key] = val\n\n        # if user did not input ticks spacing use the calculated one.\n        if \"ticks_spacing\" in kwargs.keys():\n            self.default_options[\"ticks_spacing\"] = kwargs[\"ticks_spacing\"]\n        else:\n            self.default_options[\"ticks_spacing\"] = self.ticks_spacing\n\n        if \"vmin\" in kwargs.keys():\n            self.default_options[\"vmin\"] = kwargs[\"vmin\"]\n        else:\n            self.default_options[\"vmin\"] = self.vmin\n\n        if \"vmax\" in kwargs.keys():\n            self.default_options[\"vmax\"] = kwargs[\"vmax\"]\n        else:\n            self.default_options[\"vmax\"] = self.vmax\n\n        # if optional_display\n        precision = self.default_options[\"precision\"]\n        array = self.arr\n        fig, ax = self.fig, self.ax\n\n        ticks = self.get_ticks()\n        im, cbar_kw = self._plot_im_get_cbar_kw(ax, array[0, :, :], ticks)\n\n        # Create colorbar\n        cbar = ax.figure.colorbar(\n            im,\n            ax=ax,\n            shrink=self.default_options[\"cbar_length\"],\n            orientation=self.default_options[\"cbar_orientation\"],\n            **cbar_kw,\n        )\n        cbar.ax.set_ylabel(\n            self.default_options[\"cbar_label\"],\n            rotation=self.default_options[\"cbar_label_rotation\"],\n            va=self.default_options[\"cbar_label_location\"],\n            fontsize=self.default_options[\"cbar_label_size\"],\n        )\n        cbar.ax.tick_params(labelsize=10)\n\n        ax.set_title(\n            self.default_options[\"title\"], fontsize=self.default_options[\"title_size\"]\n        )\n        ax.set_xticklabels([])\n        ax.set_yticklabels([])\n\n        ax.set_xticks([])\n        ax.set_yticks([])\n\n        if self.default_options[\"display_cell_value\"]:\n            indices = get_indices2(array[0, :, :], [np.nan])\n            cell_text_value = self._plot_text(\n                ax, array[0, :, :], indices, self.default_options\n            )\n            indices = np.array(indices)\n\n        if points is not None:\n            row = points[:, 1]\n            col = points[:, 2]\n            points_scatter = ax.scatter(col, row, color=point_color, s=point_size)\n            points_id = self._plot_point_values(ax, points, pid_color, pid_size)\n\n        # Normalize the threshold to the image color range.\n        if self.default_options[\"background_color_threshold\"] is not None:\n            background_color_threshold = im.norm(\n                self.default_options[\"background_color_threshold\"]\n            )\n        else:\n            background_color_threshold = im.norm(np.nanmax(array)) / 2.0\n\n        day_text = ax.text(\n            text_loc[0],\n            text_loc[1],\n            \" \",\n            fontsize=self.default_options[\"cbar_label_size\"],\n        )\n\n        def init():\n            \"\"\"initialize the plot with the first array\"\"\"\n            im.set_data(array[0, :, :])\n            day_text.set_text(\"\")\n            output = [im, day_text]\n\n            if points is not None:\n                points_scatter.set_offsets(np.c_[col, row])\n                output.append(points_scatter)\n                update_points = lambda x: points_id[x].set_text(points[x, 0])\n                list(map(update_points, range(len(col))))\n\n                output += points_id\n\n            if self.default_options[\"display_cell_value\"]:\n                vals = array[0, indices[:, 0], indices[:, 1]]\n                update_cell_value = lambda x: cell_text_value[x].set_text(vals[x])\n                list(map(update_cell_value, range(self.no_elem)))\n                output += cell_text_value\n\n            return output\n\n        def animate_a(i):\n            \"\"\"plot for each element in the iterable.\"\"\"\n            im.set_data(array[i, :, :])\n            day_text.set_text(\"Date = \" + str(time[i])[0:10])\n            output = [im, day_text]\n\n            if points is not None:\n                points_scatter.set_offsets(np.c_[col, row])\n                output.append(points_scatter)\n\n                for x in range(len(col)):\n                    points_id[x].set_text(points[x, 0])\n\n                output += points_id\n\n            if self.default_options[\"display_cell_value\"]:\n                vals = array[i, indices[:, 0], indices[:, 1]]\n\n                def update_cell_value(x):\n                    \"\"\"Update cell value\"\"\"\n                    val = round(vals[x], precision)\n                    kw = dict(\n                        color=text_colors[\n                            int(im.norm(vals[x]) &gt; background_color_threshold)\n                        ]\n                    )\n                    cell_text_value[x].update(kw)\n                    cell_text_value[x].set_text(val)\n\n                list(map(update_cell_value, range(self.no_elem)))\n\n                output += cell_text_value\n\n            return output\n\n        plt.tight_layout()\n\n        anim = FuncAnimation(\n            fig,\n            animate_a,\n            init_func=init,\n            frames=np.shape(array)[0],\n            interval=interval,\n            blit=True,\n        )\n        self._anim = anim\n        plt.show()\n        return anim\n\n    def save_animation(self, path: str, fps: int = 2):\n        \"\"\"Save the animation.\n\n            - video format is taken from the given path. available [\"gif\", \"mov\", \"avi\", \"mp4\"].\n\n        Parameters\n        ----------\n        path: [str]\n            path\n        fps: [int]\n            frames per second. Default is 2.\n        \"\"\"\n        video_format = path.split(\".\")[-1]\n        if video_format not in SUPPORTED_VIDEO_FORMAT:\n            raise ValueError(\n                f\"The given extension {video_format} implies a format that is not supported, \"\n                f\"only {SUPPORTED_VIDEO_FORMAT} are supported\"\n            )\n\n        if video_format == \"gif\":\n            writer_gif = animation.PillowWriter(fps=fps)\n            self.anim.save(path, writer=writer_gif)\n        else:\n            try:\n                if video_format == \"avi\" or video_format == \"mov\":\n                    writer_video = animation.FFMpegWriter(fps=fps, bitrate=1800)\n                    self.anim.save(path, writer=writer_video)\n                elif video_format == \"mp4\":\n                    writer_mp4 = animation.FFMpegWriter(fps=fps, bitrate=1800)\n                    self.anim.save(path, writer=writer_mp4)\n            except FileNotFoundError:\n                print(\n                    \"Please visit https://ffmpeg.org/ and download a version of ffmpeg compatible with your operating\"\n                    \"system, for more details please check the method definition\"\n                )\n</code></pre>"},{"location":"md/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.anim","title":"<code>anim</code>  <code>property</code>","text":"<p>Animation function</p>"},{"location":"md/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.default_options","title":"<code>default_options</code>  <code>property</code>","text":"<p>Default plot options</p>"},{"location":"md/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.exclude_value","title":"<code>exclude_value</code>  <code>property</code> <code>writable</code>","text":"<p>exclude_value</p>"},{"location":"md/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.vmax","title":"<code>vmax</code>  <code>property</code>","text":"<p>max value in the array</p>"},{"location":"md/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.vmin","title":"<code>vmin</code>  <code>property</code>","text":"<p>min value in the array</p>"},{"location":"md/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.__init__","title":"<code>__init__(array, exclude_value=np.nan, extent=None, rgb=None, surface_reflectance=None, cutoff=None, ax=None, fig=None, percentile=None, **kwargs)</code>","text":"<p>Array.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>array.</p> required <code>exclude_value</code> <code>List</code> <p>value used to fill cells out of the domain.</p> <code>nan</code> <code>extent</code> <code>List</code> <p>[xmin, ymin, xmax, ymax].</p> <code>None</code> <code>rgb</code> <code>List[int]</code> <p>the indices of the red, green, and blue bands in the given array. the <code>rgb</code> parameter can be a list of three values, or a list of four values if the alpha band is also included.</p> <code>None</code> <code>surface_reflectance</code> <code>int</code> <p>surface reflectance value of the sentinel data.</p> <code>None</code> <code>cutoff</code> <code>List</code> <p>clip the range of pixel values for each band. (take only the pixel values from 0 to the value of the cutoff and scale them back to between 0 and 1.</p> <code>None</code> <code>percentile</code> <code>int</code> <p>The percentile value to be used for scaling.</p> <code>None</code> <code>**kwargs</code> <p>figsize : [tuple], optional         figure size. The default is (8,8).</p> <code>{}</code> <code>the</code> required <p>Examples:</p> <ul> <li>Create an array and instantiate the <code>Array</code> object.     <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n&gt;&gt;&gt; array = ArrayGlyph(arr)\n&gt;&gt;&gt; fig, ax = array.plot()\n</code></pre></li> </ul> <p></p> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>def __init__(\n    self,\n    array: np.ndarray,\n    exclude_value: List = np.nan,\n    extent: List = None,\n    rgb: List[int] = None,\n    surface_reflectance: int = None,\n    cutoff: List = None,\n    ax: Axes = None,\n    fig: Figure = None,\n    percentile: int = None,\n    **kwargs,\n):\n    \"\"\"Array.\n\n    Parameters\n    ----------\n    array: np.ndarray\n        array.\n    exclude_value: numeric, Optional, Default is np.nan.\n        value used to fill cells out of the domain.\n    extent: List, Default is None.\n        [xmin, ymin, xmax, ymax].\n    rgb: List\n        the indices of the red, green, and blue bands in the given array. the `rgb` parameter can be a list of\n        three values, or a list of four values if the alpha band is also included.\n    surface_reflectance: int, Default is 10000.\n        surface reflectance value of the sentinel data.\n    cutoff: List, Default is None.\n        clip the range of pixel values for each band. (take only the pixel values from 0 to the value of the cutoff\n        and scale them back to between 0 and 1.\n    percentile: int\n        The percentile value to be used for scaling.\n    **kwargs:\n        figsize : [tuple], optional\n                figure size. The default is (8,8).\n\n    the object does not need any parameters to be initialized.\n\n    Examples\n    --------\n    - Create an array and instantiate the `Array` object.\n        ```python\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        &gt;&gt;&gt; array = ArrayGlyph(arr)\n        &gt;&gt;&gt; fig, ax = array.plot()\n        ```\n\n      ![image](../_images/image-plot.png)\n\n    \"\"\"\n    self._default_options = DEFAULT_OPTIONS.copy()\n\n    for key, val in kwargs.items():\n        if key not in self.default_options.keys():\n            raise ValueError(\n                f\"The given keyword argument:{key} is not correct, possible parameters are,\"\n                f\" {DEFAULT_OPTIONS}\"\n            )\n        else:\n            self.default_options[key] = val\n    # first replace the no_data_value by nan\n    # convert the array to float32 to be able to replace the no data value with nan\n    if exclude_value is not np.nan:\n        if len(exclude_value) &gt; 1:\n            mask = np.logical_or(\n                np.isclose(array, exclude_value[0], rtol=0.001),\n                np.isclose(array, exclude_value[1], rtol=0.001),\n            )\n        else:\n            mask = np.isclose(array, exclude_value[0], rtol=0.0000001)\n        array = ma.array(array, mask=mask, dtype=array.dtype)\n    else:\n        array = ma.array(array)\n\n    # convert the extent from [xmin, ymin, xmax, ymax] to [xmin, xmax, ymin, ymax] as required by matplotlib.\n    if extent is not None:\n        extent = [extent[0], extent[2], extent[1], extent[3]]\n    self.extent = extent\n\n    if rgb is not None:\n        self.rgb = True\n        # prepare to plot rgb plot only if there are three arrays\n        if array.shape[0] &lt; 3:\n            raise ValueError(\n                f\"To plot RGB plot the given array should have only 3 arrays, given array have \"\n                f\"{array.shape[0]}\"\n            )\n        else:\n            array = self.prepare_array(\n                array,\n                rgb=rgb,\n                surface_reflectance=surface_reflectance,\n                cutoff=cutoff,\n                percentile=percentile,\n            )\n    else:\n        self.rgb = False\n\n    self._exclude_value = exclude_value\n\n    self._vmax = (\n        np.nanmax(array) if kwargs.get(\"vmax\") is None else kwargs.get(\"vmax\")\n    )\n    self._vmin = (\n        np.nanmin(array) if kwargs.get(\"vmin\") is None else kwargs.get(\"vmin\")\n    )\n\n    self.arr = array\n    # get the tick spacing that has 10 ticks only\n    self.ticks_spacing = (self._vmax - self._vmin) / 10\n    shape = array.shape\n    if len(shape) == 3:\n        no_elem = array[0, :, :].count()\n    else:\n        no_elem = array.count()\n\n    self.no_elem = no_elem\n    if fig is None:\n        self.fig, self.ax = self.create_figure_axes()\n    else:\n        self.fig, self.ax = fig, ax\n</code></pre>"},{"location":"md/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.__str__","title":"<code>__str__()</code>","text":"<p>String representation of the Array object.</p> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>def __str__(self):\n    \"\"\"String representation of the Array object.\"\"\"\n    message = f\"\"\"\n                Min: {self.vmin}\n                Max: {self.vmax}\n                Exclude values: {self.exclude_value}\n                RGB: {self.rgb}\n            \"\"\"\n    return message\n</code></pre>"},{"location":"md/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.animate","title":"<code>animate(time, points=None, text_colors=('white', 'black'), interval=200, text_loc=None, point_color='red', point_size=100, pid_color='blue', pid_size=10, **kwargs)</code>","text":"<p>AnimateArray.</p> <p>plot an animation for 3d arrays</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>List[Any]</code> <p>A list containing the date of values for each frame in the animation.</p> required <code>points</code> <code>ndarray</code> <p>A 3 column array with the first column as the value you want to display for the point, the second is the rows index of the point in the array, and the third column as the column index in the array. - the second and third column tells the location of the point in the array.</p> <code>None</code> <code>point_color</code> <code>str</code> <p>The color of the points.</p> <code>is 'red'.</code> <code>point_size</code> <p>The size of the point.</p> <code>100</code> <code>pid_color</code> <code>str</code> <p>The annotation color of the point.</p> <code>is blue.</code> <code>pid_size</code> <code>int</code> <p>The size of the point annotation.</p> <code>is 10.</code> <code>text_colors</code> <code>Tuple[str, str], optional, The default is (\"white\",\"black\").</code> <p>Two colors to be used to plot the values on top of each cell.</p> <code>('white', 'black')</code> <code>interval</code> <p>number to control the speed of the animation.</p> <code>200</code> <code>text_loc</code> <code>list[Any, Any]</code> <p>location of the date text.</p> <code>None</code> <code>**kwargs</code> <p>figsize: [tuple], optional     figure size. The default is (8,8). title: [str], optional     title of the plot. The default is 'Total Discharge'. title_size: [integer], optional     title size. The default is 15. cbar_orientation: [string], optional     orientation of the color bar horizontal/vertical. The default is 'vertical'. cbar_label_rotation: [number], optional     rotation of the color bar label. The default is -90. cbar_label_location: str, optional, default is 'bottom'.     location of the color bar title 'top', 'bottom', 'center', 'baseline', 'center_baseline'. cbar_length: float, optional     ratio to control the height of the color bar. The default is 0.75. ticks_spacing: int, optional     Spacing in the color bar ticks. The default is 2. cbar_label_size: integer, optional     size of the color bar label. The default is 12. cbar_label: str, optional     label of the color bar. The default is 'Discharge m3/s'. color_scale : integer, optional, default is 1.     there are 5 options to change the scale of the colors.</p> <pre><code>1- `linear`:\n    linear scale.\n2- `power`:\n    for the power scale. Linearly map a given value to the 0-1 range and then apply a power-law\n    normalization over that range.\n3- `sym-lognorm`:\n    the symmetrical logarithmic scale `SymLogNorm` is logarithmic in both the positive and\n    negative directions from the origin.\n4- `boundary-norm`:\n    the BoundaryNorm scale generates a colormap index based on discrete intervals.\n5- `midpoint`:\n    the midpoint scale splits the scale into 2 halfs, be the given value.\n</code></pre> <p>gamma: [float], optional, default is 0.5.     value needed for the color_scale <code>power</code>. line_threshold: float, optional, default is 0.0001.     value needed for the color_scale <code>sym-lognorm</code>. line_scale: float, optional, default is 0.001.     value needed for the color_scale <code>sym-lognorm</code>. bounds: List, default is None,     a list of number to be used as a discrete bounds for the color scale <code>boundary-norm</code>. midpoint: float, optional, default is 0.     value needed for the color_scale <code>midpoint</code>. cmap: str, optional, default is 'coolwarm_r'.     color style. display_cell_value: bool     True if you want to display the values of the cells as a text num_size: integer, optional, default is 8.     size of the numbers plotted on top of each cell. background_color_threshold: [float/integer], optional, default is None.     threshold value if the value of the cell is greater, the plotted     numbers will be black, and if smaller the plotted number will be white     if None given the max value/2 is considered.</p> <code>{}</code> <p>Returns:</p> Type Description <code>animation.FuncAnimation.</code> <p>Examples:</p> <ul> <li>First create a 3D array with the first dimension <code>frame_0 = arr[0, :, :]</code> as the dimension that the function     will loop over as the frame, then create a list of what you want to be displayed with each frame (i.e.,     time stamp, counter, ...)</li> </ul> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; arr = np.random.randint(1, 10, size=(5, 10, 10))\n&gt;&gt;&gt; animate_time_list = [1, 2, 3, 4, 5]\n&gt;&gt;&gt; animated_array = ArrayGlyph(arr, figsize=(8, 8), title=\"Animated 3D array\", title_size=18)\n&gt;&gt;&gt; anim_obj = animated_array.animate(animate_time_list)\n</code></pre> <p></p> <ul> <li> <p>To save the animation to a file, use the <code>save_animation</code> method, and provide the frame per second <code>fps</code>     parameter.</p> <pre><code>&gt;&gt;&gt; animated_array.save_animation(\"animated_array.gif\", fps=2)\n</code></pre> </li> </ul> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>def animate(\n    self,\n    time: List[Any],\n    points: np.ndarray = None,\n    text_colors=(\"white\", \"black\"),\n    interval=200,\n    text_loc: list[Any, Any] = None,\n    point_color=\"red\",\n    point_size=100,\n    pid_color=\"blue\",\n    pid_size=10,\n    **kwargs,\n):\n    \"\"\"AnimateArray.\n\n    plot an animation for 3d arrays\n\n    Parameters\n    ----------\n    time : List[Any]\n        A list containing the date of values for each frame in the animation.\n    points : np.ndarray, optional\n        A 3 column array with the first column as the value you want to display for the point, the second is the\n        rows index of the point in the array, and the third column as the column index in the array.\n        - the second and third column tells the location of the point in the array.\n    point_color : str, optional, default is 'red'.\n        The color of the points.\n    point_size: int, optional, default is 100.\n        The size of the point.\n    pid_color : str, optional, default is blue.\n        The annotation color of the point.\n    pid_size : int, optional, default is 10.\n        The size of the point annotation.\n    text_colors : Tuple[str, str], optional, The default is (\"white\",\"black\").\n        Two colors to be used to plot the values on top of each cell.\n    interval: int, optional, default is 200.\n        number to control the speed of the animation.\n    text_loc: list, optional, default is [0.1,0.2].\n        location of the date text.\n    **kwargs: [dict]\n        figsize: [tuple], optional\n            figure size. The default is (8,8).\n        title: [str], optional\n            title of the plot. The default is 'Total Discharge'.\n        title_size: [integer], optional\n            title size. The default is 15.\n        cbar_orientation: [string], optional\n            orientation of the color bar horizontal/vertical. The default is 'vertical'.\n        cbar_label_rotation: [number], optional\n            rotation of the color bar label. The default is -90.\n        cbar_label_location: str, optional, default is 'bottom'.\n            location of the color bar title 'top', 'bottom', 'center', 'baseline', 'center_baseline'.\n        cbar_length: float, optional\n            ratio to control the height of the color bar. The default is 0.75.\n        ticks_spacing: int, optional\n            Spacing in the color bar ticks. The default is 2.\n        cbar_label_size: integer, optional\n            size of the color bar label. The default is 12.\n        cbar_label: str, optional\n            label of the color bar. The default is 'Discharge m3/s'.\n        color_scale : integer, optional, default is 1.\n            there are 5 options to change the scale of the colors.\n\n            1- `linear`:\n                linear scale.\n            2- `power`:\n                for the power scale. Linearly map a given value to the 0-1 range and then apply a power-law\n                normalization over that range.\n            3- `sym-lognorm`:\n                the symmetrical logarithmic scale `SymLogNorm` is logarithmic in both the positive and\n                negative directions from the origin.\n            4- `boundary-norm`:\n                the BoundaryNorm scale generates a colormap index based on discrete intervals.\n            5- `midpoint`:\n                the midpoint scale splits the scale into 2 halfs, be the given value.\n        gamma: [float], optional, default is 0.5.\n            value needed for the color_scale `power`.\n        line_threshold: float, optional, default is 0.0001.\n            value needed for the color_scale `sym-lognorm`.\n        line_scale: float, optional, default is 0.001.\n            value needed for the color_scale `sym-lognorm`.\n        bounds: List, default is None,\n            a list of number to be used as a discrete bounds for the color scale `boundary-norm`.\n        midpoint: float, optional, default is 0.\n            value needed for the color_scale `midpoint`.\n        cmap: str, optional, default is 'coolwarm_r'.\n            color style.\n        display_cell_value: bool\n            True if you want to display the values of the cells as a text\n        num_size: integer, optional, default is 8.\n            size of the numbers plotted on top of each cell.\n        background_color_threshold: [float/integer], optional, default is None.\n            threshold value if the value of the cell is greater, the plotted\n            numbers will be black, and if smaller the plotted number will be white\n            if None given the max value/2 is considered.\n\n    Returns\n    -------\n    animation.FuncAnimation.\n\n    Examples\n    --------\n    - First create a 3D array with the first dimension `frame_0 = arr[0, :, :]` as the dimension that the function\n        will loop over as the frame, then create a list of what you want to be displayed with each frame (i.e.,\n        time stamp, counter, ...)\n\n    ```python\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; arr = np.random.randint(1, 10, size=(5, 10, 10))\n    &gt;&gt;&gt; animate_time_list = [1, 2, 3, 4, 5]\n    &gt;&gt;&gt; animated_array = ArrayGlyph(arr, figsize=(8, 8), title=\"Animated 3D array\", title_size=18)\n    &gt;&gt;&gt; anim_obj = animated_array.animate(animate_time_list)\n    ```\n\n    ![image](../_images/animated_array.gif)\n\n    - To save the animation to a file, use the `save_animation` method, and provide the frame per second `fps`\n        parameter.\n\n        ```python\n        &gt;&gt;&gt; animated_array.save_animation(\"animated_array.gif\", fps=2)\n        ```\n\n    \"\"\"\n    if text_loc is None:\n        text_loc = [0.1, 0.2]\n\n    for key, val in kwargs.items():\n        if key not in self.default_options.keys():\n            raise ValueError(\n                f\"The given keyword argument:{key} is not correct, possible parameters are,\"\n                f\" {DEFAULT_OPTIONS}\"\n            )\n        else:\n            self.default_options[key] = val\n\n    # if user did not input ticks spacing use the calculated one.\n    if \"ticks_spacing\" in kwargs.keys():\n        self.default_options[\"ticks_spacing\"] = kwargs[\"ticks_spacing\"]\n    else:\n        self.default_options[\"ticks_spacing\"] = self.ticks_spacing\n\n    if \"vmin\" in kwargs.keys():\n        self.default_options[\"vmin\"] = kwargs[\"vmin\"]\n    else:\n        self.default_options[\"vmin\"] = self.vmin\n\n    if \"vmax\" in kwargs.keys():\n        self.default_options[\"vmax\"] = kwargs[\"vmax\"]\n    else:\n        self.default_options[\"vmax\"] = self.vmax\n\n    # if optional_display\n    precision = self.default_options[\"precision\"]\n    array = self.arr\n    fig, ax = self.fig, self.ax\n\n    ticks = self.get_ticks()\n    im, cbar_kw = self._plot_im_get_cbar_kw(ax, array[0, :, :], ticks)\n\n    # Create colorbar\n    cbar = ax.figure.colorbar(\n        im,\n        ax=ax,\n        shrink=self.default_options[\"cbar_length\"],\n        orientation=self.default_options[\"cbar_orientation\"],\n        **cbar_kw,\n    )\n    cbar.ax.set_ylabel(\n        self.default_options[\"cbar_label\"],\n        rotation=self.default_options[\"cbar_label_rotation\"],\n        va=self.default_options[\"cbar_label_location\"],\n        fontsize=self.default_options[\"cbar_label_size\"],\n    )\n    cbar.ax.tick_params(labelsize=10)\n\n    ax.set_title(\n        self.default_options[\"title\"], fontsize=self.default_options[\"title_size\"]\n    )\n    ax.set_xticklabels([])\n    ax.set_yticklabels([])\n\n    ax.set_xticks([])\n    ax.set_yticks([])\n\n    if self.default_options[\"display_cell_value\"]:\n        indices = get_indices2(array[0, :, :], [np.nan])\n        cell_text_value = self._plot_text(\n            ax, array[0, :, :], indices, self.default_options\n        )\n        indices = np.array(indices)\n\n    if points is not None:\n        row = points[:, 1]\n        col = points[:, 2]\n        points_scatter = ax.scatter(col, row, color=point_color, s=point_size)\n        points_id = self._plot_point_values(ax, points, pid_color, pid_size)\n\n    # Normalize the threshold to the image color range.\n    if self.default_options[\"background_color_threshold\"] is not None:\n        background_color_threshold = im.norm(\n            self.default_options[\"background_color_threshold\"]\n        )\n    else:\n        background_color_threshold = im.norm(np.nanmax(array)) / 2.0\n\n    day_text = ax.text(\n        text_loc[0],\n        text_loc[1],\n        \" \",\n        fontsize=self.default_options[\"cbar_label_size\"],\n    )\n\n    def init():\n        \"\"\"initialize the plot with the first array\"\"\"\n        im.set_data(array[0, :, :])\n        day_text.set_text(\"\")\n        output = [im, day_text]\n\n        if points is not None:\n            points_scatter.set_offsets(np.c_[col, row])\n            output.append(points_scatter)\n            update_points = lambda x: points_id[x].set_text(points[x, 0])\n            list(map(update_points, range(len(col))))\n\n            output += points_id\n\n        if self.default_options[\"display_cell_value\"]:\n            vals = array[0, indices[:, 0], indices[:, 1]]\n            update_cell_value = lambda x: cell_text_value[x].set_text(vals[x])\n            list(map(update_cell_value, range(self.no_elem)))\n            output += cell_text_value\n\n        return output\n\n    def animate_a(i):\n        \"\"\"plot for each element in the iterable.\"\"\"\n        im.set_data(array[i, :, :])\n        day_text.set_text(\"Date = \" + str(time[i])[0:10])\n        output = [im, day_text]\n\n        if points is not None:\n            points_scatter.set_offsets(np.c_[col, row])\n            output.append(points_scatter)\n\n            for x in range(len(col)):\n                points_id[x].set_text(points[x, 0])\n\n            output += points_id\n\n        if self.default_options[\"display_cell_value\"]:\n            vals = array[i, indices[:, 0], indices[:, 1]]\n\n            def update_cell_value(x):\n                \"\"\"Update cell value\"\"\"\n                val = round(vals[x], precision)\n                kw = dict(\n                    color=text_colors[\n                        int(im.norm(vals[x]) &gt; background_color_threshold)\n                    ]\n                )\n                cell_text_value[x].update(kw)\n                cell_text_value[x].set_text(val)\n\n            list(map(update_cell_value, range(self.no_elem)))\n\n            output += cell_text_value\n\n        return output\n\n    plt.tight_layout()\n\n    anim = FuncAnimation(\n        fig,\n        animate_a,\n        init_func=init,\n        frames=np.shape(array)[0],\n        interval=interval,\n        blit=True,\n    )\n    self._anim = anim\n    plt.show()\n    return anim\n</code></pre>"},{"location":"md/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.create_color_bar","title":"<code>create_color_bar(ax, im, cbar_kw)</code>","text":"<p>Create Color bar.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>matplotlib axes.</p> required <code>im</code> <code>AxesImage</code> <p>Image axes.</p> required <code>cbar_kw</code> <code>dict</code> <p>color bar keyword arguments.</p> required <p>Returns:</p> Name Type Description <code>Colorbar</code> <code>Colorbar</code> <p>colorbar object.</p> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>def create_color_bar(self, ax: Axes, im: AxesImage, cbar_kw: dict) -&gt; Colorbar:\n    \"\"\"Create Color bar.\n\n    Parameters\n    ----------\n    ax: Axes\n        matplotlib axes.\n    im: AxesImage\n        Image axes.\n    cbar_kw: dict\n        color bar keyword arguments.\n\n    Returns\n    -------\n    Colorbar:\n        colorbar object.\n    \"\"\"\n    # im or cax is the last image added to the axes\n    # im = ax.images[-1]\n    cbar = ax.figure.colorbar(\n        im,\n        ax=ax,\n        shrink=self.default_options[\"cbar_length\"],\n        orientation=self.default_options[\"cbar_orientation\"],\n        **cbar_kw,\n    )\n    # cbar.ax.set_ylabel(\n    #     self.default_options[\"cbar_label\"],\n    #     rotation=self.default_options[\"cbar_label_rotation\"],\n    #     va=self.default_options[\"cbar_label_location\"],\n    #     fontsize=self.default_options[\"cbar_label_size\"],\n    # )\n    cbar.ax.tick_params(labelsize=10)\n    cbar.set_label(\n        self.default_options[\"cbar_label\"],\n        fontsize=self.default_options[\"cbar_label_size\"],\n        loc=self.default_options[\"cbar_label_location\"],\n    )\n\n    return cbar\n</code></pre>"},{"location":"md/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.create_figure_axes","title":"<code>create_figure_axes()</code>","text":"<p>Create the figure and the axes.</p> <p>Returns:</p> Name Type Description <code>fig</code> <code>Figure</code> <p>the created figure.</p> <code>ax</code> <code>Axes</code> <p>the created axes.</p> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>def create_figure_axes(self) -&gt; Tuple[Figure, Axes]:\n    \"\"\"Create the figure and the axes.\n\n    Returns\n    -------\n    fig: matplotlib.figure.Figure\n        the created figure.\n    ax: matplotlib.axes.Axes\n        the created axes.\n    \"\"\"\n    fig = plt.figure(figsize=self.default_options[\"figsize\"])\n    ax = fig.add_subplot()\n\n    return fig, ax\n</code></pre>"},{"location":"md/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.get_ticks","title":"<code>get_ticks()</code>","text":"<p>get a list of ticks for the color bar</p> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>def get_ticks(self) -&gt; np.ndarray:\n    \"\"\"get a list of ticks for the color bar\"\"\"\n    ticks_spacing = self.default_options[\"ticks_spacing\"]\n    vmax = self.default_options[\"vmax\"]\n    vmin = self.default_options[\"vmin\"]\n    remainder = np.round(math.remainder(vmax, ticks_spacing), 3)\n    # np.mod(vmax, ticks_spacing) gives float point error, so we use the round function.\n    if remainder == 0:\n        ticks = np.arange(vmin, vmax + ticks_spacing, ticks_spacing)\n    else:\n        try:\n            ticks = np.arange(vmin, vmax + ticks_spacing, ticks_spacing)\n        except ValueError:\n            raise ValueError(\n                \"The number of ticks exceeded the max allowed size, possible errors\"\n                f\" is the value of the NodataValue you entered-{self.exclude_value}\"\n            )\n        ticks = np.append(\n            ticks,\n            [int(vmax / ticks_spacing) * ticks_spacing + ticks_spacing],\n        )\n    return ticks\n</code></pre>"},{"location":"md/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.plot","title":"<code>plot(points=None, point_color='red', point_size=100, pid_color='blue', pid_size=10, **kwargs)</code>","text":"<p>plot an array.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>[array]</code> <p>3 column array with the first column as the value you want to display for the point, the second is the rows' index of the point in the array, and the third column as the column index in the array. - the second and third column tells the location of the point in the array.</p> <code>None</code> <code>point_color</code> <code>str</code> <p>color.</p> <code>'red'</code> <code>point_size</code> <code>Union[int, float]</code> <p>size of the point.</p> <code>100</code> <code>pid_color</code> <p>the annotation color of the point. Default is blue.</p> <code>'blue'</code> <code>pid_size</code> <code>Union[int, float]</code> <p>size of the point annotation.</p> <code>10</code> <code>**kwargs</code> <p>title: [str], optional     title of the plot. The default is 'Total Discharge'. title_size: [integer], optional, default is 15.     title size. cbar_orientation: [string], optional, default is 'vertical'     orientation of the color bar horizontal/vertical. cbar_label_rotation: [number], optional, default is -90.     rotation of the color bar label. cbar_label_location: str, optional, default is 'bottom'.     location of the color bar title 'top', 'bottom', 'center', 'baseline', 'center_baseline'. cbar_length: float, optional     ratio to control the height of the color bar. The default is 0.75. ticks_spacing: int, optional     Spacing in the color bar ticks. The default is 2. cbar_label_size: integer, optional     size of the color bar label. The default is 12. cbar_label: str, optional     label of the color bar. The default is 'Discharge m3/s'. color_scale : integer, optional, default is 1.     there are 5 options to change the scale of the colors.</p> <pre><code>1- `linear`:\n    linear scale.\n2- `power`:\n    for the power scale. Linearly map a given value to the 0-1 range and then apply a power-law\n    normalization over that range.\n3- `sym-lognorm`:\n    the symmetrical logarithmic scale `SymLogNorm` is logarithmic in both the positive and\n    negative directions from the origin.\n4- `boundary-norm`:\n    the BoundaryNorm scale generates a colormap index based on discrete intervals.\n5- `midpoint`:\n    the midpoint scale splits the scale into 2 halfs, be the given value.\n</code></pre> <p>gamma: [float], optional, default is 0.5.     value needed for the color_scale <code>power</code>. line_threshold: float, optional, default is 0.0001.     value needed for the color_scale <code>sym-lognorm</code>. line_scale: float, optional, default is 0.001.     value needed for the color_scale <code>sym-lognorm</code>. bounds: List, default is None,     a list of number to be used as a discrete bounds for the color scale <code>boundary-norm</code>. midpoint: float, optional, default is 0.     value needed for the color_scale <code>midpoint</code>. cmap: str, optional, default is 'coolwarm_r'.     color style. display_cell_value: bool     True if you want to display the values of the cells as a text num_size: integer, optional, default is 8.     size of the numbers plotted on top of each cell. background_color_threshold: [float/integer], optional, default is None.     threshold value if the value of the cell is greater, the plotted     numbers will be black, and if smaller the plotted number will be white     if None given the max value/2 is considered.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>axes</code> <code>[figure axes].</code> <p>the axes of the matplotlib figure</p> <code>fig</code> <code>[matplotlib figure object]</code> <p>the figure object</p> <p>Examples:</p> <ul> <li> <p>Create an array and instantiate the <code>Array</code> object.     <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n&gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Customized Plot\", title_size=18)\n&gt;&gt;&gt; fig, ax = array.plot()\n</code></pre> </p> </li> <li> <p>Color bar customization:</p> <ul> <li> <p>Create an array and instantiate the <code>Array</code> object with custom options.     <pre><code>&gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Customized color bar\", title_size=18)\n&gt;&gt;&gt; fig, ax = array.plot(\n...     cbar_orientation=\"horizontal\",\n...     cbar_label_rotation=-90,\n...     cbar_label_location=\"center\",\n...     cbar_length=0.7,\n...     cbar_label_size=12,\n...     cbar_label=\"Discharge m3/s\",\n...     ticks_spacing=5,\n...     color_scale=\"linear\",\n...     cmap=\"coolwarm_r\",\n... )\n</code></pre> </p> <ul> <li>Color bar customization:</li> </ul> </li> </ul> </li> <li> <p>Display values for each cell:</p> <ul> <li>you can display the values for each cell by using thr parameter <code>display_cell_value</code>, and customize how     the values are displayed using the parameter <code>background_color_threshold</code> and <code>num_size</code>.     <pre><code>&gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Display array values\", title_size=18)\n&gt;&gt;&gt; fig, ax = array.plot(\n...     display_cell_value=True,\n...     num_size=12\n... )\n</code></pre> </li> </ul> </li> <li> <p>Plot points at specific locations in the array:</p> <ul> <li>you can display points in specific cells in the array and also display a value for each of these points.     The point parameter takes an array with the first column as the values to be displayed on top of the     points, the second and third columns are the row and column index of the point in the array.</li> <li>The <code>point_color</code> and <code>point_size</code> parameters are used to customize the appearance of the points,     while the <code>pid_color</code> and <code>pid_size</code> parameters are used to customize the appearance of the point     IDs/text.     <pre><code>&gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Display Points in top of the array\", title_size=14)\n&gt;&gt;&gt; points = np.array([[1, 0, 0], [2, 1, 1], [3, 2, 2]])\n&gt;&gt;&gt; fig, ax = array.plot(\n...     points=points,\n...     point_color=\"black\",\n...     point_size=100,\n...     pid_color=\"orange\",\n...     pid_size=30,\n... )\n</code></pre> </li> </ul> </li> <li> <p>Color scale customization:</p> <ul> <li> <p>Power scale.</p> <ul> <li> <p>The default power scale uses a gamma value of 0.5.     <pre><code>&gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Power scale\", title_size=18)\n&gt;&gt;&gt; fig, ax = array.plot(\n...     cbar_label_rotation=-90,\n...     cbar_label=\"Discharge m3/s\",\n...     color_scale=\"power\",\n...     cmap=\"coolwarm_r\",\n... )\n</code></pre> </p> </li> <li> <p>change the gamma of 0.8.     <pre><code>&gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Power scale: gamma=0.8\", title_size=18)\n&gt;&gt;&gt; fig, ax = array.plot(\n...     cbar_label_rotation=-90,\n...     cbar_label=\"Discharge m3/s\",\n...     color_scale=\"power\",\n...     gamma=0.8,\n...     cmap=\"coolwarm_r\",\n... )\n</code></pre> </p> </li> <li> <p>change the gamma of 0.1.     <pre><code>&gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Power scale: gamma=0.1\", title_size=18)\n&gt;&gt;&gt; fig, ax = array.plot(\n...     cbar_label_rotation=-90,\n...     cbar_label=\"Discharge m3/s\",\n...     color_scale=\"power\",\n...     gamma=0.1,\n...     cmap=\"coolwarm_r\",\n... )\n</code></pre> </p> </li> </ul> </li> <li> <p>Logarithmic scale.</p> <ul> <li> <p>the logarithmic scale uses to parameters <code>line_threshold</code> and <code>line_scale</code> with a default value if 0.0001, and 0.001 respectively.     <pre><code>&gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"logarithmic scale\", title_size=18)\n&gt;&gt;&gt; fig, ax = array.plot(\n...     cbar_label_rotation=-90,\n...     cbar_label=\"Discharge m3/s\",\n...     color_scale=\"sym-lognorm\",\n...     cmap=\"coolwarm_r\",\n... )\n</code></pre> </p> </li> <li> <p>you can change the <code>line_threshold</code> and <code>line_scale</code> values.     <pre><code>&gt;&gt;&gt; array = ArrayGlyph(\n...     arr, figsize=(6, 6), title=\"Logarithmic scale: Customized Parameter\", title_size=12\n... )\n&gt;&gt;&gt; fig, ax = array.plot(\n...     cbar_label_rotation=-90,\n...     cbar_label=\"Discharge m3/s\",\n...     color_scale=\"sym-lognorm\",\n...     cmap=\"coolwarm_r\",\n...     line_threshold=0.015,\n...     line_scale=0.1,\n... )\n</code></pre> </p> </li> </ul> </li> <li> <p>Defined boundary scale.     <pre><code>&gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Defined boundary scale\", title_size=18)\n&gt;&gt;&gt; fig, ax = array.plot(\n...     cbar_label_rotation=-90,\n...     cbar_label=\"Discharge m3/s\",\n...     color_scale=\"boundary-norm\",\n...     cmap=\"coolwarm_r\",\n... )\n</code></pre> </p> <ul> <li>You can also define the boundaries.     <pre><code>&gt;&gt;&gt; array = ArrayGlyph(\n...     arr, figsize=(6, 6), title=\"Defined boundary scale: defined bounds\", title_size=18\n... )\n&gt;&gt;&gt; bounds = [0, 5, 10]\n&gt;&gt;&gt; fig, ax = array.plot(\n...     cbar_label_rotation=-90,\n...     cbar_label=\"Discharge m3/s\",\n...     color_scale=\"boundary-norm\",\n...     bounds=bounds,\n...     cmap=\"coolwarm_r\",\n... )\n</code></pre> </li> </ul> </li> <li> <p>Midpoint scale.     <pre><code>in the midpoint scale you can define a value that splits the scale into half.\n&gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Midpoint scale\", title_size=18)\n&gt;&gt;&gt; fig, ax = array.plot(\n...     cbar_label_rotation=-90,\n...     cbar_label=\"Discharge m3/s\",\n...     color_scale=\"midpoint\",\n...     cmap=\"coolwarm_r\",\n...     midpoint=2,\n... )\n</code></pre> </p> </li> </ul> </li> </ul> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>def plot(\n    self,\n    points: np.ndarray = None,\n    point_color: str = \"red\",\n    point_size: Union[int, float] = 100,\n    pid_color=\"blue\",\n    pid_size: Union[int, float] = 10,\n    **kwargs,\n) -&gt; Tuple[Figure, Axes]:\n    \"\"\"plot an array.\n\n    Parameters\n    ----------\n    points : [array]\n        3 column array with the first column as the value you want to display for the point, the second is the rows'\n        index of the point in the array, and the third column as the column index in the array.\n        - the second and third column tells the location of the point in the array.\n    point_color: [str]\n        color.\n    point_size: [Any]\n        size of the point.\n    pid_color: [str]\n        the annotation color of the point. Default is blue.\n    pid_size: [Any]\n        size of the point annotation.\n    **kwargs: [dict]\n        title: [str], optional\n            title of the plot. The default is 'Total Discharge'.\n        title_size: [integer], optional, default is 15.\n            title size.\n        cbar_orientation: [string], optional, default is 'vertical'\n            orientation of the color bar horizontal/vertical.\n        cbar_label_rotation: [number], optional, default is -90.\n            rotation of the color bar label.\n        cbar_label_location: str, optional, default is 'bottom'.\n            location of the color bar title 'top', 'bottom', 'center', 'baseline', 'center_baseline'.\n        cbar_length: float, optional\n            ratio to control the height of the color bar. The default is 0.75.\n        ticks_spacing: int, optional\n            Spacing in the color bar ticks. The default is 2.\n        cbar_label_size: integer, optional\n            size of the color bar label. The default is 12.\n        cbar_label: str, optional\n            label of the color bar. The default is 'Discharge m3/s'.\n        color_scale : integer, optional, default is 1.\n            there are 5 options to change the scale of the colors.\n\n            1- `linear`:\n                linear scale.\n            2- `power`:\n                for the power scale. Linearly map a given value to the 0-1 range and then apply a power-law\n                normalization over that range.\n            3- `sym-lognorm`:\n                the symmetrical logarithmic scale `SymLogNorm` is logarithmic in both the positive and\n                negative directions from the origin.\n            4- `boundary-norm`:\n                the BoundaryNorm scale generates a colormap index based on discrete intervals.\n            5- `midpoint`:\n                the midpoint scale splits the scale into 2 halfs, be the given value.\n        gamma: [float], optional, default is 0.5.\n            value needed for the color_scale `power`.\n        line_threshold: float, optional, default is 0.0001.\n            value needed for the color_scale `sym-lognorm`.\n        line_scale: float, optional, default is 0.001.\n            value needed for the color_scale `sym-lognorm`.\n        bounds: List, default is None,\n            a list of number to be used as a discrete bounds for the color scale `boundary-norm`.\n        midpoint: float, optional, default is 0.\n            value needed for the color_scale `midpoint`.\n        cmap: str, optional, default is 'coolwarm_r'.\n            color style.\n        display_cell_value: bool\n            True if you want to display the values of the cells as a text\n        num_size: integer, optional, default is 8.\n            size of the numbers plotted on top of each cell.\n        background_color_threshold: [float/integer], optional, default is None.\n            threshold value if the value of the cell is greater, the plotted\n            numbers will be black, and if smaller the plotted number will be white\n            if None given the max value/2 is considered.\n\n    Returns\n    -------\n    axes: [figure axes].\n        the axes of the matplotlib figure\n    fig: [matplotlib figure object]\n        the figure object\n\n    Examples\n    --------\n    - Create an array and instantiate the `Array` object.\n        ```python\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Customized Plot\", title_size=18)\n        &gt;&gt;&gt; fig, ax = array.plot()\n        ```\n    ![image](../_images/array-plot.png)\n\n    - Color bar customization:\n\n        - Create an array and instantiate the `Array` object with custom options.\n            ```python\n            &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Customized color bar\", title_size=18)\n            &gt;&gt;&gt; fig, ax = array.plot(\n            ...     cbar_orientation=\"horizontal\",\n            ...     cbar_label_rotation=-90,\n            ...     cbar_label_location=\"center\",\n            ...     cbar_length=0.7,\n            ...     cbar_label_size=12,\n            ...     cbar_label=\"Discharge m3/s\",\n            ...     ticks_spacing=5,\n            ...     color_scale=\"linear\",\n            ...     cmap=\"coolwarm_r\",\n            ... )\n            ```\n            ![image](../_images/color-bar-customization.png)\n\n            - Color bar customization:\n\n    - Display values for each cell:\n\n        - you can display the values for each cell by using thr parameter `display_cell_value`, and customize how\n            the values are displayed using the parameter `background_color_threshold` and `num_size`.\n            ```python\n            &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Display array values\", title_size=18)\n            &gt;&gt;&gt; fig, ax = array.plot(\n            ...     display_cell_value=True,\n            ...     num_size=12\n            ... )\n            ```\n            ![image](../_images/display-cell-values.png)\n\n    - Plot points at specific locations in the array:\n\n        - you can display points in specific cells in the array and also display a value for each of these points.\n            The point parameter takes an array with the first column as the values to be displayed on top of the\n            points, the second and third columns are the row and column index of the point in the array.\n        - The `point_color` and `point_size` parameters are used to customize the appearance of the points,\n            while the `pid_color` and `pid_size` parameters are used to customize the appearance of the point\n            IDs/text.\n            ```python\n            &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Display Points in top of the array\", title_size=14)\n            &gt;&gt;&gt; points = np.array([[1, 0, 0], [2, 1, 1], [3, 2, 2]])\n            &gt;&gt;&gt; fig, ax = array.plot(\n            ...     points=points,\n            ...     point_color=\"black\",\n            ...     point_size=100,\n            ...     pid_color=\"orange\",\n            ...     pid_size=30,\n            ... )\n            ```\n            ![image](../_images/display-points.png)\n\n    - Color scale customization:\n\n        - Power scale.\n\n            - The default power scale uses a gamma value of 0.5.\n                ```python\n                &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Power scale\", title_size=18)\n                &gt;&gt;&gt; fig, ax = array.plot(\n                ...     cbar_label_rotation=-90,\n                ...     cbar_label=\"Discharge m3/s\",\n                ...     color_scale=\"power\",\n                ...     cmap=\"coolwarm_r\",\n                ... )\n                ```\n                ![image](../_images/power-scale.png)\n\n            - change the gamma of 0.8.\n                ```python\n                &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Power scale: gamma=0.8\", title_size=18)\n                &gt;&gt;&gt; fig, ax = array.plot(\n                ...     cbar_label_rotation=-90,\n                ...     cbar_label=\"Discharge m3/s\",\n                ...     color_scale=\"power\",\n                ...     gamma=0.8,\n                ...     cmap=\"coolwarm_r\",\n                ... )\n                ```\n                ![image](../_images/power-scale-gamma-0.8.png)\n\n            - change the gamma of 0.1.\n                ```python\n                &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Power scale: gamma=0.1\", title_size=18)\n                &gt;&gt;&gt; fig, ax = array.plot(\n                ...     cbar_label_rotation=-90,\n                ...     cbar_label=\"Discharge m3/s\",\n                ...     color_scale=\"power\",\n                ...     gamma=0.1,\n                ...     cmap=\"coolwarm_r\",\n                ... )\n                ```\n                ![image](../_images/power-scale-gamma-0.1.png)\n\n        - Logarithmic scale.\n\n            - the logarithmic scale uses to parameters `line_threshold` and `line_scale` with a default\n            value if 0.0001, and 0.001 respectively.\n                ```python\n                &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"logarithmic scale\", title_size=18)\n                &gt;&gt;&gt; fig, ax = array.plot(\n                ...     cbar_label_rotation=-90,\n                ...     cbar_label=\"Discharge m3/s\",\n                ...     color_scale=\"sym-lognorm\",\n                ...     cmap=\"coolwarm_r\",\n                ... )\n                ```\n                ![image](../_images/log-scale.png)\n\n            - you can change the `line_threshold` and `line_scale` values.\n                ```python\n                &gt;&gt;&gt; array = ArrayGlyph(\n                ...     arr, figsize=(6, 6), title=\"Logarithmic scale: Customized Parameter\", title_size=12\n                ... )\n                &gt;&gt;&gt; fig, ax = array.plot(\n                ...     cbar_label_rotation=-90,\n                ...     cbar_label=\"Discharge m3/s\",\n                ...     color_scale=\"sym-lognorm\",\n                ...     cmap=\"coolwarm_r\",\n                ...     line_threshold=0.015,\n                ...     line_scale=0.1,\n                ... )\n                ```\n                ![image](../_images/log-scale-custom-parameters.png)\n\n        - Defined boundary scale.\n            ```python\n            &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Defined boundary scale\", title_size=18)\n            &gt;&gt;&gt; fig, ax = array.plot(\n            ...     cbar_label_rotation=-90,\n            ...     cbar_label=\"Discharge m3/s\",\n            ...     color_scale=\"boundary-norm\",\n            ...     cmap=\"coolwarm_r\",\n            ... )\n            ```\n            ![image](../_images/boundary-scale.png)\n\n            - You can also define the boundaries.\n                ```python\n                &gt;&gt;&gt; array = ArrayGlyph(\n                ...     arr, figsize=(6, 6), title=\"Defined boundary scale: defined bounds\", title_size=18\n                ... )\n                &gt;&gt;&gt; bounds = [0, 5, 10]\n                &gt;&gt;&gt; fig, ax = array.plot(\n                ...     cbar_label_rotation=-90,\n                ...     cbar_label=\"Discharge m3/s\",\n                ...     color_scale=\"boundary-norm\",\n                ...     bounds=bounds,\n                ...     cmap=\"coolwarm_r\",\n                ... )\n                ```\n                ![image](../_images/boundary-scale-defined-bounds.png)\n\n        - Midpoint scale.\n            ```python\n            in the midpoint scale you can define a value that splits the scale into half.\n            &gt;&gt;&gt; array = ArrayGlyph(arr, figsize=(6, 6), title=\"Midpoint scale\", title_size=18)\n            &gt;&gt;&gt; fig, ax = array.plot(\n            ...     cbar_label_rotation=-90,\n            ...     cbar_label=\"Discharge m3/s\",\n            ...     color_scale=\"midpoint\",\n            ...     cmap=\"coolwarm_r\",\n            ...     midpoint=2,\n            ... )\n            ```\n            ![image](../_images/midpoint-scale-costom-parameters.png)\n    \"\"\"\n    for key, val in kwargs.items():\n        if key not in self.default_options.keys():\n            raise ValueError(\n                f\"The given keyword argument:{key} is not correct, possible parameters are,\"\n                f\" {DEFAULT_OPTIONS}\"\n            )\n        else:\n            self.default_options[key] = val\n\n    arr = self.arr\n    fig, ax = self.fig, self.ax\n\n    if self.rgb:\n        ax.imshow(arr, extent=self.extent)\n    else:\n        # if user did not input ticks spacing use the calculated one.\n        if \"ticks_spacing\" in kwargs.keys():\n            self.default_options[\"ticks_spacing\"] = kwargs[\"ticks_spacing\"]\n        else:\n            self.default_options[\"ticks_spacing\"] = self.ticks_spacing\n\n        if \"vmin\" in kwargs.keys():\n            self.default_options[\"vmin\"] = kwargs[\"vmin\"]\n        else:\n            self.default_options[\"vmin\"] = self.vmin\n\n        if \"vmax\" in kwargs.keys():\n            self.default_options[\"vmax\"] = kwargs[\"vmax\"]\n        else:\n            self.default_options[\"vmax\"] = self.vmax\n\n        # creating the ticks/bounds\n        ticks = self.get_ticks()\n        im, cbar_kw = self._plot_im_get_cbar_kw(ax, arr, ticks)\n\n        # Create colorbar\n        self.create_color_bar(ax, im, cbar_kw)\n\n    ax.set_title(\n        self.default_options[\"title\"], fontsize=self.default_options[\"title_size\"]\n    )\n\n    if self.extent is None:\n        ax.set_xticklabels([])\n        ax.set_yticklabels([])\n        ax.set_xticks([])\n        ax.set_yticks([])\n\n    optional_display = {}\n    if self.default_options[\"display_cell_value\"]:\n        indices = get_indices2(arr, [np.nan])\n        optional_display[\"cell_text_value\"] = self._plot_text(\n            ax, arr, indices, self.default_options\n        )\n\n    if points is not None:\n        row = points[:, 1]\n        col = points[:, 2]\n        optional_display[\"points_scatter\"] = ax.scatter(\n            col, row, color=point_color, s=point_size\n        )\n        optional_display[\"points_id\"] = self._plot_point_values(\n            ax, points, pid_color, pid_size\n        )\n\n    # # Normalize the threshold to the image color range.\n    # if self.default_options[\"background_color_threshold\"] is not None:\n    #     im.norm(self.default_options[\"background_color_threshold\"])\n    # else:\n    #     im.norm(self.vmax) / 2.0\n    plt.show()\n    return fig, ax\n</code></pre>"},{"location":"md/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.prepare_array","title":"<code>prepare_array(array, rgb=None, surface_reflectance=None, cutoff=None, percentile=None)</code>","text":"<p>Prepare Array.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>array.</p> required <code>rgb</code> <code>List[int]</code> <p>the indices of the red, green, and blue bands in the given array.</p> <code>None</code> <code>surface_reflectance</code> <code>int</code> <p>surface reflectance value of the sentinel data.</p> <code>None</code> <code>cutoff</code> <code>List</code> <p>clip the range of pixel values for each band. (take only the pixel values from 0 to the value of the cutoff and scale them back to between 0 and 1).</p> <code>None</code> <code>percentile</code> <code>int</code> <p>The percentile value to be used for scaling.</p> <code>None</code> <p>Returns:</p> Type Description <code>np.ndarray: np.float32</code> <p>the rgb 3d array is converted into 2d array to be plotted using the plt.imshow function. a float32 array normalized between 0 and 1 using the percentile values.</p> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>def prepare_array(\n    self,\n    array: np.ndarray,\n    rgb: List[int] = None,\n    surface_reflectance: int = None,\n    cutoff: List = None,\n    percentile: int = None,\n) -&gt; np.ndarray:\n    \"\"\"Prepare Array.\n\n    Parameters\n    ----------\n    array: np.ndarray\n        array.\n    rgb: List, Default is [3,2,1]\n        the indices of the red, green, and blue bands in the given array.\n    surface_reflectance: int, Default is 10000.\n        surface reflectance value of the sentinel data.\n    cutoff: List, Default is None.\n        clip the range of pixel values for each band. (take only the pixel values from 0 to the value of the cutoff\n        and scale them back to between 0 and 1).\n    percentile: int\n        The percentile value to be used for scaling.\n\n    Returns\n    -------\n    np.ndarray: np.float32\n        the rgb 3d array is converted into 2d array to be plotted using the plt.imshow function.\n        a float32 array normalized between 0 and 1 using the percentile values.\n    \"\"\"\n    # take the rgb arrays and reorder them to have the red-green-blue, if the order is not given, assume the\n    # order as sentinel data. [3, 2, 1]\n    array = array[rgb].transpose(1, 2, 0)\n\n    if percentile is not None:\n        array = self.scale_percentile(array, percentile=percentile)\n    elif surface_reflectance is not None:\n        array = self._prepare_sentinel_rgb(\n            array,\n            rgb=rgb,\n            surface_reflectance=surface_reflectance,\n            cutoff=cutoff,\n        )\n    return array\n</code></pre>"},{"location":"md/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.save_animation","title":"<code>save_animation(path, fps=2)</code>","text":"<p>Save the animation.</p> <pre><code>- video format is taken from the given path. available [\"gif\", \"mov\", \"avi\", \"mp4\"].\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path</p> required <code>fps</code> <code>int</code> <p>frames per second. Default is 2.</p> <code>2</code> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>def save_animation(self, path: str, fps: int = 2):\n    \"\"\"Save the animation.\n\n        - video format is taken from the given path. available [\"gif\", \"mov\", \"avi\", \"mp4\"].\n\n    Parameters\n    ----------\n    path: [str]\n        path\n    fps: [int]\n        frames per second. Default is 2.\n    \"\"\"\n    video_format = path.split(\".\")[-1]\n    if video_format not in SUPPORTED_VIDEO_FORMAT:\n        raise ValueError(\n            f\"The given extension {video_format} implies a format that is not supported, \"\n            f\"only {SUPPORTED_VIDEO_FORMAT} are supported\"\n        )\n\n    if video_format == \"gif\":\n        writer_gif = animation.PillowWriter(fps=fps)\n        self.anim.save(path, writer=writer_gif)\n    else:\n        try:\n            if video_format == \"avi\" or video_format == \"mov\":\n                writer_video = animation.FFMpegWriter(fps=fps, bitrate=1800)\n                self.anim.save(path, writer=writer_video)\n            elif video_format == \"mp4\":\n                writer_mp4 = animation.FFMpegWriter(fps=fps, bitrate=1800)\n                self.anim.save(path, writer=writer_mp4)\n        except FileNotFoundError:\n            print(\n                \"Please visit https://ffmpeg.org/ and download a version of ffmpeg compatible with your operating\"\n                \"system, for more details please check the method definition\"\n            )\n</code></pre>"},{"location":"md/array-glyph-class/#cleopatra.array_glyph.ArrayGlyph.scale_percentile","title":"<code>scale_percentile(arr, percentile=1)</code>  <code>staticmethod</code>","text":"<p>Scale the array.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>ndarray</code> <p>The array to be scaled.</p> required <code>percentile</code> <code>int</code> <p>The percentile value to be used for scaling.</p> <code>1</code> <p>Returns:</p> Type Description <code>np.ndarray: float32</code> <p>The scaled array, normalized between 0 and 1. using the percentile values.</p> Source code in <code>cleopatra/array_glyph.py</code> <pre><code>@staticmethod\ndef scale_percentile(arr: np.ndarray, percentile: int = 1) -&gt; np.ndarray:\n    \"\"\"Scale the array.\n\n    Parameters\n    ----------\n    arr: np.ndarray\n        The array to be scaled.\n    percentile: int\n        The percentile value to be used for scaling.\n\n    Returns\n    -------\n    np.ndarray: float32\n        The scaled array, normalized between 0 and 1. using the percentile values.\n    \"\"\"\n    rows, columns, bands = arr.shape\n    # flatten image.\n    arr = np.reshape(arr, [rows * columns, bands]).astype(np.float32)\n    # lower percentile values (one value for each band).\n    lower_percent = np.percentile(arr, percentile, axis=0)\n    # 98 percentile values.\n    upper_percent = np.percentile(arr, 100 - percentile, axis=0) - lower_percent\n    # normalize the 3 bands using the percentile values for each band.\n    arr = (arr - lower_percent[None, :]) / upper_percent[None, :]\n    arr = np.reshape(arr, [rows, columns, bands])\n    # discard outliers.\n    arr = arr.clip(0, 1)\n\n    return arr\n</code></pre>"},{"location":"md/array-glyph-class/#examples","title":"Examples","text":""},{"location":"md/array-glyph-class/#basic-array-plot","title":"Basic Array Plot","text":"<pre><code>import numpy as np\nfrom cleopatra.array_glyph import ArrayGlyph\n\n# Create a sample array\narray = np.random.rand(10, 10)\n\n# Create an ArrayGlyph object\narray_glyph = ArrayGlyph(array)\n\n# Plot the array\nfig, ax, im, cbar = array_glyph.plot()\n</code></pre>"},{"location":"md/array-glyph-class/#display-cell-values","title":"Display Cell Values","text":"<pre><code># Plot the array with cell values displayed\nfig, ax, im, cbar = array_glyph.plot(display_cell_values=True)\n</code></pre>"},{"location":"md/array-glyph-class/#display-points","title":"Display Points","text":"<pre><code># Create some points to display on the array\npoints = np.array([[2, 3, 1], [5, 7, 2], [8, 1, 3]])\n\n# Plot the array with points\nfig, ax, im, cbar = array_glyph.plot(points=points)\n</code></pre>"},{"location":"md/array-glyph-class/#animation","title":"Animation","text":"<pre><code>import numpy as np\nfrom cleopatra.array_glyph import ArrayGlyph\n\n# Create a time series of arrays\ntime_series = [np.random.rand(10, 10) for _ in range(5)]\ntime_labels = [\"t1\", \"t2\", \"t3\", \"t4\", \"t5\"]\n\n# Create an ArrayGlyph object with the first array\narray_glyph = ArrayGlyph(time_series[0])\n\n# Animate the array over time\nanim = array_glyph.animate(time=time_labels, points=points)\n\n# Save the animation\narray_glyph.save_animation(\"animation.gif\", fps=2)\n</code></pre>"},{"location":"md/colors-class/","title":"Colors Class","text":"<p>The <code>Colors</code> class provides functionality for working with colors, including converting between different color formats (hex, RGB), validating color values, and getting the type of color.</p>"},{"location":"md/colors-class/#class-documentation","title":"Class Documentation","text":""},{"location":"md/colors-class/#cleopatra.colors.Colors","title":"<code>cleopatra.colors.Colors</code>","text":"<p>Colors class for Cleopatra.</p> Source code in <code>cleopatra/colors.py</code> <pre><code>class Colors:\n    \"\"\"Colors class for Cleopatra.\"\"\"\n\n    def __init__(\n        self,\n        color_value: Union[\n            List[str], str, Tuple[float, float, float], List[Tuple[float, float, float]]\n        ],\n    ):\n        \"\"\"\n\n        Parameters\n        ----------\n        color_value: List[str]/Tuple[float, float, float]/str.\n            the color value could be a list of hex colors, a tuple of RGB values, or a single hex/RGB color.\n\n        Examples\n        --------\n        - Create a color object from a hex color:\n            ```python\n            &gt;&gt;&gt; hex_number = \"ff0000\"\n            &gt;&gt;&gt; color = Colors(hex_number)\n            &gt;&gt;&gt; print(color.color_value)\n            ['ff0000']\n            ```\n        - Create a color object from an RGB color (values are between 0 and 1):\n            ```python\n            &gt;&gt;&gt; rgb_color = (0.5, 0.2, 0.8)\n            &gt;&gt;&gt; color = Colors(rgb_color)\n            &gt;&gt;&gt; print(color.color_value)\n            [(0.5, 0.2, 0.8)]\n            ```\n        - Create a color object from an RGB color (values are between 0 and 255):\n            ```python\n            &gt;&gt;&gt; rgb_color = (128, 51, 204)\n            &gt;&gt;&gt; color = Colors(rgb_color)\n            &gt;&gt;&gt; print(color.color_value)\n            [(128, 51, 204)]\n            ```\n        \"\"\"\n        # convert the hex color to a list if it is a string\n        if isinstance(color_value, str) or isinstance(color_value, tuple):\n            color_value = [color_value]\n        elif not isinstance(color_value, list):\n            raise ValueError(\n                \"The color_value must be a list of hex colors, list of tuples (RGB color), a single hex \"\n                \"or single RGB tuple color.\"\n            )\n\n        self._color_value = color_value\n\n    def get_type(self) -&gt; List[str]:\n        \"\"\"get_type.\n\n        Returns\n        -------\n        List[str]\n\n        Examples\n        --------\n        - Create a color object from a hex color:\n            ```python\n            &gt;&gt;&gt; hex_number = \"#23a9dd\"\n            &gt;&gt;&gt; color = Colors(hex_number)\n            &gt;&gt;&gt; print(color.get_type())\n            ['hex']\n            ```\n        - Create a color object from an RGB color (values are between 0 and 1):\n            ```python\n            &gt;&gt;&gt; rgb_color = (0.5, 0.2, 0.8)\n            &gt;&gt;&gt; color = Colors(rgb_color)\n            &gt;&gt;&gt; print(color.get_type())\n            ['rgb-normalized']\n            ```\n        - Create a color object from an RGB color (values are between 0 and 255):\n            ```python\n            &gt;&gt;&gt; rgb_color = (128, 51, 204)\n            &gt;&gt;&gt; color = Colors(rgb_color)\n            &gt;&gt;&gt; print(color.get_type())\n            ['rgb']\n            ```\n        \"\"\"\n        color_type = []\n        for color_i in self.color_value:\n            if self.is_valid_rgb_norm(color_i):\n                color_type.append(\"rgb-normalized\")\n            elif self.is_valid_rgb_255(color_i):\n                color_type.append(\"rgb\")\n            elif self.is_valid_hex_i(color_i):\n                color_type.append(\"hex\")\n\n        return color_type\n\n    @property\n    def color_value(self) -&gt; Union[List[str], Tuple[float, float, float]]:\n        \"\"\"Color values given by the user.\n\n        Returns\n        -------\n        List[str]\n        \"\"\"\n        return self._color_value\n\n    def to_hex(self) -&gt; List[str]:\n        \"\"\"Convert colors to hexdecimal format.\n\n        Returns\n        -------\n        List[str]\n            list of hec colors.\n\n        Examples\n        --------\n        - Create a color object from a mixed list of hex and RGB colors:\n            ```python\n            &gt;&gt;&gt; mixed_color = [(128, 51, 204), \"#23a9dd\", (0.5, 0.2, 0.8)]\n            &gt;&gt;&gt; color = Colors(mixed_color)\n            &gt;&gt;&gt; print(color.to_hex())\n            ['#8033cc', '#23a9dd', '#8033cc']\n            ```\n        \"\"\"\n        converted_color = []\n        color_type = self.get_type()\n        for ind, color_i in enumerate(self.color_value):\n            if color_type[ind] == \"hex\":\n                converted_color.append(color_i)\n            elif color_type[ind] == \"rgb\":\n                # Normalize the RGB values to be between 0 and 1\n                rgb_color_normalized = tuple(value / 255 for value in color_i)\n                converted_color.append(mcolors.to_hex(rgb_color_normalized))\n            else:\n                converted_color.append(mcolors.to_hex(color_i))\n        return converted_color\n\n    def is_valid_hex(self) -&gt; List[bool]:\n        \"\"\"is_valid_hex.\n\n            is_valid_hex\n\n        Parameters\n        ----------\n\n        Returns\n        -------\n\n        \"\"\"\n        return [self.is_valid_hex_i(col) for col in self.color_value]\n\n    @staticmethod\n    def is_valid_hex_i(hex_color: str) -&gt; bool:\n        \"\"\"is_valid_hex for single color.\n\n\n        Parameters\n        ----------\n        hex_color: str.\n            single hex color.\n        Returns\n        -------\n        bool\n        \"\"\"\n        return True if mcolors.is_color_like(hex_color) else False\n\n    def is_valid_rgb(self) -&gt; List[bool]:\n        \"\"\"is_valid_rgb.\n\n        Returns\n        -------\n        List[bool]\n            List of boolean values for each color\n        \"\"\"\n        return [\n            self.is_valid_rgb_norm(col) or self.is_valid_rgb_255(col)\n            for col in self.color_value\n        ]\n\n    @staticmethod\n    def is_valid_rgb_255(rgb_tuple: Any) -&gt; bool:\n        \"\"\"validate a single color whither it is rgb or not.\"\"\"\n        if isinstance(rgb_tuple, tuple) and len(rgb_tuple) == 3:\n            if all(isinstance(value, int) for value in rgb_tuple):\n                return all(0 &lt;= value &lt;= 255 for value in rgb_tuple)\n        return False\n\n    @staticmethod\n    def is_valid_rgb_norm(rgb_tuple: Any) -&gt; bool:\n        \"\"\"validate a single color whither it is rgb or not.\"\"\"\n        if isinstance(rgb_tuple, tuple) and len(rgb_tuple) == 3:\n            if all(isinstance(value, float) for value in rgb_tuple):\n                return all(0.0 &lt;= value &lt;= 1.0 for value in rgb_tuple)\n        return False\n\n    def to_rgb(\n        self, normalized: bool = True\n    ) -&gt; List[Tuple[Union[int, float], Union[int, float]]]:\n        \"\"\"get_rgb.\n\n        Parameters\n        ----------\n        normalized: int, Default is True.\n            True if you want the RGB values to be scaled between 0 and 1. False if you want the RGB values to be scaled\n            between 0 and 255.\n\n        Returns\n        -------\n        List[Tuples]\n        \"\"\"\n        color_type = self.get_type()\n        rgb = []\n        if normalized:\n            for ind, color_i in enumerate(self.color_value):\n                # if the color is in RGB format (0-255), normalize the values to be between 0 and 1\n                if color_type[ind] == \"rgb\":\n                    rgb_color_normalized = tuple(value / 255 for value in color_i)\n                    rgb.append(rgb_color_normalized)\n                else:\n                    # any other format, just convert it to RGB\n                    rgb.append(mcolors.to_rgb(color_i))\n        else:\n            for ind, color_i in enumerate(self.color_value):\n                # if the color is in RGB format (0-255), normalize the values to be between 0 and 1\n                if color_type[ind] == \"rgb\":\n                    rgb.append(color_i)\n                else:\n                    # any other format, just convert it to RGB\n                    rgb.append(tuple([int(c * 255) for c in mcolors.to_rgb(color_i)]))\n\n        return rgb\n</code></pre>"},{"location":"md/colors-class/#cleopatra.colors.Colors.color_value","title":"<code>color_value</code>  <code>property</code>","text":"<p>Color values given by the user.</p> <p>Returns:</p> Type Description <code>List[str]</code>"},{"location":"md/colors-class/#cleopatra.colors.Colors.__init__","title":"<code>__init__(color_value)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>color_value</code> <code>Union[List[str], str, Tuple[float, float, float], List[Tuple[float, float, float]]]</code> <p>the color value could be a list of hex colors, a tuple of RGB values, or a single hex/RGB color.</p> required <p>Examples:</p> <ul> <li>Create a color object from a hex color:     <pre><code>&gt;&gt;&gt; hex_number = \"ff0000\"\n&gt;&gt;&gt; color = Colors(hex_number)\n&gt;&gt;&gt; print(color.color_value)\n['ff0000']\n</code></pre></li> <li>Create a color object from an RGB color (values are between 0 and 1):     <pre><code>&gt;&gt;&gt; rgb_color = (0.5, 0.2, 0.8)\n&gt;&gt;&gt; color = Colors(rgb_color)\n&gt;&gt;&gt; print(color.color_value)\n[(0.5, 0.2, 0.8)]\n</code></pre></li> <li>Create a color object from an RGB color (values are between 0 and 255):     <pre><code>&gt;&gt;&gt; rgb_color = (128, 51, 204)\n&gt;&gt;&gt; color = Colors(rgb_color)\n&gt;&gt;&gt; print(color.color_value)\n[(128, 51, 204)]\n</code></pre></li> </ul> Source code in <code>cleopatra/colors.py</code> <pre><code>def __init__(\n    self,\n    color_value: Union[\n        List[str], str, Tuple[float, float, float], List[Tuple[float, float, float]]\n    ],\n):\n    \"\"\"\n\n    Parameters\n    ----------\n    color_value: List[str]/Tuple[float, float, float]/str.\n        the color value could be a list of hex colors, a tuple of RGB values, or a single hex/RGB color.\n\n    Examples\n    --------\n    - Create a color object from a hex color:\n        ```python\n        &gt;&gt;&gt; hex_number = \"ff0000\"\n        &gt;&gt;&gt; color = Colors(hex_number)\n        &gt;&gt;&gt; print(color.color_value)\n        ['ff0000']\n        ```\n    - Create a color object from an RGB color (values are between 0 and 1):\n        ```python\n        &gt;&gt;&gt; rgb_color = (0.5, 0.2, 0.8)\n        &gt;&gt;&gt; color = Colors(rgb_color)\n        &gt;&gt;&gt; print(color.color_value)\n        [(0.5, 0.2, 0.8)]\n        ```\n    - Create a color object from an RGB color (values are between 0 and 255):\n        ```python\n        &gt;&gt;&gt; rgb_color = (128, 51, 204)\n        &gt;&gt;&gt; color = Colors(rgb_color)\n        &gt;&gt;&gt; print(color.color_value)\n        [(128, 51, 204)]\n        ```\n    \"\"\"\n    # convert the hex color to a list if it is a string\n    if isinstance(color_value, str) or isinstance(color_value, tuple):\n        color_value = [color_value]\n    elif not isinstance(color_value, list):\n        raise ValueError(\n            \"The color_value must be a list of hex colors, list of tuples (RGB color), a single hex \"\n            \"or single RGB tuple color.\"\n        )\n\n    self._color_value = color_value\n</code></pre>"},{"location":"md/colors-class/#cleopatra.colors.Colors.get_type","title":"<code>get_type()</code>","text":"<p>get_type.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>Examples:</p> <ul> <li>Create a color object from a hex color:     <pre><code>&gt;&gt;&gt; hex_number = \"#23a9dd\"\n&gt;&gt;&gt; color = Colors(hex_number)\n&gt;&gt;&gt; print(color.get_type())\n['hex']\n</code></pre></li> <li>Create a color object from an RGB color (values are between 0 and 1):     <pre><code>&gt;&gt;&gt; rgb_color = (0.5, 0.2, 0.8)\n&gt;&gt;&gt; color = Colors(rgb_color)\n&gt;&gt;&gt; print(color.get_type())\n['rgb-normalized']\n</code></pre></li> <li>Create a color object from an RGB color (values are between 0 and 255):     <pre><code>&gt;&gt;&gt; rgb_color = (128, 51, 204)\n&gt;&gt;&gt; color = Colors(rgb_color)\n&gt;&gt;&gt; print(color.get_type())\n['rgb']\n</code></pre></li> </ul> Source code in <code>cleopatra/colors.py</code> <pre><code>def get_type(self) -&gt; List[str]:\n    \"\"\"get_type.\n\n    Returns\n    -------\n    List[str]\n\n    Examples\n    --------\n    - Create a color object from a hex color:\n        ```python\n        &gt;&gt;&gt; hex_number = \"#23a9dd\"\n        &gt;&gt;&gt; color = Colors(hex_number)\n        &gt;&gt;&gt; print(color.get_type())\n        ['hex']\n        ```\n    - Create a color object from an RGB color (values are between 0 and 1):\n        ```python\n        &gt;&gt;&gt; rgb_color = (0.5, 0.2, 0.8)\n        &gt;&gt;&gt; color = Colors(rgb_color)\n        &gt;&gt;&gt; print(color.get_type())\n        ['rgb-normalized']\n        ```\n    - Create a color object from an RGB color (values are between 0 and 255):\n        ```python\n        &gt;&gt;&gt; rgb_color = (128, 51, 204)\n        &gt;&gt;&gt; color = Colors(rgb_color)\n        &gt;&gt;&gt; print(color.get_type())\n        ['rgb']\n        ```\n    \"\"\"\n    color_type = []\n    for color_i in self.color_value:\n        if self.is_valid_rgb_norm(color_i):\n            color_type.append(\"rgb-normalized\")\n        elif self.is_valid_rgb_255(color_i):\n            color_type.append(\"rgb\")\n        elif self.is_valid_hex_i(color_i):\n            color_type.append(\"hex\")\n\n    return color_type\n</code></pre>"},{"location":"md/colors-class/#cleopatra.colors.Colors.is_valid_hex","title":"<code>is_valid_hex()</code>","text":"<p>is_valid_hex.</p> <pre><code>is_valid_hex\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>Returns</code> required Source code in <code>cleopatra/colors.py</code> <pre><code>def is_valid_hex(self) -&gt; List[bool]:\n    \"\"\"is_valid_hex.\n\n        is_valid_hex\n\n    Parameters\n    ----------\n\n    Returns\n    -------\n\n    \"\"\"\n    return [self.is_valid_hex_i(col) for col in self.color_value]\n</code></pre>"},{"location":"md/colors-class/#cleopatra.colors.Colors.is_valid_hex_i","title":"<code>is_valid_hex_i(hex_color)</code>  <code>staticmethod</code>","text":"<p>is_valid_hex for single color.</p> <p>Parameters:</p> Name Type Description Default <code>hex_color</code> <code>str</code> <p>single hex color.</p> required <p>Returns:</p> Type Description <code>bool</code> Source code in <code>cleopatra/colors.py</code> <pre><code>@staticmethod\ndef is_valid_hex_i(hex_color: str) -&gt; bool:\n    \"\"\"is_valid_hex for single color.\n\n\n    Parameters\n    ----------\n    hex_color: str.\n        single hex color.\n    Returns\n    -------\n    bool\n    \"\"\"\n    return True if mcolors.is_color_like(hex_color) else False\n</code></pre>"},{"location":"md/colors-class/#cleopatra.colors.Colors.is_valid_rgb","title":"<code>is_valid_rgb()</code>","text":"<p>is_valid_rgb.</p> <p>Returns:</p> Type Description <code>List[bool]</code> <p>List of boolean values for each color</p> Source code in <code>cleopatra/colors.py</code> <pre><code>def is_valid_rgb(self) -&gt; List[bool]:\n    \"\"\"is_valid_rgb.\n\n    Returns\n    -------\n    List[bool]\n        List of boolean values for each color\n    \"\"\"\n    return [\n        self.is_valid_rgb_norm(col) or self.is_valid_rgb_255(col)\n        for col in self.color_value\n    ]\n</code></pre>"},{"location":"md/colors-class/#cleopatra.colors.Colors.is_valid_rgb_255","title":"<code>is_valid_rgb_255(rgb_tuple)</code>  <code>staticmethod</code>","text":"<p>validate a single color whither it is rgb or not.</p> Source code in <code>cleopatra/colors.py</code> <pre><code>@staticmethod\ndef is_valid_rgb_255(rgb_tuple: Any) -&gt; bool:\n    \"\"\"validate a single color whither it is rgb or not.\"\"\"\n    if isinstance(rgb_tuple, tuple) and len(rgb_tuple) == 3:\n        if all(isinstance(value, int) for value in rgb_tuple):\n            return all(0 &lt;= value &lt;= 255 for value in rgb_tuple)\n    return False\n</code></pre>"},{"location":"md/colors-class/#cleopatra.colors.Colors.is_valid_rgb_norm","title":"<code>is_valid_rgb_norm(rgb_tuple)</code>  <code>staticmethod</code>","text":"<p>validate a single color whither it is rgb or not.</p> Source code in <code>cleopatra/colors.py</code> <pre><code>@staticmethod\ndef is_valid_rgb_norm(rgb_tuple: Any) -&gt; bool:\n    \"\"\"validate a single color whither it is rgb or not.\"\"\"\n    if isinstance(rgb_tuple, tuple) and len(rgb_tuple) == 3:\n        if all(isinstance(value, float) for value in rgb_tuple):\n            return all(0.0 &lt;= value &lt;= 1.0 for value in rgb_tuple)\n    return False\n</code></pre>"},{"location":"md/colors-class/#cleopatra.colors.Colors.to_hex","title":"<code>to_hex()</code>","text":"<p>Convert colors to hexdecimal format.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>list of hec colors.</p> <p>Examples:</p> <ul> <li>Create a color object from a mixed list of hex and RGB colors:     <pre><code>&gt;&gt;&gt; mixed_color = [(128, 51, 204), \"#23a9dd\", (0.5, 0.2, 0.8)]\n&gt;&gt;&gt; color = Colors(mixed_color)\n&gt;&gt;&gt; print(color.to_hex())\n['#8033cc', '#23a9dd', '#8033cc']\n</code></pre></li> </ul> Source code in <code>cleopatra/colors.py</code> <pre><code>def to_hex(self) -&gt; List[str]:\n    \"\"\"Convert colors to hexdecimal format.\n\n    Returns\n    -------\n    List[str]\n        list of hec colors.\n\n    Examples\n    --------\n    - Create a color object from a mixed list of hex and RGB colors:\n        ```python\n        &gt;&gt;&gt; mixed_color = [(128, 51, 204), \"#23a9dd\", (0.5, 0.2, 0.8)]\n        &gt;&gt;&gt; color = Colors(mixed_color)\n        &gt;&gt;&gt; print(color.to_hex())\n        ['#8033cc', '#23a9dd', '#8033cc']\n        ```\n    \"\"\"\n    converted_color = []\n    color_type = self.get_type()\n    for ind, color_i in enumerate(self.color_value):\n        if color_type[ind] == \"hex\":\n            converted_color.append(color_i)\n        elif color_type[ind] == \"rgb\":\n            # Normalize the RGB values to be between 0 and 1\n            rgb_color_normalized = tuple(value / 255 for value in color_i)\n            converted_color.append(mcolors.to_hex(rgb_color_normalized))\n        else:\n            converted_color.append(mcolors.to_hex(color_i))\n    return converted_color\n</code></pre>"},{"location":"md/colors-class/#cleopatra.colors.Colors.to_rgb","title":"<code>to_rgb(normalized=True)</code>","text":"<p>get_rgb.</p> <p>Parameters:</p> Name Type Description Default <code>normalized</code> <code>bool</code> <p>True if you want the RGB values to be scaled between 0 and 1. False if you want the RGB values to be scaled between 0 and 255.</p> <code>True</code> <p>Returns:</p> Type Description <code>List[Tuples]</code> Source code in <code>cleopatra/colors.py</code> <pre><code>def to_rgb(\n    self, normalized: bool = True\n) -&gt; List[Tuple[Union[int, float], Union[int, float]]]:\n    \"\"\"get_rgb.\n\n    Parameters\n    ----------\n    normalized: int, Default is True.\n        True if you want the RGB values to be scaled between 0 and 1. False if you want the RGB values to be scaled\n        between 0 and 255.\n\n    Returns\n    -------\n    List[Tuples]\n    \"\"\"\n    color_type = self.get_type()\n    rgb = []\n    if normalized:\n        for ind, color_i in enumerate(self.color_value):\n            # if the color is in RGB format (0-255), normalize the values to be between 0 and 1\n            if color_type[ind] == \"rgb\":\n                rgb_color_normalized = tuple(value / 255 for value in color_i)\n                rgb.append(rgb_color_normalized)\n            else:\n                # any other format, just convert it to RGB\n                rgb.append(mcolors.to_rgb(color_i))\n    else:\n        for ind, color_i in enumerate(self.color_value):\n            # if the color is in RGB format (0-255), normalize the values to be between 0 and 1\n            if color_type[ind] == \"rgb\":\n                rgb.append(color_i)\n            else:\n                # any other format, just convert it to RGB\n                rgb.append(tuple([int(c * 255) for c in mcolors.to_rgb(color_i)]))\n\n    return rgb\n</code></pre>"},{"location":"md/colors-class/#examples","title":"Examples","text":""},{"location":"md/colors-class/#creating-color-objects","title":"Creating Color Objects","text":"<pre><code>from cleopatra.colors import Colors\n\n# Create a Colors object with a hex color\nhex_color = Colors(\"#FF5733\")\n\n# Create a Colors object with an RGB color (normalized)\nrgb_color = Colors((1.0, 0.34, 0.2))\n\n# Create a Colors object with an RGB color (0-255)\nrgb_255_color = Colors((255, 87, 51))\n\n# Create a Colors object with a named color\nnamed_color = Colors(\"red\")\n\n# Create a Colors object with a list of colors\ncolor_list = Colors([\"red\", \"green\", \"blue\"])\n</code></pre>"},{"location":"md/colors-class/#converting-between-color-formats","title":"Converting Between Color Formats","text":"<pre><code># Convert to hex\nhex_value = rgb_color.to_hex()\nprint(hex_value)  # \"#FF5733\"\n\n# Convert to RGB (normalized)\nrgb_value = hex_color.to_rgb(normalized=True)\nprint(rgb_value)  # (1.0, 0.34, 0.2)\n\n# Convert to RGB (0-255)\nrgb_255_value = hex_color.to_rgb(normalized=False)\nprint(rgb_255_value)  # (255, 87, 51)\n</code></pre>"},{"location":"md/colors-class/#validating-color-values","title":"Validating Color Values","text":"<pre><code># Check if a hex color is valid\nis_valid = hex_color.is_valid_hex()\nprint(is_valid)  # True\n\n# Check if an RGB color is valid\nis_valid = rgb_color.is_valid_rgb()\nprint(is_valid)  # True\n</code></pre>"},{"location":"md/installation/","title":"Installation","text":""},{"location":"md/installation/#dependencies","title":"Dependencies","text":""},{"location":"md/installation/#required-dependencies","title":"Required dependencies","text":"<ul> <li>Python (3.11 or later)</li> <li>numpy (2.0.0 or later)</li> <li>hpc (0.1.4 or later)</li> <li>matplotlib (3.8.4 or later)</li> <li>ffmpeg-python (0.2.0 or later)</li> </ul>"},{"location":"md/installation/#stable-release","title":"Stable release","text":"<p>Please install <code>cleopatra</code> in a Virtual environment so that its requirements don't tamper with your system's python.</p>"},{"location":"md/installation/#conda","title":"conda","text":"<p>The easiest way to install <code>cleopatra</code> is using <code>conda</code> package manager. <code>cleopatra</code> is available in the conda-forge channel. To install you can use the following command:</p> <pre><code>conda install -c conda-forge cleopatra\n</code></pre> <p>If this works it will install <code>cleopatra</code> with all dependencies including Python, and you skip the rest of the installation instructions.</p>"},{"location":"md/installation/#installing-python-and-gdal-dependencies","title":"Installing Python and gdal dependencies","text":"<p>The main dependencies for cleopatra are an installation of Python 3.11+</p>"},{"location":"md/installation/#installing-python","title":"Installing Python","text":"<p>For Python, we recommend using the Anaconda Distribution for Python 3, which is available for download from https://www.anaconda.com/download/. The installer gives the option to add <code>python</code> to your <code>PATH</code> environment variable. We will assume in the instructions below that it is available in the path, such that <code>python</code>, <code>pip</code>, and <code>conda</code> are all available from the command line.</p> <p>Note that there is no hard requirement specifically for Anaconda's Python, but often it makes installation of required dependencies easier using the conda package manager.</p>"},{"location":"md/installation/#install-as-a-conda-environment","title":"Install as a conda environment","text":"<p>The easiest and most robust way to install Hapi is by installing it in a separate conda environment. In the root repository directory there is an <code>environment.yml</code> file. This file lists all dependencies. Either use the <code>environment.yml</code> file from the master branch (please note that the master branch can change rapidly and break functionality without warning), or from one of the releases {release}.</p> <p>Run this command to start installing all Hapi dependencies:</p> <pre><code>conda env create -f environment.yml\n</code></pre> <p>This creates a new environment with the name <code>cleopatra</code>. To activate this environment in a session, run:</p> <pre><code>conda activate cleopatra\n</code></pre> <p>For the installation of Hapi there are two options (from the Python Package Index (PyPI) or from Github). To install a release of Hapi from the PyPI (available from release 2018.1):</p> <pre><code>pip install cleopatra=={release}\n</code></pre>"},{"location":"md/installation/#from-sources","title":"From sources","text":"<p>The sources for HapiSM can be downloaded from the Github repo.</p> <p>You can either clone the public repository:</p> <pre><code>git clone git://github.com/Serapieum-of-alex/cleopatra\n</code></pre> <p>Or download the tarball:</p> <pre><code>curl -OJL https://github.com/Serapieum-of-alex/cleopatra/tarball/main\n</code></pre> <p>Once you have a copy of the source, you can install it with:</p> <pre><code>python pip install .\n</code></pre> <p>To install directly from GitHub (from the HEAD of the master branch):</p> <pre><code>pip install git+https://github.com/Serapieum-of-alex/cleopatra.git\n</code></pre> <p>or from Github from a specific release:</p> <pre><code>pip install git+https://github.com/Serapieum-of-alex/cleopatra.git@{release}\n</code></pre> <p>Now you should be able to start this environment's Python with <code>python</code>, try <code>import cleopatra</code> to see if the package is installed.</p> <p>More details on how to work with conda environments can be found here: https://conda.io/docs/user-guide/tasks/manage-environments.html</p> <p>If you are planning to make changes and contribute to the development of Hapi, it is best to make a git clone of the repository, and do a editable install in the location of you clone. This will not move a copy to your Python installation directory, but instead create a link in your Python installation pointing to the folder you installed it from, such that any changes you make there are directly reflected in your install.</p> <pre><code>git clone https://github.com/Serapieum-of-alex/cleopatra.git\ncd cleopatra\nactivate cleopatra\npip install -e .\n</code></pre> <p>Alternatively, if you want to avoid using <code>git</code> and simply want to test the latest version from the <code>main</code> branch, you can replace the first line with downloading a zip archive from GitHub: https://github.com/Serapieum-of-alex/cleopatra/archive/master.zip libraries.io.</p>"},{"location":"md/installation/#install-using-pip","title":"Install using pip","text":"<p>Besides the recommended conda environment setup described above, you can also install <code>cleopatra</code> with <code>pip</code>. For the more difficult to install Python dependencies, it is best to use the conda package manager:</p> <pre><code>conda install numpy gdal\n</code></pre> <p>you can check libraries.io to check versions of the libraries</p> <p>Then install a release {release} of cleopatra (available from release 2018.1) with pip:</p> <pre><code>pip install cleopatra=={release}\n</code></pre>"},{"location":"md/installation/#check-if-the-installation-is-successful","title":"Check if the installation is successful","text":"<p>To check it the install is successful, go to the examples directory and run the following command:</p> <pre><code>python -m cleopatra.*******\n</code></pre> <p>This should run without errors.</p> <p>Note</p> <p>This documentation was generated on {{ date }}</p> <p>Documentation for the development version: https://cleopatra.readthedocs.org/en/latest/</p> <p>Documentation for the stable version: https://cleopatra.readthedocs.org/en/stable/</p>"},{"location":"md/statistics-class/","title":"Statistic Class","text":"<p>The <code>Statistic</code> module provides a class for creating statistical plots, specifically histograms. The class, <code>Statistic</code>, is designed to handle both 1D (single-dimensional) and 2D (multi-dimensional) data.</p>"},{"location":"md/statistics-class/#class-documentation","title":"Class Documentation","text":""},{"location":"md/statistics-class/#cleopatra.statistics.Statistic","title":"<code>cleopatra.statistics.Statistic</code>","text":"<p>A class for creating statistical plots, specifically histograms.</p> <p>This class provides methods for initializing the class with numerical values and optional keyword arguments, and for creating histograms from the given values.</p> <p>Attributes: _values: numpy.ndarray     The numerical values to be plotted as histograms. _default_options: dict     The default options for creating histograms, including the number of bins, color, alpha, rwidth, grid_alpha,     xlabel, ylabel, xlabel_font_size, ylabel_font_size, xtick_font_size, and ytick_font_size.</p> <p>Methods: init(self, values: Union[List, np.ndarray], kwargs):     Initializes the class with numerical values and optional keyword arguments. histogram(self, kwargs) -&gt; [Figure, Axes, Dict]:     Creates a histogram from the given values and optional keyword arguments.</p> Example <pre><code>&gt;&gt;&gt; np.random.seed(1)\n&gt;&gt;&gt; x = 4 + np.random.normal(0, 1.5, 200)\n&gt;&gt;&gt; stat_plot = Statistic(x)\n&gt;&gt;&gt; fig, ax, hist = stat_plot.histogram()\n&gt;&gt;&gt; print(hist) # doctest: +SKIP\n{'n': [array([ 2.,  4.,  3., 10., 11., 20., 30., 27., 31., 25., 17.,  8.,  5.,\n                    6.,  1.])], 'bins': [array([0.34774335, 0.8440597 , 1.34037605, 1.8366924 , 2.33300874,\n                   2.82932509, 3.32564144, 3.82195778, 4.31827413, 4.81459048,\n                   5.31090682, 5.80722317, 6.30353952, 6.79985587, 7.29617221,\n                   7.79248856])], 'patches': [&lt;BarContainer object of 15 artists&gt;]}\n</code></pre> <p></p> Source code in <code>cleopatra/statistics.py</code> <pre><code>class Statistic:\n    \"\"\"\n    A class for creating statistical plots, specifically histograms.\n\n    This class provides methods for initializing the class with numerical values and optional keyword arguments,\n    and for creating histograms from the given values.\n\n    Attributes:\n    _values: numpy.ndarray\n        The numerical values to be plotted as histograms.\n    _default_options: dict\n        The default options for creating histograms, including the number of bins, color, alpha, rwidth, grid_alpha,\n        xlabel, ylabel, xlabel_font_size, ylabel_font_size, xtick_font_size, and ytick_font_size.\n\n    Methods:\n    __init__(self, values: Union[List, np.ndarray], **kwargs):\n        Initializes the class with numerical values and optional keyword arguments.\n    histogram(self, **kwargs) -&gt; [Figure, Axes, Dict]:\n        Creates a histogram from the given values and optional keyword arguments.\n\n    Example\n    -------\n        &gt;&gt;&gt; np.random.seed(1)\n        &gt;&gt;&gt; x = 4 + np.random.normal(0, 1.5, 200)\n        &gt;&gt;&gt; stat_plot = Statistic(x)\n        &gt;&gt;&gt; fig, ax, hist = stat_plot.histogram()\n        &gt;&gt;&gt; print(hist) # doctest: +SKIP\n        {'n': [array([ 2.,  4.,  3., 10., 11., 20., 30., 27., 31., 25., 17.,  8.,  5.,\n                            6.,  1.])], 'bins': [array([0.34774335, 0.8440597 , 1.34037605, 1.8366924 , 2.33300874,\n                           2.82932509, 3.32564144, 3.82195778, 4.31827413, 4.81459048,\n                           5.31090682, 5.80722317, 6.30353952, 6.79985587, 7.29617221,\n                           7.79248856])], 'patches': [&lt;BarContainer object of 15 artists&gt;]}\n\n    ![image](../_images/one-histogram.png)\n    \"\"\"\n\n    def __init__(\n        self,\n        values: Union[List, np.ndarray],\n        **kwargs,\n    ):\n        \"\"\"\n\n        Parameters\n        ----------\n        values: [list/array]\n            values to be plotted as histogram.\n        \"\"\"\n        self._values = values\n        options_dict = DEFAULT_OPTIONS.copy()\n        options_dict.update(kwargs)\n        self._default_options = options_dict\n\n    @property\n    def values(self):\n        \"\"\"numerical values\"\"\"\n        return self._values\n\n    @values.setter\n    def values(self, values):\n        self._values = values\n\n    @property\n    def default_options(self) -&gt; Dict:\n        \"\"\"Default plot options\"\"\"\n        return self._default_options\n\n    def histogram(self, **kwargs) -&gt; [Figure, Axes, Dict]:\n        \"\"\"\n\n        Parameters\n        ----------\n        **kwargs: [dict]\n            keys:\n                bins: int, Default is 15.\n                    number of bins.\n                color: List[str], default is [\"#0504aa\"]\n                    color of the bins, the number of colors should be equal to the number of samples (columns of the\n                    given array).\n                alpha: float, default is 0.7\n                     degree of transparency.\n                rwidth: float, default is 0.85\n                    width of the bins.\n                grid_alpha:\n                    alpha of the grid.\n                xlabel: str\n                    x-axis label.\n                ylabel: str\n                    y-axis label.\n                xlabel_font_size: int\n                    x-axis label font size.\n                ylabel_font_size: int\n                    y-axis label font size.\n                xtick_font_size: int\n                    x-axis tick font size.\n                 ytick_font_size: int\n                    y-axis tick font size.\n\n        Raises\n        ------\n        ValueError\n            If the number of colors given by the `color` kwars is not equal to the number of samples.\n\n        Example\n        -------\n            - 1D data.\n\n                - First genearte some random data and plot the histogram.\n                    ```python\n                    &gt;&gt;&gt; np.random.seed(1)\n                    &gt;&gt;&gt; x = 4 + np.random.normal(0, 1.5, 200)\n                    &gt;&gt;&gt; stat_plot = Statistic(x)\n                    &gt;&gt;&gt; fig, ax, hist = stat_plot.histogram()\n                    &gt;&gt;&gt; print(hist) # doctest: +SKIP\n                    {'n': [array([ 2.,  4.,  3., 10., 11., 20., 30., 27., 31., 25., 17.,  8.,  5.,\n                            6.,  1.])], 'bins': [array([0.34774335, 0.8440597 , 1.34037605, 1.8366924 , 2.33300874,\n                           2.82932509, 3.32564144, 3.82195778, 4.31827413, 4.81459048,\n                           5.31090682, 5.80722317, 6.30353952, 6.79985587, 7.29617221,\n                           7.79248856])], 'patches': [&lt;BarContainer object of 15 artists&gt;]}\n                    ```\n                ![image](../_images/one-histogram.png)\n\n            - 2D data.\n\n                - First genearte some random data and plot the histogram.\n                    ```python\n                    &gt;&gt;&gt; np.random.seed(1)\n                    &gt;&gt;&gt; x = 4 + np.random.normal(0, 1.5, (200, 3))\n                    &gt;&gt;&gt; stat_plot = Statistic(x, color=[\"red\", \"green\", \"blue\"], alpha=0.4, rwidth=0.8)\n                    &gt;&gt;&gt; fig, ax, hist = stat_plot.histogram()\n                    &gt;&gt;&gt; print(hist) # doctest: +SKIP\n                    {'n': [array([ 1.,  2.,  4., 10., 13., 19., 20., 32., 27., 23., 24., 11.,  5.,\n                            5.,  4.]), array([ 3.,  4.,  9., 12., 20., 41., 29., 32., 25., 14.,  9.,  1.,  0.,\n                            0.,  1.]), array([ 3.,  4.,  6.,  7., 25., 26., 31., 24., 30., 19., 11.,  9.,  4.,\n                            0.,  1.])], 'bins': [array([-0.1896275 ,  0.33461786,  0.85886323,  1.38310859,  1.90735396,\n                            2.43159932,  2.95584469,  3.48009005,  4.00433542,  4.52858078,\n                            5.05282615,  5.57707151,  6.10131688,  6.62556224,  7.14980761,\n                            7.67405297]), array([-0.1738017 ,  0.50031202,  1.17442573,  1.84853945,  2.52265317,\n                            3.19676688,  3.8708806 ,  4.54499432,  5.21910804,  5.89322175,\n                            6.56733547,  7.24144919,  7.9155629 ,  8.58967662,  9.26379034,\n                            9.93790406]), array([0.24033902, 0.7940688 , 1.34779857, 1.90152835, 2.45525813,\n                           3.0089879 , 3.56271768, 4.11644746, 4.67017723, 5.22390701,\n                           5.77763679, 6.33136656, 6.88509634, 7.43882612, 7.99255589,\n                           8.54628567])], 'patches': [&lt;BarContainer object of 15 artists&gt;,\n                           &lt;BarContainer object of 15 artists&gt;, &lt;BarContainer object of 15 artists&gt;]}\n                    ```\n\n                ![image](../_images/three-histogram.png)\n        \"\"\"\n        for key, val in kwargs.items():\n            if key not in self.default_options.keys():\n                raise ValueError(\n                    f\"The given keyword argument:{key} is not correct, possible parameters are,\"\n                    f\" {self.default_options}\"\n                )\n            else:\n                self.default_options[key] = val\n\n        fig, ax = plt.subplots(figsize=self.default_options[\"figsize\"])\n\n        n = []\n        bins = []\n        patches = []\n        bins_val = self.default_options[\"bins\"]\n        color = self.default_options[\"color\"]\n        alpha = self.default_options[\"alpha\"]\n        rwidth = self.default_options[\"rwidth\"]\n        if self.values.ndim == 2:\n            num_samples = self.values.shape[1]\n            if len(color) != num_samples:\n                raise ValueError(\n                    f\"The number of colors:{len(color)} should be equal to the number of samples:{num_samples}\"\n                )\n        else:\n            num_samples = 1\n\n        for i in range(num_samples):\n            if self.values.ndim == 1:\n                vals = self.values\n            else:\n                vals = self.values[:, i]\n\n            n_i, bins_i, patches_i = ax.hist(\n                x=vals,\n                bins=bins_val,\n                color=color[i],\n                alpha=alpha,\n                rwidth=rwidth,\n            )\n            n.append(n_i)\n            bins.append(bins_i)\n            patches.append(patches_i)\n\n        plt.grid(axis=\"y\", alpha=self.default_options[\"grid_alpha\"])\n        plt.xlabel(\n            self.default_options[\"xlabel\"],\n            fontsize=self.default_options[\"xlabel_font_size\"],\n        )\n        plt.ylabel(\n            self.default_options[\"ylabel\"],\n            fontsize=self.default_options[\"ylabel_font_size\"],\n        )\n        plt.xticks(fontsize=self.default_options[\"xtick_font_size\"])\n        plt.yticks(fontsize=self.default_options[\"ytick_font_size\"])\n        hist = {\"n\": n, \"bins\": bins, \"patches\": patches}\n        plt.show()\n        return fig, ax, hist\n</code></pre>"},{"location":"md/statistics-class/#cleopatra.statistics.Statistic.default_options","title":"<code>default_options</code>  <code>property</code>","text":"<p>Default plot options</p>"},{"location":"md/statistics-class/#cleopatra.statistics.Statistic.values","title":"<code>values</code>  <code>property</code> <code>writable</code>","text":"<p>numerical values</p>"},{"location":"md/statistics-class/#cleopatra.statistics.Statistic.__init__","title":"<code>__init__(values, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>values</code> <code>Union[List, ndarray]</code> <p>values to be plotted as histogram.</p> required Source code in <code>cleopatra/statistics.py</code> <pre><code>def __init__(\n    self,\n    values: Union[List, np.ndarray],\n    **kwargs,\n):\n    \"\"\"\n\n    Parameters\n    ----------\n    values: [list/array]\n        values to be plotted as histogram.\n    \"\"\"\n    self._values = values\n    options_dict = DEFAULT_OPTIONS.copy()\n    options_dict.update(kwargs)\n    self._default_options = options_dict\n</code></pre>"},{"location":"md/statistics-class/#cleopatra.statistics.Statistic.histogram","title":"<code>histogram(**kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>keys:     bins: int, Default is 15.         number of bins.     color: List[str], default is [\"#0504aa\"]         color of the bins, the number of colors should be equal to the number of samples (columns of the         given array).     alpha: float, default is 0.7          degree of transparency.     rwidth: float, default is 0.85         width of the bins.     grid_alpha:         alpha of the grid.     xlabel: str         x-axis label.     ylabel: str         y-axis label.     xlabel_font_size: int         x-axis label font size.     ylabel_font_size: int         y-axis label font size.     xtick_font_size: int         x-axis tick font size.      ytick_font_size: int         y-axis tick font size.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the number of colors given by the <code>color</code> kwars is not equal to the number of samples.</p> Example <pre><code>- 1D data.\n\n    - First genearte some random data and plot the histogram.\n        ```python\n        &gt;&gt;&gt; np.random.seed(1)\n        &gt;&gt;&gt; x = 4 + np.random.normal(0, 1.5, 200)\n        &gt;&gt;&gt; stat_plot = Statistic(x)\n        &gt;&gt;&gt; fig, ax, hist = stat_plot.histogram()\n        &gt;&gt;&gt; print(hist) # doctest: +SKIP\n        {'n': [array([ 2.,  4.,  3., 10., 11., 20., 30., 27., 31., 25., 17.,  8.,  5.,\n                6.,  1.])], 'bins': [array([0.34774335, 0.8440597 , 1.34037605, 1.8366924 , 2.33300874,\n               2.82932509, 3.32564144, 3.82195778, 4.31827413, 4.81459048,\n               5.31090682, 5.80722317, 6.30353952, 6.79985587, 7.29617221,\n               7.79248856])], 'patches': [&lt;BarContainer object of 15 artists&gt;]}\n        ```\n    ![image](../_images/one-histogram.png)\n\n- 2D data.\n\n    - First genearte some random data and plot the histogram.\n        ```python\n        &gt;&gt;&gt; np.random.seed(1)\n        &gt;&gt;&gt; x = 4 + np.random.normal(0, 1.5, (200, 3))\n        &gt;&gt;&gt; stat_plot = Statistic(x, color=[\"red\", \"green\", \"blue\"], alpha=0.4, rwidth=0.8)\n        &gt;&gt;&gt; fig, ax, hist = stat_plot.histogram()\n        &gt;&gt;&gt; print(hist) # doctest: +SKIP\n        {'n': [array([ 1.,  2.,  4., 10., 13., 19., 20., 32., 27., 23., 24., 11.,  5.,\n                5.,  4.]), array([ 3.,  4.,  9., 12., 20., 41., 29., 32., 25., 14.,  9.,  1.,  0.,\n                0.,  1.]), array([ 3.,  4.,  6.,  7., 25., 26., 31., 24., 30., 19., 11.,  9.,  4.,\n                0.,  1.])], 'bins': [array([-0.1896275 ,  0.33461786,  0.85886323,  1.38310859,  1.90735396,\n                2.43159932,  2.95584469,  3.48009005,  4.00433542,  4.52858078,\n                5.05282615,  5.57707151,  6.10131688,  6.62556224,  7.14980761,\n                7.67405297]), array([-0.1738017 ,  0.50031202,  1.17442573,  1.84853945,  2.52265317,\n                3.19676688,  3.8708806 ,  4.54499432,  5.21910804,  5.89322175,\n                6.56733547,  7.24144919,  7.9155629 ,  8.58967662,  9.26379034,\n                9.93790406]), array([0.24033902, 0.7940688 , 1.34779857, 1.90152835, 2.45525813,\n               3.0089879 , 3.56271768, 4.11644746, 4.67017723, 5.22390701,\n               5.77763679, 6.33136656, 6.88509634, 7.43882612, 7.99255589,\n               8.54628567])], 'patches': [&lt;BarContainer object of 15 artists&gt;,\n               &lt;BarContainer object of 15 artists&gt;, &lt;BarContainer object of 15 artists&gt;]}\n        ```\n\n    ![image](../_images/three-histogram.png)\n</code></pre> Source code in <code>cleopatra/statistics.py</code> <pre><code>def histogram(self, **kwargs) -&gt; [Figure, Axes, Dict]:\n    \"\"\"\n\n    Parameters\n    ----------\n    **kwargs: [dict]\n        keys:\n            bins: int, Default is 15.\n                number of bins.\n            color: List[str], default is [\"#0504aa\"]\n                color of the bins, the number of colors should be equal to the number of samples (columns of the\n                given array).\n            alpha: float, default is 0.7\n                 degree of transparency.\n            rwidth: float, default is 0.85\n                width of the bins.\n            grid_alpha:\n                alpha of the grid.\n            xlabel: str\n                x-axis label.\n            ylabel: str\n                y-axis label.\n            xlabel_font_size: int\n                x-axis label font size.\n            ylabel_font_size: int\n                y-axis label font size.\n            xtick_font_size: int\n                x-axis tick font size.\n             ytick_font_size: int\n                y-axis tick font size.\n\n    Raises\n    ------\n    ValueError\n        If the number of colors given by the `color` kwars is not equal to the number of samples.\n\n    Example\n    -------\n        - 1D data.\n\n            - First genearte some random data and plot the histogram.\n                ```python\n                &gt;&gt;&gt; np.random.seed(1)\n                &gt;&gt;&gt; x = 4 + np.random.normal(0, 1.5, 200)\n                &gt;&gt;&gt; stat_plot = Statistic(x)\n                &gt;&gt;&gt; fig, ax, hist = stat_plot.histogram()\n                &gt;&gt;&gt; print(hist) # doctest: +SKIP\n                {'n': [array([ 2.,  4.,  3., 10., 11., 20., 30., 27., 31., 25., 17.,  8.,  5.,\n                        6.,  1.])], 'bins': [array([0.34774335, 0.8440597 , 1.34037605, 1.8366924 , 2.33300874,\n                       2.82932509, 3.32564144, 3.82195778, 4.31827413, 4.81459048,\n                       5.31090682, 5.80722317, 6.30353952, 6.79985587, 7.29617221,\n                       7.79248856])], 'patches': [&lt;BarContainer object of 15 artists&gt;]}\n                ```\n            ![image](../_images/one-histogram.png)\n\n        - 2D data.\n\n            - First genearte some random data and plot the histogram.\n                ```python\n                &gt;&gt;&gt; np.random.seed(1)\n                &gt;&gt;&gt; x = 4 + np.random.normal(0, 1.5, (200, 3))\n                &gt;&gt;&gt; stat_plot = Statistic(x, color=[\"red\", \"green\", \"blue\"], alpha=0.4, rwidth=0.8)\n                &gt;&gt;&gt; fig, ax, hist = stat_plot.histogram()\n                &gt;&gt;&gt; print(hist) # doctest: +SKIP\n                {'n': [array([ 1.,  2.,  4., 10., 13., 19., 20., 32., 27., 23., 24., 11.,  5.,\n                        5.,  4.]), array([ 3.,  4.,  9., 12., 20., 41., 29., 32., 25., 14.,  9.,  1.,  0.,\n                        0.,  1.]), array([ 3.,  4.,  6.,  7., 25., 26., 31., 24., 30., 19., 11.,  9.,  4.,\n                        0.,  1.])], 'bins': [array([-0.1896275 ,  0.33461786,  0.85886323,  1.38310859,  1.90735396,\n                        2.43159932,  2.95584469,  3.48009005,  4.00433542,  4.52858078,\n                        5.05282615,  5.57707151,  6.10131688,  6.62556224,  7.14980761,\n                        7.67405297]), array([-0.1738017 ,  0.50031202,  1.17442573,  1.84853945,  2.52265317,\n                        3.19676688,  3.8708806 ,  4.54499432,  5.21910804,  5.89322175,\n                        6.56733547,  7.24144919,  7.9155629 ,  8.58967662,  9.26379034,\n                        9.93790406]), array([0.24033902, 0.7940688 , 1.34779857, 1.90152835, 2.45525813,\n                       3.0089879 , 3.56271768, 4.11644746, 4.67017723, 5.22390701,\n                       5.77763679, 6.33136656, 6.88509634, 7.43882612, 7.99255589,\n                       8.54628567])], 'patches': [&lt;BarContainer object of 15 artists&gt;,\n                       &lt;BarContainer object of 15 artists&gt;, &lt;BarContainer object of 15 artists&gt;]}\n                ```\n\n            ![image](../_images/three-histogram.png)\n    \"\"\"\n    for key, val in kwargs.items():\n        if key not in self.default_options.keys():\n            raise ValueError(\n                f\"The given keyword argument:{key} is not correct, possible parameters are,\"\n                f\" {self.default_options}\"\n            )\n        else:\n            self.default_options[key] = val\n\n    fig, ax = plt.subplots(figsize=self.default_options[\"figsize\"])\n\n    n = []\n    bins = []\n    patches = []\n    bins_val = self.default_options[\"bins\"]\n    color = self.default_options[\"color\"]\n    alpha = self.default_options[\"alpha\"]\n    rwidth = self.default_options[\"rwidth\"]\n    if self.values.ndim == 2:\n        num_samples = self.values.shape[1]\n        if len(color) != num_samples:\n            raise ValueError(\n                f\"The number of colors:{len(color)} should be equal to the number of samples:{num_samples}\"\n            )\n    else:\n        num_samples = 1\n\n    for i in range(num_samples):\n        if self.values.ndim == 1:\n            vals = self.values\n        else:\n            vals = self.values[:, i]\n\n        n_i, bins_i, patches_i = ax.hist(\n            x=vals,\n            bins=bins_val,\n            color=color[i],\n            alpha=alpha,\n            rwidth=rwidth,\n        )\n        n.append(n_i)\n        bins.append(bins_i)\n        patches.append(patches_i)\n\n    plt.grid(axis=\"y\", alpha=self.default_options[\"grid_alpha\"])\n    plt.xlabel(\n        self.default_options[\"xlabel\"],\n        fontsize=self.default_options[\"xlabel_font_size\"],\n    )\n    plt.ylabel(\n        self.default_options[\"ylabel\"],\n        fontsize=self.default_options[\"ylabel_font_size\"],\n    )\n    plt.xticks(fontsize=self.default_options[\"xtick_font_size\"])\n    plt.yticks(fontsize=self.default_options[\"ytick_font_size\"])\n    hist = {\"n\": n, \"bins\": bins, \"patches\": patches}\n    plt.show()\n    return fig, ax, hist\n</code></pre>"},{"location":"md/statistics-class/#examples","title":"Examples","text":""},{"location":"md/statistics-class/#1d-data-example","title":"1D Data Example","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom cleopatra.statistics import Statistic\n\n# Create some random 1D data\nnp.random.seed(1)\ndata_1d = 4 + np.random.normal(0, 1.5, 200)\n\n# Create a Statistic object with the 1D data\nstat_plot_1d = Statistic(data_1d)\n\n# Generate a histogram plot for the 1D data\nfig_1d, ax_1d, hist_1d = stat_plot_1d.histogram()\n</code></pre>"},{"location":"md/statistics-class/#2d-data-example","title":"2D Data Example","text":"<pre><code># Create some random 2D data\ndata_2d = 4 + np.random.normal(0, 1.5, (200, 3))\n\n# Create a Statistic object with the 2D data\nstat_plot_2d = Statistic(data_2d, color=[\"red\", \"green\", \"blue\"], alpha=0.4, rwidth=0.8)\n\n# Generate a histogram plot for the 2D data\nfig_2d, ax_2d, hist_2d = stat_plot_2d.histogram()\n</code></pre>"},{"location":"md/styles-class/","title":"Styles Module","text":"<p>The <code>styles</code> module provides classes and functions for styling plots, including line styles, marker styles, scaling functions, and color normalization.</p>"},{"location":"md/styles-class/#styles-class","title":"Styles Class","text":""},{"location":"md/styles-class/#cleopatra.styles.Styles","title":"<code>cleopatra.styles.Styles</code>","text":"<p>Styles</p> Source code in <code>cleopatra/styles.py</code> <pre><code>class Styles:\n    \"\"\"Styles\"\"\"\n\n    line_styles = OrderedDict(\n        [\n            (\"solid\", (0, ())),  # 0\n            (\"loosely dotted\", (0, (1, 10))),  # 1\n            (\"dotted\", (0, (1, 5))),  # 2\n            (\"densely dotted\", (0, (1, 1))),  # 3\n            (\"loosely dashed\", (0, (5, 10))),  # 4\n            (\"dashed\", (0, (5, 5))),  # 5\n            (\"densely dashed\", (0, (5, 1))),  # 6\n            (\"loosely dashdotted\", (0, (3, 10, 1, 10))),  # 7\n            (\"dashdotted\", (0, (3, 5, 1, 5))),  # 8\n            (\"densely dashdotted\", (0, (3, 1, 1, 1))),  # 9\n            (\"loosely dashdotdotted\", (0, (3, 10, 1, 10, 1, 10))),  # 10\n            (\"dashdotdotted\", (0, (3, 5, 1, 5, 1, 5))),  # 11\n            (\"densely dashdotdotted\", (0, (3, 1, 1, 1, 1, 1))),  # 12\n            (\"densely dashdotdottededited\", (0, (6, 1, 1, 1, 1, 1))),  # 13\n        ]\n    )\n\n    marker_style_list = [\n        \"--o\",\n        \":D\",\n        \"-.H\",\n        \"--x\",\n        \":v\",\n        \"--|\",\n        \"-+\",\n        \"-^\",\n        \"--s\",\n        \"-.*\",\n        \"-.h\",\n    ]\n\n    @staticmethod\n    def get_line_style(style: Union[str, int] = \"loosely dotted\"):\n        \"\"\"LineStyle.\n\n        Line styles for plotting\n\n        Parameters\n        ----------\n        style : TYPE, optional\n            DESCRIPTION. The default is 'loosely dotted'.\n\n        Returns\n        -------\n        TYPE\n            DESCRIPTION.\n        \"\"\"\n        if isinstance(style, str):\n            try:\n                return Styles.line_styles[style]\n            except KeyError:\n                msg = (\n                    f\" The style name you entered-{style}-does not exist please\"\n                    \"choose from the available styles\"\n                )\n                print(msg)\n                print(list(Styles.line_styles))\n        else:\n            return list(Styles.line_styles.items())[style][1]\n\n    @staticmethod\n    def get_marker_style(style: int):\n        \"\"\"Marker styles for plotting.\n\n        Parameters\n        ----------\n        style: [int]\n            DESCRIPTION.\n\n        Returns\n        -------\n        TYPE\n            DESCRIPTION.\n        \"\"\"\n        if style &gt; len(Styles.marker_style_list) - 1:\n            style = style % len(Styles.marker_style_list)\n        return Styles.marker_style_list[style]\n</code></pre>"},{"location":"md/styles-class/#cleopatra.styles.Styles.get_line_style","title":"<code>get_line_style(style='loosely dotted')</code>  <code>staticmethod</code>","text":"<p>LineStyle.</p> <p>Line styles for plotting</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>TYPE</code> <p>DESCRIPTION. The default is 'loosely dotted'.</p> <code>'loosely dotted'</code> <p>Returns:</p> Type Description <code>TYPE</code> <p>DESCRIPTION.</p> Source code in <code>cleopatra/styles.py</code> <pre><code>@staticmethod\ndef get_line_style(style: Union[str, int] = \"loosely dotted\"):\n    \"\"\"LineStyle.\n\n    Line styles for plotting\n\n    Parameters\n    ----------\n    style : TYPE, optional\n        DESCRIPTION. The default is 'loosely dotted'.\n\n    Returns\n    -------\n    TYPE\n        DESCRIPTION.\n    \"\"\"\n    if isinstance(style, str):\n        try:\n            return Styles.line_styles[style]\n        except KeyError:\n            msg = (\n                f\" The style name you entered-{style}-does not exist please\"\n                \"choose from the available styles\"\n            )\n            print(msg)\n            print(list(Styles.line_styles))\n    else:\n        return list(Styles.line_styles.items())[style][1]\n</code></pre>"},{"location":"md/styles-class/#cleopatra.styles.Styles.get_marker_style","title":"<code>get_marker_style(style)</code>  <code>staticmethod</code>","text":"<p>Marker styles for plotting.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>int</code> <p>DESCRIPTION.</p> required <p>Returns:</p> Type Description <code>TYPE</code> <p>DESCRIPTION.</p> Source code in <code>cleopatra/styles.py</code> <pre><code>@staticmethod\ndef get_marker_style(style: int):\n    \"\"\"Marker styles for plotting.\n\n    Parameters\n    ----------\n    style: [int]\n        DESCRIPTION.\n\n    Returns\n    -------\n    TYPE\n        DESCRIPTION.\n    \"\"\"\n    if style &gt; len(Styles.marker_style_list) - 1:\n        style = style % len(Styles.marker_style_list)\n    return Styles.marker_style_list[style]\n</code></pre>"},{"location":"md/styles-class/#scale-class","title":"Scale Class","text":""},{"location":"md/styles-class/#cleopatra.styles.Scale","title":"<code>cleopatra.styles.Scale</code>","text":"<p>different scale object.</p> Source code in <code>cleopatra/styles.py</code> <pre><code>class Scale:\n    \"\"\"different scale object.\"\"\"\n\n    def __init__(self):\n        \"\"\"Different scale object.\"\"\"\n        pass\n\n    @staticmethod\n    def log_scale(val):\n        \"\"\"log_scale.\n\n            logarithmic scale\n\n        Parameters\n        ----------\n        val\n\n        Returns\n        -------\n        \"\"\"\n\n        # def scalar(val):\n        #     \"\"\"scalar.\n        #\n        #         scalar\n        #\n        #     Parameters\n        #     ----------\n        #     val\n        #\n        #     Returns\n        #     -------\n        #     \"\"\"\n        #   val = val + abs(minval) + 1\n        # return scalar\n        return np.log10(val)\n\n    @staticmethod\n    def power_scale(min_val) -&gt; float:\n        \"\"\"power_scale.\n\n            power scale\n\n        Parameters\n        ----------\n        min_val: float\n            minimum value.\n\n        Returns\n        -------\n        float:\n            power scale value.\n        \"\"\"\n\n        def scalar(val):\n            val = val + abs(min_val) + 1\n            return (val / 1000) ** 2\n\n        return scalar\n\n    @staticmethod\n    def identity_scale(min_val, max_val):\n        \"\"\"identity_scale.\n\n            identity_scale\n\n        Parameters\n        ----------\n        min_val\n        max_val\n\n        Returns\n        -------\n        \"\"\"\n\n        def scalar(val):\n            return 2\n\n        return scalar\n\n    @staticmethod\n    def rescale(old_value, old_min, old_max, new_min, new_max):\n        \"\"\"Rescale.\n\n        Rescale method rescales a value between two boundaries to a new value between two other boundaries\n\n        Parameters\n        ----------\n        old_value: float\n            The value that need to be transformed.\n        old_min: float\n            min old value\n        old_max: float\n            max old value\n        new_min: float\n            min new value\n        new_max: float\n            max new value\n\n        Returns\n        -------\n        new_value: float\n            transformed new value\n        \"\"\"\n        old_range = old_max - old_min\n        new_range = new_max - new_min\n        new_value = (((old_value - old_min) * new_range) / old_range) + new_min\n\n        return new_value\n</code></pre>"},{"location":"md/styles-class/#cleopatra.styles.Scale.__init__","title":"<code>__init__()</code>","text":"<p>Different scale object.</p> Source code in <code>cleopatra/styles.py</code> <pre><code>def __init__(self):\n    \"\"\"Different scale object.\"\"\"\n    pass\n</code></pre>"},{"location":"md/styles-class/#cleopatra.styles.Scale.identity_scale","title":"<code>identity_scale(min_val, max_val)</code>  <code>staticmethod</code>","text":"<p>identity_scale.</p> <pre><code>identity_scale\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>min_val</code> required <code>max_val</code> required Source code in <code>cleopatra/styles.py</code> <pre><code>@staticmethod\ndef identity_scale(min_val, max_val):\n    \"\"\"identity_scale.\n\n        identity_scale\n\n    Parameters\n    ----------\n    min_val\n    max_val\n\n    Returns\n    -------\n    \"\"\"\n\n    def scalar(val):\n        return 2\n\n    return scalar\n</code></pre>"},{"location":"md/styles-class/#cleopatra.styles.Scale.log_scale","title":"<code>log_scale(val)</code>  <code>staticmethod</code>","text":"<p>log_scale.</p> <pre><code>logarithmic scale\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>val</code> required Source code in <code>cleopatra/styles.py</code> <pre><code>@staticmethod\ndef log_scale(val):\n    \"\"\"log_scale.\n\n        logarithmic scale\n\n    Parameters\n    ----------\n    val\n\n    Returns\n    -------\n    \"\"\"\n\n    # def scalar(val):\n    #     \"\"\"scalar.\n    #\n    #         scalar\n    #\n    #     Parameters\n    #     ----------\n    #     val\n    #\n    #     Returns\n    #     -------\n    #     \"\"\"\n    #   val = val + abs(minval) + 1\n    # return scalar\n    return np.log10(val)\n</code></pre>"},{"location":"md/styles-class/#cleopatra.styles.Scale.power_scale","title":"<code>power_scale(min_val)</code>  <code>staticmethod</code>","text":"<p>power_scale.</p> <pre><code>power scale\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>min_val</code> <p>minimum value.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>power scale value.</p> Source code in <code>cleopatra/styles.py</code> <pre><code>@staticmethod\ndef power_scale(min_val) -&gt; float:\n    \"\"\"power_scale.\n\n        power scale\n\n    Parameters\n    ----------\n    min_val: float\n        minimum value.\n\n    Returns\n    -------\n    float:\n        power scale value.\n    \"\"\"\n\n    def scalar(val):\n        val = val + abs(min_val) + 1\n        return (val / 1000) ** 2\n\n    return scalar\n</code></pre>"},{"location":"md/styles-class/#cleopatra.styles.Scale.rescale","title":"<code>rescale(old_value, old_min, old_max, new_min, new_max)</code>  <code>staticmethod</code>","text":"<p>Rescale.</p> <p>Rescale method rescales a value between two boundaries to a new value between two other boundaries</p> <p>Parameters:</p> Name Type Description Default <code>old_value</code> <p>The value that need to be transformed.</p> required <code>old_min</code> <p>min old value</p> required <code>old_max</code> <p>max old value</p> required <code>new_min</code> <p>min new value</p> required <code>new_max</code> <p>max new value</p> required <p>Returns:</p> Name Type Description <code>new_value</code> <code>float</code> <p>transformed new value</p> Source code in <code>cleopatra/styles.py</code> <pre><code>@staticmethod\ndef rescale(old_value, old_min, old_max, new_min, new_max):\n    \"\"\"Rescale.\n\n    Rescale method rescales a value between two boundaries to a new value between two other boundaries\n\n    Parameters\n    ----------\n    old_value: float\n        The value that need to be transformed.\n    old_min: float\n        min old value\n    old_max: float\n        max old value\n    new_min: float\n        min new value\n    new_max: float\n        max new value\n\n    Returns\n    -------\n    new_value: float\n        transformed new value\n    \"\"\"\n    old_range = old_max - old_min\n    new_range = new_max - new_min\n    new_value = (((old_value - old_min) * new_range) / old_range) + new_min\n\n    return new_value\n</code></pre>"},{"location":"md/styles-class/#midpointnormalize-class","title":"MidpointNormalize Class","text":""},{"location":"md/styles-class/#cleopatra.styles.MidpointNormalize","title":"<code>cleopatra.styles.MidpointNormalize</code>","text":"<p>               Bases: <code>Normalize</code></p> <p>MidpointNormalize.</p> <p>!TODO needs docs</p> Source code in <code>cleopatra/styles.py</code> <pre><code>class MidpointNormalize(colors.Normalize):\n    \"\"\"MidpointNormalize.\n\n    !TODO needs docs\n    \"\"\"\n\n    def __init__(self, vmin=None, vmax=None, midpoint=None, clip=False):\n        \"\"\"MidpointNormalize.\n\n        Parameters\n        ----------\n        vmin\n        vmax\n        midpoint\n        clip\n        \"\"\"\n        self.midpoint = midpoint\n        colors.Normalize.__init__(self, vmin, vmax, clip)\n\n    def __call__(self, value, clip=None):\n        \"\"\"MidpointNormalize.\n\n        ! TODO needs docs\n\n        Parameters\n        ----------\n        value : TYPE\n            DESCRIPTION.\n        clip : TYPE, optional\n            DESCRIPTION. The default is None.\n\n        Returns\n        -------\n        TYPE\n            DESCRIPTION.\n        \"\"\"\n        # I'm ignoring masked values and all kinds of edge cases to make a\n        # simple example...\n        x, y = [self.vmin, self.midpoint, self.vmax], [0, 0.5, 1]\n\n        return np.ma.masked_array(np.interp(value, x, y))\n</code></pre>"},{"location":"md/styles-class/#cleopatra.styles.MidpointNormalize.__call__","title":"<code>__call__(value, clip=None)</code>","text":"<p>MidpointNormalize.</p> <p>! TODO needs docs</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>TYPE</code> <p>DESCRIPTION.</p> required <code>clip</code> <code>TYPE</code> <p>DESCRIPTION. The default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>TYPE</code> <p>DESCRIPTION.</p> Source code in <code>cleopatra/styles.py</code> <pre><code>def __call__(self, value, clip=None):\n    \"\"\"MidpointNormalize.\n\n    ! TODO needs docs\n\n    Parameters\n    ----------\n    value : TYPE\n        DESCRIPTION.\n    clip : TYPE, optional\n        DESCRIPTION. The default is None.\n\n    Returns\n    -------\n    TYPE\n        DESCRIPTION.\n    \"\"\"\n    # I'm ignoring masked values and all kinds of edge cases to make a\n    # simple example...\n    x, y = [self.vmin, self.midpoint, self.vmax], [0, 0.5, 1]\n\n    return np.ma.masked_array(np.interp(value, x, y))\n</code></pre>"},{"location":"md/styles-class/#cleopatra.styles.MidpointNormalize.__init__","title":"<code>__init__(vmin=None, vmax=None, midpoint=None, clip=False)</code>","text":"<p>MidpointNormalize.</p> <p>Parameters:</p> Name Type Description Default <code>vmin</code> <code>None</code> <code>vmax</code> <code>None</code> <code>midpoint</code> <code>None</code> <code>clip</code> <code>False</code> Source code in <code>cleopatra/styles.py</code> <pre><code>def __init__(self, vmin=None, vmax=None, midpoint=None, clip=False):\n    \"\"\"MidpointNormalize.\n\n    Parameters\n    ----------\n    vmin\n    vmax\n    midpoint\n    clip\n    \"\"\"\n    self.midpoint = midpoint\n    colors.Normalize.__init__(self, vmin, vmax, clip)\n</code></pre>"},{"location":"md/styles-class/#examples","title":"Examples","text":""},{"location":"md/styles-class/#log-scale","title":"Log Scale","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom cleopatra.styles import Scale\n\n# Create some data with a wide range of values\ndata = np.array([0.1, 1, 10, 100, 1000])\n\n# Apply log scale\nscale = Scale()\nlog_data = scale.log_scale(data)\n\n# Plot the original and log-scaled data\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 4))\nax1.plot(data)\nax1.set_title('Original Data')\nax2.plot(log_data)\nax2.set_title('Log-Scaled Data')\nplt.tight_layout()\n</code></pre>"},{"location":"md/styles-class/#power-scale","title":"Power Scale","text":"<pre><code># Apply power scale with gamma=0.5 (square root)\npower_data = scale.power_scale(data)(0.5)\n\n# Plot the original and power-scaled data\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 4))\nax1.plot(data)\nax1.set_title('Original Data')\nax2.plot(power_data)\nax2.set_title('Power-Scaled Data (gamma=0.5)')\nplt.tight_layout()\n</code></pre>"},{"location":"md/styles-class/#midpoint-normalize","title":"Midpoint Normalize","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom cleopatra.styles import MidpointNormalize\nimport matplotlib.colors as colors\n\n# Create some data with positive and negative values\ndata = np.random.uniform(-10, 10, (10, 10))\n\n# Create a figure with two subplots\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 4))\n\n# Plot with standard normalization\nim1 = ax1.imshow(data, cmap='RdBu_r', norm=colors.Normalize(vmin=-10, vmax=10))\nax1.set_title('Standard Normalization')\nplt.colorbar(im1, ax=ax1)\n\n# Plot with midpoint normalization (midpoint at 0)\nim2 = ax2.imshow(data, cmap='RdBu_r', norm=MidpointNormalize(vmin=-10, vmax=10, midpoint=0))\nax2.set_title('Midpoint Normalization')\nplt.colorbar(im2, ax=ax2)\n\nplt.tight_layout()\n</code></pre>"}]}